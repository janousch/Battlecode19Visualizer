declare global {
	function require(name: string): any;
}

declare function gc() : void;
declare type UnrealEngineClass = any;
declare type timeout_handle = any;
declare function setTimeout(fn : (milliseconds: number) => void, timeout : number) : timeout_handle;
declare function clearTimeout(handle : timeout_handle) : void;
declare class UnrealEngineMulticastDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class UnrealEngineDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class Process {
	nextTick(fn : (number) => void): void;
}

declare var process : Process;

declare class Memory {
	exec(ab : ArrayBuffer, fn : (ab : ArrayBuffer) => void): void;
	access(obj : JavascriptMemoryObject): ArrayBuffer;
}

declare var memory : Memory;

declare var GEngine : Engine;

declare var GWorld : World;

declare var Root : JavascriptComponent | any;

declare namespace JSX {
	interface IntrinsicElements {
		[elemName: string]: any;
		div: any;
		span: any;
		text: any;
		img: any;
		input: any;
	}
}

declare class Field extends UObject { 
	static Load(ResourceName: string): Field;
	static Find(Outer: UObject, ResourceName: string): Field;
	static GetDefaultObject(): Field;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Field;
	static C(Other: UObject | any): Field;
	GetMetaData(Key: string): string;
	static GetMetaData(Field: Field,Key: string): string;
}

declare class Enum extends Field { 
	static Load(ResourceName: string): Enum;
	static Find(Outer: UObject, ResourceName: string): Enum;
	static GetDefaultObject(): Enum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Enum;
	static C(Other: UObject | any): Enum;
	GetEnumeratorName(EnumeratorValue: number): string;
	GetEnumeratorUserFriendlyName(EnumeratorValue: number): string;
	GetEnumeratorValueFromIndex(EnumeratorIndex: number): number;
	GetValidValue(EnumeratorValue: number): number;
	static GetEnumeratorName(Enum: Enum,EnumeratorValue: number): string;
	static GetEnumeratorUserFriendlyName(Enum: Enum,EnumeratorValue: number): string;
	static GetEnumeratorValueFromIndex(Enum: Enum,EnumeratorIndex: number): number;
	static GetValidValue(Enum: Enum,EnumeratorValue: number): number;
}

declare class LayerActorStats { 
	Type: UnrealEngineClass;
	Total: number;
	clone() : LayerActorStats;
	static C(Other: UObject | any): LayerActorStats;
}

declare class Layer extends UObject { 
	LayerName: string;
	bIsVisible: boolean;
	ActorStats: LayerActorStats[];
	static Load(ResourceName: string): Layer;
	static Find(Outer: UObject, ResourceName: string): Layer;
	static GetDefaultObject(): Layer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Layer;
	static C(Other: UObject | any): Layer;
}

declare type ETickingGroup = 'TG_PrePhysics' | 'TG_StartPhysics' | 'TG_DuringPhysics' | 'TG_EndPhysics' | 'TG_PostPhysics' | 'TG_PostUpdateWork' | 'TG_LastDemotable' | 'TG_NewlySpawned';
declare var ETickingGroup : { TG_PrePhysics:'TG_PrePhysics',TG_StartPhysics:'TG_StartPhysics',TG_DuringPhysics:'TG_DuringPhysics',TG_EndPhysics:'TG_EndPhysics',TG_PostPhysics:'TG_PostPhysics',TG_PostUpdateWork:'TG_PostUpdateWork',TG_LastDemotable:'TG_LastDemotable',TG_NewlySpawned:'TG_NewlySpawned', };
declare class TickFunction { 
	TickGroup: ETickingGroup;
	EndTickGroup: ETickingGroup;
	bTickEvenWhenPaused: boolean;
	bCanEverTick: boolean;
	bStartWithTickEnabled: boolean;
	bAllowTickOnDedicatedServer: boolean;
	TickInterval: number;
	clone() : TickFunction;
	static C(Other: UObject | any): TickFunction;
}

declare class ActorTickFunction extends TickFunction { 
	clone() : ActorTickFunction;
	static C(Other: UObject | any): ActorTickFunction;
}

declare type ENetRole = 'ROLE_None' | 'ROLE_SimulatedProxy' | 'ROLE_AutonomousProxy' | 'ROLE_Authority';
declare var ENetRole : { ROLE_None:'ROLE_None',ROLE_SimulatedProxy:'ROLE_SimulatedProxy',ROLE_AutonomousProxy:'ROLE_AutonomousProxy',ROLE_Authority:'ROLE_Authority', };
declare class Box2D { 
	Min: Vector2D;
	Max: Vector2D;
	bIsValid: number;
	clone() : Box2D;
	static C(Other: UObject | any): Box2D;
}

declare class Vector2D { 
	X: number;
	Y: number;
	clone() : Vector2D;
	static C(Other: UObject | any): Vector2D;
	Conv_Vector2dToText(): string;
	Conv_Vector2dToString(): string;
	Add_Vector2DFloat(B: number): Vector2D;
	Add_Vector2DVector2D(B: Vector2D): Vector2D;
	BreakVector2D(X?: number,Y?: number): {X: number, Y: number};
	Conv_Vector2DToVector(Z: number): Vector;
	CrossProduct2D(B: Vector2D): number;
	Divide_Vector2DFloat(B: number): Vector2D;
	Divide_Vector2DVector2D(B: Vector2D): Vector2D;
	DotProduct2D(B: Vector2D): number;
	EqualEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	MakeBox2D(Max: Vector2D): Box2D;
	Multiply_Vector2DFloat(B: number): Vector2D;
	Multiply_Vector2DVector2D(B: Vector2D): Vector2D;
	Normal2D(): Vector2D;
	NotEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	Subtract_Vector2DFloat(B: number): Vector2D;
	Subtract_Vector2DVector2D(B: Vector2D): Vector2D;
	Vector2DInterpTo(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	Vector2DInterpTo_Constant(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	VSize2D(): number;
	VSize2DSquared(): number;
	SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean): void;
	static Conv_Vector2dToText(InVec: Vector2D): string;
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Add_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static BreakVector2D(InVec: Vector2D,X?: number,Y?: number): {X: number, Y: number};
	static Conv_Vector2DToVector(InVector2D: Vector2D,Z: number): Vector;
	static CrossProduct2D(A: Vector2D,B: Vector2D): number;
	static Divide_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Divide_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static DotProduct2D(A: Vector2D,B: Vector2D): number;
	static EqualEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static MakeBox2D(Min: Vector2D,Max: Vector2D): Box2D;
	static Multiply_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Normal2D(A: Vector2D): Vector2D;
	static NotEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static Subtract_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static VSize2D(A: Vector2D): number;
	static VSize2DSquared(A: Vector2D): number;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean): void;
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	static MakeVector2D(X: number,Y: number): Vector2D;
	static NextSobolCell2D(Index: number,NumCells: number,PreviousValue: Vector2D): Vector2D;
	static RandomSobolCell2D(Index: number,NumCells: number,Cell: Vector2D,Seed: Vector2D): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
}

declare class ProcMeshTangent { 
	TangentX: Vector;
	bFlipTangentY: boolean;
	clone() : ProcMeshTangent;
	static C(Other: UObject | any): ProcMeshTangent;
}

declare type ETrackedDeviceType = 'None' | 'HMD' | 'LTouch' | 'RTouch' | 'Touch' | 'DeviceObjectZero' | 'All';
declare var ETrackedDeviceType : { None:'None',HMD:'HMD',LTouch:'LTouch',RTouch:'RTouch',Touch:'Touch',DeviceObjectZero:'DeviceObjectZero',All:'All', };
declare class Color { 
	B: number;
	G: number;
	R: number;
	A: number;
	clone() : Color;
	static C(Other: UObject | any): Color;
	Conv_ColorToLinearColor(): LinearColor;
	static Conv_ColorToLinearColor(InColor: Color): LinearColor;
}

declare class LinearColor { 
	R: number;
	G: number;
	B: number;
	A: number;
	clone() : LinearColor;
	static C(Other: UObject | any): LinearColor;
	Conv_ColorToText(): string;
	Conv_ColorToString(): string;
	BreakColor(R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	CInterpTo(Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	Conv_LinearColorToColor(): Color;
	Conv_LinearColorToVector(): Vector;
	HSVToRGB_Vector(RGB?: LinearColor): {RGB: LinearColor};
	LinearColorLerp(B: LinearColor,Alpha: number): LinearColor;
	LinearColorLerpUsingHSV(B: LinearColor,Alpha: number): LinearColor;
	Multiply_LinearColorFloat(B: number): LinearColor;
	Multiply_LinearColorLinearColor(B: LinearColor): LinearColor;
	RGBToHSV(H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	RGBToHSV_Vector(HSV?: LinearColor): {HSV: LinearColor};
	SelectColor(B: LinearColor,bPickA: boolean): LinearColor;
	static Conv_ColorToText(InColor: LinearColor): string;
	static Conv_ColorToString(InColor: LinearColor): string;
	static BreakColor(InColor: LinearColor,R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	static CInterpTo(Current: LinearColor,Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	static Conv_LinearColorToColor(InLinearColor: LinearColor): Color;
	static Conv_LinearColorToVector(InLinearColor: LinearColor): Vector;
	static HSVToRGB_Vector(HSV: LinearColor,RGB?: LinearColor): {RGB: LinearColor};
	static LinearColorLerp(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	static LinearColorLerpUsingHSV(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	static Multiply_LinearColorFloat(A: LinearColor,B: number): LinearColor;
	static Multiply_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static RGBToHSV(InColor: LinearColor,H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	static RGBToHSV_Vector(RGB: LinearColor,HSV?: LinearColor): {HSV: LinearColor};
	static SelectColor(A: LinearColor,B: LinearColor,bPickA: boolean): LinearColor;
	static Conv_FloatToLinearColor(InFloat: number): LinearColor;
	static HSVToRGB(H: number,S: number,V: number,A: number): LinearColor;
	static MakeColor(R: number,G: number,B: number,A: number): LinearColor;
}

declare type EOrientPositionSelector = 'Orientation' | 'Position' | 'OrientationAndPosition';
declare var EOrientPositionSelector : { Orientation:'Orientation',Position:'Position',OrientationAndPosition:'OrientationAndPosition', };
declare type EEasingFunc = 'Linear' | 'Step' | 'SinusoidalIn' | 'SinusoidalOut' | 'SinusoidalInOut' | 'EaseIn' | 'EaseOut' | 'EaseInOut' | 'ExpoIn' | 'ExpoOut' | 'ExpoInOut' | 'CircularIn' | 'CircularOut' | 'CircularInOut';
declare var EEasingFunc : { Linear:'Linear',Step:'Step',SinusoidalIn:'SinusoidalIn',SinusoidalOut:'SinusoidalOut',SinusoidalInOut:'SinusoidalInOut',EaseIn:'EaseIn',EaseOut:'EaseOut',EaseInOut:'EaseInOut',ExpoIn:'ExpoIn',ExpoOut:'ExpoOut',ExpoInOut:'ExpoInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut', };
declare class RandomStream { 
	InitialSeed: number;
	Seed: number;
	clone() : RandomStream;
	static C(Other: UObject | any): RandomStream;
	BreakRandomStream(InitialSeed?: number): {InitialSeed: number};
	RandomBoolFromStream(): boolean;
	RandomFloatFromStream(): number;
	RandomUnitVectorFromStream(): Vector;
	ResetRandomStream(): void;
	SeedRandomStream(): {Stream: RandomStream};
	SetRandomStreamSeed(NewSeed?: number): {Stream: RandomStream};
	static BreakRandomStream(InRandomStream: RandomStream,InitialSeed?: number): {InitialSeed: number};
	static RandomBoolFromStream(Stream: RandomStream): boolean;
	static RandomFloatFromStream(Stream: RandomStream): number;
	static RandomUnitVectorFromStream(Stream: RandomStream): Vector;
	static ResetRandomStream(Stream: RandomStream): void;
	static SeedRandomStream(Stream?: RandomStream): {Stream: RandomStream};
	static SetRandomStreamSeed(Stream?: RandomStream,NewSeed?: number): {Stream: RandomStream};
	static MakeRandomStream(InitialSeed: number): RandomStream;
}

declare class Rotator { 
	Pitch: number;
	Yaw: number;
	Roll: number;
	clone() : Rotator;
	static C(Other: UObject | any): Rotator;
	GetBaseRotationAndBaseOffsetInMeters(OutBaseOffsetInMeters?: Vector): {OutRotation: Rotator, OutBaseOffsetInMeters: Vector};
	GetBaseRotationAndPositionOffset(OutPosOffset?: Vector): {OutRot: Rotator, OutPosOffset: Vector};
	GetPose(DevicePosition?: Vector,NeckPosition?: Vector,bUseOrienationForPlayerCamera?: boolean,bUsePositionForPlayerCamera?: boolean,PositionScale?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector, NeckPosition: Vector};
	SetBaseRotationAndBaseOffsetInMeters(BaseOffsetInMeters: Vector,Options: EOrientPositionSelector): void;
	SetBaseRotationAndPositionOffset(PosOffset: Vector,Options: EOrientPositionSelector): void;
	Conv_RotatorToText(): string;
	Conv_RotatorToString(): string;
	BreakRotator(Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	BreakRotIntoAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	ComposeRotators(B: Rotator): Rotator;
	Conv_RotatorToVector(): Vector;
	EqualEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	GetAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	GetForwardVector(): Vector;
	GetRightVector(): Vector;
	GetUpVector(): Vector;
	Multiply_RotatorFloat(B: number): Rotator;
	Multiply_RotatorInt(B: number): Rotator;
	NegateRotator(): Rotator;
	NormalizedDeltaRotator(B: Rotator): Rotator;
	NotEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	REase(B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	RInterpTo(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RInterpTo_Constant(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RLerp(B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	SelectRotator(B: Rotator,bPickA: boolean): Rotator;
	IsValidAIRotation(): boolean;
	GetOrientationAndPosition(DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static GetBaseRotationAndBaseOffsetInMeters(OutRotation?: Rotator,OutBaseOffsetInMeters?: Vector): {OutRotation: Rotator, OutBaseOffsetInMeters: Vector};
	static GetBaseRotationAndPositionOffset(OutRot?: Rotator,OutPosOffset?: Vector): {OutRot: Rotator, OutPosOffset: Vector};
	static GetPose(DeviceRotation?: Rotator,DevicePosition?: Vector,NeckPosition?: Vector,bUseOrienationForPlayerCamera?: boolean,bUsePositionForPlayerCamera?: boolean,PositionScale?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector, NeckPosition: Vector};
	static SetBaseRotationAndBaseOffsetInMeters(Rotation: Rotator,BaseOffsetInMeters: Vector,Options: EOrientPositionSelector): void;
	static SetBaseRotationAndPositionOffset(BaseRot: Rotator,PosOffset: Vector,Options: EOrientPositionSelector): void;
	static Conv_RotatorToText(InRot: Rotator): string;
	static Conv_RotatorToString(InRot: Rotator): string;
	static BreakRotator(InRot: Rotator,Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	static BreakRotIntoAxes(InRot: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static ComposeRotators(A: Rotator,B: Rotator): Rotator;
	static Conv_RotatorToVector(InRot: Rotator): Vector;
	static EqualEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static GetAxes(A: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static GetForwardVector(InRot: Rotator): Vector;
	static GetRightVector(InRot: Rotator): Vector;
	static GetUpVector(InRot: Rotator): Vector;
	static Multiply_RotatorFloat(A: Rotator,B: number): Rotator;
	static Multiply_RotatorInt(A: Rotator,B: number): Rotator;
	static NegateRotator(A: Rotator): Rotator;
	static NormalizedDeltaRotator(A: Rotator,B: Rotator): Rotator;
	static NotEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static REase(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	static RInterpTo(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RInterpTo_Constant(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RLerp(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	static SelectRotator(A: Rotator,B: Rotator,bPickA: boolean): Rotator;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static MakeRotator(Roll: number,Pitch: number,Yaw: number): Rotator;
	static RandomRotator(bRoll: boolean): Rotator;
	static RandomRotatorFromStream(bRoll: boolean,Stream: RandomStream): Rotator;
}

declare class Quat { 
	X: number;
	Y: number;
	Z: number;
	W: number;
	clone() : Quat;
	static C(Other: UObject | any): Quat;
}

declare type ELerpInterpolationMode = 'QuatInterp' | 'EulerInterp' | 'DualQuatInterp';
declare var ELerpInterpolationMode : { QuatInterp:'QuatInterp',EulerInterp:'EulerInterp',DualQuatInterp:'DualQuatInterp', };
declare class Transform { 
	Rotation: Quat;
	Translation: Vector;
	Scale3D: Vector;
	clone() : Transform;
	static C(Other: UObject | any): Transform;
	Conv_TransformToText(): string;
	Conv_TransformToString(): string;
	BreakTransform(Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	ComposeTransforms(B: Transform): Transform;
	ConvertTransformToRelative(ParentTransform: Transform): Transform;
	EqualEqual_TransformTransform(B: Transform): boolean;
	InverseTransformDirection(Direction: Vector): Vector;
	InverseTransformLocation(Location: Vector): Vector;
	InverseTransformRotation(Rotation: Rotator): Rotator;
	InvertTransform(): Transform;
	NearlyEqual_TransformTransform(B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	SelectTransform(B: Transform,bPickA: boolean): Transform;
	TEase(B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	TInterpTo(Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	TLerp(B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	TransformDirection(Direction: Vector): Vector;
	TransformLocation(Location: Vector): Vector;
	TransformRotation(Rotation: Rotator): Rotator;
	K2_LookAt(TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	static Conv_TransformToText(InTrans: Transform): string;
	static Conv_TransformToString(InTrans: Transform): string;
	static BreakTransform(InTransform: Transform,Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	static ComposeTransforms(A: Transform,B: Transform): Transform;
	static ConvertTransformToRelative(Transform: Transform,ParentTransform: Transform): Transform;
	static EqualEqual_TransformTransform(A: Transform,B: Transform): boolean;
	static InverseTransformDirection(T: Transform,Direction: Vector): Vector;
	static InverseTransformLocation(T: Transform,Location: Vector): Vector;
	static InverseTransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static InvertTransform(T: Transform): Transform;
	static NearlyEqual_TransformTransform(A: Transform,B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	static SelectTransform(A: Transform,B: Transform,bPickA: boolean): Transform;
	static TEase(A: Transform,B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	static TInterpTo(Current: Transform,Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	static TLerp(A: Transform,B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	static TransformDirection(T: Transform,Direction: Vector): Vector;
	static TransformLocation(T: Transform,Location: Vector): Vector;
	static TransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static K2_LookAt(CurrentTransform: Transform,TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
}

declare class IntVector { 
	X: number;
	Y: number;
	Z: number;
	clone() : IntVector;
	static C(Other: UObject | any): IntVector;
	Conv_IntVectorToString(): string;
	Conv_IntVectorToVector(): Vector;
	static Conv_IntVectorToString(InIntVec: IntVector): string;
	static Conv_IntVectorToVector(InIntVector: IntVector): Vector;
	static Conv_IntToIntVector(InInt: number): IntVector;
}

declare class Plane extends Vector { 
	W: number;
	clone() : Plane;
	static C(Other: UObject | any): Plane;
}

declare class Box { 
	Min: Vector;
	Max: Vector;
	IsValid: number;
	clone() : Box;
	static C(Other: UObject | any): Box;
}

declare class VectorSpringState { 
	clone() : VectorSpringState;
	static C(Other: UObject | any): VectorSpringState;
	ResetVectorSpringState(): {SpringState: VectorSpringState};
	static ResetVectorSpringState(SpringState?: VectorSpringState): {SpringState: VectorSpringState};
}

declare class Vector { 
	X: number;
	Y: number;
	Z: number;
	clone() : Vector;
	static C(Other: UObject | any): Vector;
	SegmentIntersection2D(SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	GenerateBoxMesh(Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	GetRawSensorData(LinearAcceleration?: Vector,AngularVelocity?: Vector,LinearVelocity?: Vector,TimeInSeconds?: number,DeviceType?: DeviceType): {AngularAcceleration: Vector, LinearAcceleration: Vector, AngularVelocity: Vector, LinearVelocity: Vector, TimeInSeconds: number};
	SetPositionScale3D(): void;
	Conv_VectorToText(): string;
	Conv_VectorToString(): string;
	Add_VectorFloat(B: number): Vector;
	Add_VectorInt(B: number): Vector;
	Add_VectorVector(B: Vector): Vector;
	BreakVector(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	ClampVectorSize(Min: number,Max: number): Vector;
	Conv_VectorToLinearColor(): LinearColor;
	Conv_VectorToRotator(): Rotator;
	Conv_VectorToTransform(): Transform;
	Conv_VectorToVector2D(): Vector2D;
	Cross_VectorVector(B: Vector): Vector;
	Divide_VectorFloat(B: number): Vector;
	Divide_VectorInt(B: number): Vector;
	Divide_VectorVector(B: Vector): Vector;
	Dot_VectorVector(B: Vector): number;
	EqualEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	FindClosestPointOnLine(LineOrigin: Vector,LineDirection: Vector): Vector;
	FindClosestPointOnSegment(SegmentStart: Vector,SegmentEnd: Vector): Vector;
	FindLookAtRotation(Target: Vector): Rotator;
	FindNearestPointsOnLineSegments(Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	FTruncVector(): IntVector;
	GetAzimuthAndElevation(ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	GetDirectionUnitVector(To: Vector): Vector;
	GetMaxElement(): number;
	GetMinElement(): number;
	GetPointDistanceToLine(LineOrigin: Vector,LineDirection: Vector): number;
	GetPointDistanceToSegment(SegmentStart: Vector,SegmentEnd: Vector): number;
	GetReflectionVector(SurfaceNormal: Vector): Vector;
	GetYawPitchFromVector(Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	GreaterGreater_VectorRotator(B: Rotator): Vector;
	IsPointInBox(BoxOrigin: Vector,BoxExtent: Vector): boolean;
	IsPointInBoxWithTransform(BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	LessLess_VectorRotator(B: Rotator): Vector;
	LinePlaneIntersection(LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	LinePlaneIntersection_OriginNormal(LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	MakeBox(Max: Vector): Box;
	MakePlaneFromPointAndNormal(Normal: Vector): Plane;
	MakeRotationFromAxes(Right: Vector,Up: Vector): Rotator;
	MakeRotFromX(): Rotator;
	MakeRotFromXY(Y: Vector): Rotator;
	MakeRotFromXZ(Z: Vector): Rotator;
	MakeRotFromY(): Rotator;
	MakeRotFromYX(X: Vector): Rotator;
	MakeRotFromYZ(Z: Vector): Rotator;
	MakeRotFromZ(): Rotator;
	MakeRotFromZX(X: Vector): Rotator;
	MakeRotFromZY(Y: Vector): Rotator;
	MakeTransform(Rotation: Rotator,Scale: Vector): Transform;
	MirrorVectorByNormal(InNormal: Vector): Vector;
	Multiply_VectorFloat(B: number): Vector;
	Multiply_VectorInt(B: number): Vector;
	Multiply_VectorVector(B: Vector): Vector;
	NegateVector(): Vector;
	Normal(): Vector;
	NotEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	ProjectPointOnToPlane(PlaneBase: Vector,PlaneNormal: Vector): Vector;
	ProjectVectorOnToPlane(PlaneNormal: Vector): Vector;
	ProjectVectorOnToVector(Target: Vector): Vector;
	RandomPointInBoundingBox(BoxExtent: Vector): Vector;
	RandomUnitVectorInConeInDegrees(ConeHalfAngleInDegrees: number): Vector;
	RandomUnitVectorInConeInDegreesFromStream(ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInRadians(ConeHalfAngleInRadians: number): Vector;
	RandomUnitVectorInConeInRadiansFromStream(ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInDegrees(MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	RandomUnitVectorInEllipticalConeInDegreesFromStream(MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInRadians(MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	RandomUnitVectorInEllipticalConeInRadiansFromStream(MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	RotateAngleAxis(AngleDeg: number,Axis: Vector): Vector;
	RotatorFromAxisAndAngle(Angle: number): Rotator;
	SelectVector(B: Vector,bPickA: boolean): Vector;
	Subtract_VectorFloat(B: number): Vector;
	Subtract_VectorInt(B: number): Vector;
	Subtract_VectorVector(B: Vector): Vector;
	VEase(B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	VectorSpringInterp(Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number): {SpringState: VectorSpringState, $: Vector};
	VInterpTo(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VInterpTo_Constant(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VLerp(B: Vector,Alpha: number): Vector;
	VSize(): number;
	VSizeSquared(): number;
	K2_TwoBoneIK(JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	IsValidAIDirection(): boolean;
	IsValidAILocation(): boolean;
	GetPositionalTrackingCameraParameters(CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	GetTrackingSensorParameters(Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static GetRawSensorData(AngularAcceleration?: Vector,LinearAcceleration?: Vector,AngularVelocity?: Vector,LinearVelocity?: Vector,TimeInSeconds?: number,DeviceType?: DeviceType): {AngularAcceleration: Vector, LinearAcceleration: Vector, AngularVelocity: Vector, LinearVelocity: Vector, TimeInSeconds: number};
	static SetPositionScale3D(PosScale3D: Vector): void;
	static Conv_VectorToText(InVec: Vector): string;
	static Conv_VectorToString(InVec: Vector): string;
	static Add_VectorFloat(A: Vector,B: number): Vector;
	static Add_VectorInt(A: Vector,B: number): Vector;
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	static BreakVector(InVec: Vector,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static ClampVectorSize(A: Vector,Min: number,Max: number): Vector;
	static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
	static Conv_VectorToRotator(InVec: Vector): Rotator;
	static Conv_VectorToTransform(InLocation: Vector): Transform;
	static Conv_VectorToVector2D(InVector: Vector): Vector2D;
	static Cross_VectorVector(A: Vector,B: Vector): Vector;
	static Divide_VectorFloat(A: Vector,B: number): Vector;
	static Divide_VectorInt(A: Vector,B: number): Vector;
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	static Dot_VectorVector(A: Vector,B: Vector): number;
	static EqualEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	static FTruncVector(InVector: Vector): IntVector;
	static GetAzimuthAndElevation(InDirection: Vector,ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	static GetDirectionUnitVector(From: Vector,To: Vector): Vector;
	static GetMaxElement(A: Vector): number;
	static GetMinElement(A: Vector): number;
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	static GetReflectionVector(Direction: Vector,SurfaceNormal: Vector): Vector;
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	static GreaterGreater_VectorRotator(A: Vector,B: Rotator): Vector;
	static IsPointInBox(Point: Vector,BoxOrigin: Vector,BoxExtent: Vector): boolean;
	static IsPointInBoxWithTransform(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	static LessLess_VectorRotator(A: Vector,B: Rotator): Vector;
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinePlaneIntersection_OriginNormal(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static MakeBox(Min: Vector,Max: Vector): Box;
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	static MakeRotFromX(X: Vector): Rotator;
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	static MakeRotFromY(Y: Vector): Rotator;
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	static MakeRotFromZ(Z: Vector): Rotator;
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	static Multiply_VectorFloat(A: Vector,B: number): Vector;
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	static NegateVector(A: Vector): Vector;
	static Normal(A: Vector): Vector;
	static NotEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	static RandomPointInBoundingBox(Origin: Vector,BoxExtent: Vector): Vector;
	static RandomUnitVectorInConeInDegrees(ConeDir: Vector,ConeHalfAngleInDegrees: number): Vector;
	static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector,ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInRadians(ConeDir: Vector,ConeHalfAngleInRadians: number): Vector;
	static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector,ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	static RotateAngleAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	static Subtract_VectorFloat(A: Vector,B: number): Vector;
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	static VEase(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	static VectorSpringInterp(Current: Vector,Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number): {SpringState: VectorSpringState, $: Vector};
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VLerp(A: Vector,B: Vector,Alpha: number): Vector;
	static VSize(A: Vector): number;
	static VSizeSquared(A: Vector): number;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static Conv_FloatToVector(InFloat: number): Vector;
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	static MakeVector(X: number,Y: number,Z: number): Vector;
	static RandomUnitVector(): Vector;
	static NextSobolCell3D(Index: number,NumCells: number,PreviousValue: Vector): Vector;
	static RandomSobolCell3D(Index: number,NumCells: number,Cell: Vector,Seed: Vector): Vector;
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
}

declare type EVectorQuantization = 'RoundWholeNumber' | 'RoundOneDecimal' | 'RoundTwoDecimals';
declare var EVectorQuantization : { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals', };
declare type ERotatorQuantization = 'ByteComponents' | 'ShortComponents';
declare var ERotatorQuantization : { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents', };
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	LocationQuantizationLevel: LocationQuantizationLevel;
	VelocityQuantizationLevel: VelocityQuantizationLevel;
	RotationQuantizationLevel: RotationQuantizationLevel;
	clone() : RepMovement;
	static C(Other: UObject | any): RepMovement;
}

declare class Vector_NetQuantize100 extends Vector { 
	clone() : Vector_NetQuantize100;
	static C(Other: UObject | any): Vector_NetQuantize100;
}

declare class ActorComponentTickFunction extends TickFunction { 
	clone() : ActorComponentTickFunction;
	static C(Other: UObject | any): ActorComponentTickFunction;
}

declare class AssetUserData extends UObject { 
	static Load(ResourceName: string): AssetUserData;
	static Find(Outer: UObject, ResourceName: string): AssetUserData;
	static GetDefaultObject(): AssetUserData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetUserData;
	static C(Other: UObject | any): AssetUserData;
}

declare type EComponentCreationMethod = 'Native' | 'SimpleConstructionScript' | 'UserConstructionScript' | 'Instance';
declare var EComponentCreationMethod : { Native:'Native',SimpleConstructionScript:'SimpleConstructionScript',UserConstructionScript:'UserConstructionScript',Instance:'Instance', };
declare class Guid { 
	A: number;
	B: number;
	C: number;
	D: number;
	clone() : Guid;
	static C(Other: UObject | any): Guid;
	Conv_GuidToString(): string;
	EqualEqual_GuidGuid(B: Guid): boolean;
	Invalidate_Guid(): {InGuid: Guid};
	IsValid_Guid(): boolean;
	NotEqual_GuidGuid(B: Guid): boolean;
	static Conv_GuidToString(InGuid: Guid): string;
	static EqualEqual_GuidGuid(A: Guid,B: Guid): boolean;
	static Invalidate_Guid(InGuid?: Guid): {InGuid: Guid};
	static IsValid_Guid(InGuid: Guid): boolean;
	static NotEqual_GuidGuid(A: Guid,B: Guid): boolean;
	static NewGuid(): Guid;
}

declare class SimpleMemberReference { 
	MemberParent: UObject;
	MemberName: string;
	MemberGuid: Guid;
	clone() : SimpleMemberReference;
	static C(Other: UObject | any): SimpleMemberReference;
}

declare type EEndPlayReason = 'Destroyed' | 'LevelTransition' | 'EndPlayInEditor' | 'RemovedFromWorld' | 'Quit';
declare var EEndPlayReason : { Destroyed:'Destroyed',LevelTransition:'LevelTransition',EndPlayInEditor:'EndPlayInEditor',RemovedFromWorld:'RemovedFromWorld',Quit:'Quit', };
declare class ActorComponent extends UObject { 
	PrimaryComponentTick: ActorComponentTickFunction;
	ComponentTags: string[];
	AssetUserData: AssetUserData[];
	bReplicates: boolean;
	bNetAddressable: boolean;
	bCreatedByConstructionScript: boolean;
	bInstanceComponent: boolean;
	bAutoActivate: boolean;
	bIsActive: boolean;
	bEditableWhenInherited: boolean;
	bCanEverAffectNavigation: boolean;
	bIsEditorOnly: boolean;
	CreationMethod: CreationMethod;
	UCSModifiedProperties: SimpleMemberReference[];
	OnComponentActivated: UnrealEngineMulticastDelegate<(Component: ActorComponent, bReset: boolean) => void>;
	OnComponentDeactivated: UnrealEngineMulticastDelegate<(Component: ActorComponent) => void>;
	static Load(ResourceName: string): ActorComponent;
	static Find(Outer: UObject, ResourceName: string): ActorComponent;
	static GetDefaultObject(): ActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	ToggleActive(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetIsReplicated(ShouldReplicate: boolean): void;
	SetComponentTickInterval(TickInterval: number): void;
	SetComponentTickEnabled(bEnabled: boolean): void;
	SetAutoActivate(bNewAutoActivate: boolean): void;
	SetActive(bNewActive: boolean,bReset: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveBeginPlay(): void;
	OnRep_IsActive(): void;
	K2_DestroyComponent(UObject: UObject): void;
	IsComponentTickEnabled(): boolean;
	IsBeingDestroyed(): boolean;
	IsActive(): boolean;
	GetOwner(): Actor;
	GetComponentTickInterval(): number;
	Deactivate(): void;
	ComponentHasTag(Tag: string): boolean;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Activate(bReset: boolean): void;
	static C(Other: UObject | any): ActorComponent;
	IsRegistered(): boolean;
	MarkRenderStateDirty(): void;
	RegisterComponent(): void;
	ReregisterComponent(): void;
	UnregisterComponent(): void;
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	static MarkRenderStateDirty(Component: ActorComponent): void;
	static RegisterComponent(ActorComponent: ActorComponent): void;
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	static UnregisterComponent(ActorComponent: ActorComponent): void;
}

declare type EComponentMobility = 'Static' | 'Stationary' | 'Movable';
declare var EComponentMobility : { Static:'Static',Stationary:'Stationary',Movable:'Movable', };
declare type EDetailMode = 'DM_Low' | 'DM_Medium' | 'DM_High';
declare var EDetailMode : { DM_Low:'DM_Low',DM_Medium:'DM_Medium',DM_High:'DM_High', };
declare type EBrushType = 'Brush_Default' | 'Brush_Add' | 'Brush_Subtract';
declare var EBrushType : { Brush_Default:'Brush_Default',Brush_Add:'Brush_Add',Brush_Subtract:'Brush_Subtract', };
declare class Model extends UObject { 
	static Load(ResourceName: string): Model;
	static Find(Outer: UObject, ResourceName: string): Model;
	static GetDefaultObject(): Model;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Model;
	static C(Other: UObject | any): Model;
}

declare type ESceneDepthPriorityGroup = 'SDPG_World' | 'SDPG_Foreground';
declare var ESceneDepthPriorityGroup : { SDPG_World:'SDPG_World',SDPG_Foreground:'SDPG_Foreground', };
declare type EIndirectLightingCacheQuality = 'ILCQ_Off' | 'ILCQ_Point' | 'ILCQ_Volume';
declare var EIndirectLightingCacheQuality : { ILCQ_Off:'ILCQ_Off',ILCQ_Point:'ILCQ_Point',ILCQ_Volume:'ILCQ_Volume', };
declare type EHasCustomNavigableGeometry = 'No' | 'Yes' | 'EvenIfNotCollidable' | 'DontExport';
declare var EHasCustomNavigableGeometry : { No:'No',Yes:'Yes',EvenIfNotCollidable:'EvenIfNotCollidable',DontExport:'DontExport', };
declare type ECanBeCharacterBase = 'ECB_No' | 'ECB_Yes' | 'ECB_Owner';
declare var ECanBeCharacterBase : { ECB_No:'ECB_No',ECB_Yes:'ECB_Yes',ECB_Owner:'ECB_Owner', };
declare class LightingChannels { 
	bChannel0: boolean;
	bChannel1: boolean;
	bChannel2: boolean;
	clone() : LightingChannels;
	static C(Other: UObject | any): LightingChannels;
}

declare type ERendererStencilMask = 'ERSM_Default' | 'ERSM_255' | 'ERSM_1' | 'ERSM_2' | 'ERSM_4' | 'ERSM_8' | 'ERSM_16' | 'ERSM_32' | 'ERSM_64' | 'ERSM_128';
declare var ERendererStencilMask : { ERSM_Default:'ERSM_Default',ERSM_255:'ERSM_255',ERSM_1:'ERSM_1',ERSM_2:'ERSM_2',ERSM_4:'ERSM_4',ERSM_8:'ERSM_8',ERSM_16:'ERSM_16',ERSM_32:'ERSM_32',ERSM_64:'ERSM_64',ERSM_128:'ERSM_128', };
declare type ECollisionResponse = 'ECR_Ignore' | 'ECR_Overlap' | 'ECR_Block';
declare var ECollisionResponse : { ECR_Ignore:'ECR_Ignore',ECR_Overlap:'ECR_Overlap',ECR_Block:'ECR_Block', };
declare class CollisionResponseContainer { 
	WorldStatic: ECollisionResponse;
	WorldDynamic: ECollisionResponse;
	Pawn: ECollisionResponse;
	Visibility: ECollisionResponse;
	Camera: ECollisionResponse;
	PhysicsBody: ECollisionResponse;
	Vehicle: ECollisionResponse;
	Destructible: ECollisionResponse;
	EngineTraceChannel1: ECollisionResponse;
	EngineTraceChannel2: ECollisionResponse;
	EngineTraceChannel3: ECollisionResponse;
	EngineTraceChannel4: ECollisionResponse;
	EngineTraceChannel5: ECollisionResponse;
	EngineTraceChannel6: ECollisionResponse;
	GameTraceChannel1: ECollisionResponse;
	GameTraceChannel2: ECollisionResponse;
	GameTraceChannel3: ECollisionResponse;
	GameTraceChannel4: ECollisionResponse;
	GameTraceChannel5: ECollisionResponse;
	GameTraceChannel6: ECollisionResponse;
	GameTraceChannel7: ECollisionResponse;
	GameTraceChannel8: ECollisionResponse;
	GameTraceChannel9: ECollisionResponse;
	GameTraceChannel10: ECollisionResponse;
	GameTraceChannel11: ECollisionResponse;
	GameTraceChannel12: ECollisionResponse;
	GameTraceChannel13: ECollisionResponse;
	GameTraceChannel14: ECollisionResponse;
	GameTraceChannel15: ECollisionResponse;
	GameTraceChannel16: ECollisionResponse;
	GameTraceChannel17: ECollisionResponse;
	GameTraceChannel18: ECollisionResponse;
	clone() : CollisionResponseContainer;
	static C(Other: UObject | any): CollisionResponseContainer;
}

declare type ESleepFamily = 'Normal' | 'Sensitive' | 'Custom';
declare var ESleepFamily : { Normal:'Normal',Sensitive:'Sensitive',Custom:'Custom', };
declare type EDOFMode = 'Default' | 'SixDOF' | 'YZPlane' | 'XZPlane' | 'XYPlane' | 'CustomPlane' | 'None';
declare var EDOFMode : { Default:'Default',SixDOF:'SixDOF',YZPlane:'YZPlane',XZPlane:'XZPlane',XYPlane:'XYPlane',CustomPlane:'CustomPlane',None:'None', };
declare type ECollisionEnabled = 'NoCollision' | 'QueryOnly' | 'PhysicsOnly' | 'QueryAndPhysics';
declare var ECollisionEnabled : { NoCollision:'NoCollision',QueryOnly:'QueryOnly',PhysicsOnly:'PhysicsOnly',QueryAndPhysics:'QueryAndPhysics', };
declare class ResponseChannel { 
	Channel: string;
	Response: ECollisionResponse;
	clone() : ResponseChannel;
	static C(Other: UObject | any): ResponseChannel;
}

declare class CollisionResponse { 
	ResponseToChannels: CollisionResponseContainer;
	ResponseArray: ResponseChannel[];
	clone() : CollisionResponse;
	static C(Other: UObject | any): CollisionResponse;
}

declare type ECollisionChannel = 'ECC_WorldStatic' | 'ECC_WorldDynamic' | 'ECC_Pawn' | 'ECC_Visibility' | 'ECC_Camera' | 'ECC_PhysicsBody' | 'ECC_Vehicle' | 'ECC_Destructible' | 'ECC_EngineTraceChannel1' | 'ECC_EngineTraceChannel2' | 'ECC_EngineTraceChannel3' | 'ECC_EngineTraceChannel4' | 'ECC_EngineTraceChannel5' | 'ECC_EngineTraceChannel6' | 'ECC_GameTraceChannel1' | 'ECC_GameTraceChannel2' | 'ECC_GameTraceChannel3' | 'ECC_GameTraceChannel4' | 'ECC_GameTraceChannel5' | 'ECC_GameTraceChannel6' | 'ECC_GameTraceChannel7' | 'ECC_GameTraceChannel8' | 'ECC_GameTraceChannel9' | 'ECC_GameTraceChannel10' | 'ECC_GameTraceChannel11' | 'ECC_GameTraceChannel12' | 'ECC_GameTraceChannel13' | 'ECC_GameTraceChannel14' | 'ECC_GameTraceChannel15' | 'ECC_GameTraceChannel16' | 'ECC_GameTraceChannel17' | 'ECC_GameTraceChannel18' | 'ECC_OverlapAll_Deprecated';
declare var ECollisionChannel : { ECC_WorldStatic:'ECC_WorldStatic',ECC_WorldDynamic:'ECC_WorldDynamic',ECC_Pawn:'ECC_Pawn',ECC_Visibility:'ECC_Visibility',ECC_Camera:'ECC_Camera',ECC_PhysicsBody:'ECC_PhysicsBody',ECC_Vehicle:'ECC_Vehicle',ECC_Destructible:'ECC_Destructible',ECC_EngineTraceChannel1:'ECC_EngineTraceChannel1',ECC_EngineTraceChannel2:'ECC_EngineTraceChannel2',ECC_EngineTraceChannel3:'ECC_EngineTraceChannel3',ECC_EngineTraceChannel4:'ECC_EngineTraceChannel4',ECC_EngineTraceChannel5:'ECC_EngineTraceChannel5',ECC_EngineTraceChannel6:'ECC_EngineTraceChannel6',ECC_GameTraceChannel1:'ECC_GameTraceChannel1',ECC_GameTraceChannel2:'ECC_GameTraceChannel2',ECC_GameTraceChannel3:'ECC_GameTraceChannel3',ECC_GameTraceChannel4:'ECC_GameTraceChannel4',ECC_GameTraceChannel5:'ECC_GameTraceChannel5',ECC_GameTraceChannel6:'ECC_GameTraceChannel6',ECC_GameTraceChannel7:'ECC_GameTraceChannel7',ECC_GameTraceChannel8:'ECC_GameTraceChannel8',ECC_GameTraceChannel9:'ECC_GameTraceChannel9',ECC_GameTraceChannel10:'ECC_GameTraceChannel10',ECC_GameTraceChannel11:'ECC_GameTraceChannel11',ECC_GameTraceChannel12:'ECC_GameTraceChannel12',ECC_GameTraceChannel13:'ECC_GameTraceChannel13',ECC_GameTraceChannel14:'ECC_GameTraceChannel14',ECC_GameTraceChannel15:'ECC_GameTraceChannel15',ECC_GameTraceChannel16:'ECC_GameTraceChannel16',ECC_GameTraceChannel17:'ECC_GameTraceChannel17',ECC_GameTraceChannel18:'ECC_GameTraceChannel18',ECC_OverlapAll_Deprecated:'ECC_OverlapAll_Deprecated', };
declare type EWalkableSlopeBehavior = 'WalkableSlope_Default' | 'WalkableSlope_Increase' | 'WalkableSlope_Decrease' | 'WalkableSlope_Unwalkable' | 'WalkableSlope_Max';
declare var EWalkableSlopeBehavior : { WalkableSlope_Default:'WalkableSlope_Default',WalkableSlope_Increase:'WalkableSlope_Increase',WalkableSlope_Decrease:'WalkableSlope_Decrease',WalkableSlope_Unwalkable:'WalkableSlope_Unwalkable',WalkableSlope_Max:'WalkableSlope_Max', };
declare class WalkableSlopeOverride { 
	WalkableSlopeBehavior: EWalkableSlopeBehavior;
	WalkableSlopeAngle: number;
	clone() : WalkableSlopeOverride;
	static C(Other: UObject | any): WalkableSlopeOverride;
}

declare type EFrictionCombineMode = 'Average' | 'Min' | 'Multiply' | 'Max';
declare var EFrictionCombineMode : { Average:'Average',Min:'Min',Multiply:'Multiply',Max:'Max', };
declare class PhysicalMaterialPropertyBase extends UObject { 
	static Load(ResourceName: string): PhysicalMaterialPropertyBase;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterialPropertyBase;
	static GetDefaultObject(): PhysicalMaterialPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterialPropertyBase;
	static C(Other: UObject | any): PhysicalMaterialPropertyBase;
}

declare type EPhysicalSurface = 'SurfaceType_Default' | 'SurfaceType1' | 'SurfaceType2' | 'SurfaceType3' | 'SurfaceType4' | 'SurfaceType5' | 'SurfaceType6' | 'SurfaceType7' | 'SurfaceType8' | 'SurfaceType9' | 'SurfaceType10' | 'SurfaceType11' | 'SurfaceType12' | 'SurfaceType13' | 'SurfaceType14' | 'SurfaceType15' | 'SurfaceType16' | 'SurfaceType17' | 'SurfaceType18' | 'SurfaceType19' | 'SurfaceType20' | 'SurfaceType21' | 'SurfaceType22' | 'SurfaceType23' | 'SurfaceType24' | 'SurfaceType25' | 'SurfaceType26' | 'SurfaceType27' | 'SurfaceType28' | 'SurfaceType29' | 'SurfaceType30' | 'SurfaceType31' | 'SurfaceType32' | 'SurfaceType33' | 'SurfaceType34' | 'SurfaceType35' | 'SurfaceType36' | 'SurfaceType37' | 'SurfaceType38' | 'SurfaceType39' | 'SurfaceType40' | 'SurfaceType41' | 'SurfaceType42' | 'SurfaceType43' | 'SurfaceType44' | 'SurfaceType45' | 'SurfaceType46' | 'SurfaceType47' | 'SurfaceType48' | 'SurfaceType49' | 'SurfaceType50' | 'SurfaceType51' | 'SurfaceType52' | 'SurfaceType53' | 'SurfaceType54' | 'SurfaceType55' | 'SurfaceType56' | 'SurfaceType57' | 'SurfaceType58' | 'SurfaceType59' | 'SurfaceType60' | 'SurfaceType61' | 'SurfaceType62' | 'SurfaceType_Max';
declare var EPhysicalSurface : { SurfaceType_Default:'SurfaceType_Default',SurfaceType1:'SurfaceType1',SurfaceType2:'SurfaceType2',SurfaceType3:'SurfaceType3',SurfaceType4:'SurfaceType4',SurfaceType5:'SurfaceType5',SurfaceType6:'SurfaceType6',SurfaceType7:'SurfaceType7',SurfaceType8:'SurfaceType8',SurfaceType9:'SurfaceType9',SurfaceType10:'SurfaceType10',SurfaceType11:'SurfaceType11',SurfaceType12:'SurfaceType12',SurfaceType13:'SurfaceType13',SurfaceType14:'SurfaceType14',SurfaceType15:'SurfaceType15',SurfaceType16:'SurfaceType16',SurfaceType17:'SurfaceType17',SurfaceType18:'SurfaceType18',SurfaceType19:'SurfaceType19',SurfaceType20:'SurfaceType20',SurfaceType21:'SurfaceType21',SurfaceType22:'SurfaceType22',SurfaceType23:'SurfaceType23',SurfaceType24:'SurfaceType24',SurfaceType25:'SurfaceType25',SurfaceType26:'SurfaceType26',SurfaceType27:'SurfaceType27',SurfaceType28:'SurfaceType28',SurfaceType29:'SurfaceType29',SurfaceType30:'SurfaceType30',SurfaceType31:'SurfaceType31',SurfaceType32:'SurfaceType32',SurfaceType33:'SurfaceType33',SurfaceType34:'SurfaceType34',SurfaceType35:'SurfaceType35',SurfaceType36:'SurfaceType36',SurfaceType37:'SurfaceType37',SurfaceType38:'SurfaceType38',SurfaceType39:'SurfaceType39',SurfaceType40:'SurfaceType40',SurfaceType41:'SurfaceType41',SurfaceType42:'SurfaceType42',SurfaceType43:'SurfaceType43',SurfaceType44:'SurfaceType44',SurfaceType45:'SurfaceType45',SurfaceType46:'SurfaceType46',SurfaceType47:'SurfaceType47',SurfaceType48:'SurfaceType48',SurfaceType49:'SurfaceType49',SurfaceType50:'SurfaceType50',SurfaceType51:'SurfaceType51',SurfaceType52:'SurfaceType52',SurfaceType53:'SurfaceType53',SurfaceType54:'SurfaceType54',SurfaceType55:'SurfaceType55',SurfaceType56:'SurfaceType56',SurfaceType57:'SurfaceType57',SurfaceType58:'SurfaceType58',SurfaceType59:'SurfaceType59',SurfaceType60:'SurfaceType60',SurfaceType61:'SurfaceType61',SurfaceType62:'SurfaceType62',SurfaceType_Max:'SurfaceType_Max', };
declare class DataAsset extends UObject { 
	NativeClass: UnrealEngineClass;
	static Load(ResourceName: string): DataAsset;
	static Find(Outer: UObject, ResourceName: string): DataAsset;
	static GetDefaultObject(): DataAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataAsset;
	static C(Other: UObject | any): DataAsset;
}

declare class TireType extends DataAsset { 
	FrictionScale: number;
	static Load(ResourceName: string): TireType;
	static Find(Outer: UObject, ResourceName: string): TireType;
	static GetDefaultObject(): TireType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TireType;
	static C(Other: UObject | any): TireType;
}

declare class TireFrictionScalePair { 
	TireType: TireType;
	FrictionScale: number;
	clone() : TireFrictionScalePair;
	static C(Other: UObject | any): TireFrictionScalePair;
}

declare class PhysicalMaterial extends UObject { 
	Friction: number;
	FrictionCombineMode: EFrictionCombineMode;
	bOverrideFrictionCombineMode: boolean;
	Restitution: number;
	RestitutionCombineMode: EFrictionCombineMode;
	bOverrideRestitutionCombineMode: boolean;
	Density: number;
	RaiseMassToPower: number;
	DestructibleDamageThresholdScale: number;
	PhysicalMaterialProperty: PhysicalMaterialPropertyBase;
	SurfaceType: EPhysicalSurface;
	TireFrictionScale: number;
	TireFrictionScales: TireFrictionScalePair[];
	static Load(ResourceName: string): PhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterial;
	static GetDefaultObject(): PhysicalMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterial;
	static C(Other: UObject | any): PhysicalMaterial;
}

declare class BodyInstance { 
	ResponseToChannels: CollisionResponseContainer;
	SleepFamily: SleepFamily;
	DOFMode: EDOFMode;
	CollisionEnabled: ECollisionEnabled;
	CollisionProfileName: string;
	CollisionResponses: CollisionResponse;
	bUseCCD: boolean;
	bNotifyRigidBodyCollision: boolean;
	bSimulatePhysics: boolean;
	bOverrideMass: boolean;
	bEnableGravity: boolean;
	bAutoWeld: boolean;
	bStartAwake: boolean;
	bGenerateWakeEvents: boolean;
	bUpdateMassWhenScaleChanges: boolean;
	bLockTranslation: boolean;
	bLockRotation: boolean;
	bLockXTranslation: boolean;
	bLockYTranslation: boolean;
	bLockZTranslation: boolean;
	bLockXRotation: boolean;
	bLockYRotation: boolean;
	bLockZRotation: boolean;
	bOverrideMaxAngularVelocity: boolean;
	bUseAsyncScene: boolean;
	bOverrideMaxDepenetrationVelocity: boolean;
	bOverrideWalkableSlopeOnInstance: boolean;
	MaxDepenetrationVelocity: number;
	MassInKgOverride: number;
	LinearDamping: number;
	AngularDamping: number;
	CustomDOFPlaneNormal: Vector;
	COMNudge: Vector;
	MassScale: number;
	InertiaTensorScale: Vector;
	ObjectType: ECollisionChannel;
	WalkableSlopeOverride: WalkableSlopeOverride;
	PhysMaterialOverride: PhysicalMaterial;
	MaxAngularVelocity: number;
	CustomSleepThresholdMultiplier: number;
	StabilizationThresholdMultiplier: number;
	PhysicsBlendWeight: number;
	PositionSolverIterationCount: number;
	RigidActorSyncId: any;
	RigidActorAsyncId: any;
	VelocitySolverIterationCount: number;
	clone() : BodyInstance;
	static C(Other: UObject | any): BodyInstance;
}

declare class Vector_NetQuantize extends Vector { 
	clone() : Vector_NetQuantize;
	static C(Other: UObject | any): Vector_NetQuantize;
}

declare class Vector_NetQuantizeNormal extends Vector { 
	clone() : Vector_NetQuantizeNormal;
	static C(Other: UObject | any): Vector_NetQuantizeNormal;
}

declare class HitResult { 
	bBlockingHit: boolean;
	bStartPenetrating: boolean;
	Time: number;
	Distance: number;
	Location: Vector_NetQuantize;
	ImpactPoint: Vector_NetQuantize;
	Normal: Vector_NetQuantizeNormal;
	ImpactNormal: Vector_NetQuantizeNormal;
	TraceStart: Vector_NetQuantize;
	TraceEnd: Vector_NetQuantize;
	PenetrationDepth: number;
	Item: number;
	PhysMaterial: any;
	Actor: any;
	Component: any;
	BoneName: string;
	FaceIndex: number;
	clone() : HitResult;
	static C(Other: UObject | any): HitResult;
	BreakHitResult(bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Distance?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,HitItem?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	FindCollisionUV(UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	GetSurfaceType(): EPhysicalSurface;
	static BreakHitResult(Hit: HitResult,bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Distance?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,HitItem?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	static FindCollisionUV(Hit: HitResult,UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	static GetSurfaceType(Hit: HitResult): EPhysicalSurface;
	static MakeHitResult(bBlockingHit: boolean,bInitialOverlap: boolean,Time: number,Distance: number,Location: Vector,ImpactPoint: Vector,Normal: Vector,ImpactNormal: Vector,PhysMat: PhysicalMaterial,HitActor: Actor,HitComponent: PrimitiveComponent,HitBoneName: string,HitItem: number,FaceIndex: number,TraceStart: Vector,TraceEnd: Vector): HitResult;
}

declare class Key { 
	KeyName: string;
	clone() : Key;
	static C(Other: UObject | any): Key;
	EqualEqual_KeyKey(B: Key): boolean;
	Key_GetDisplayName(): string;
	Key_IsFloatAxis(): boolean;
	Key_IsGamepadKey(): boolean;
	Key_IsKeyboardKey(): boolean;
	Key_IsModifierKey(): boolean;
	Key_IsMouseButton(): boolean;
	Key_IsVectorAxis(): boolean;
	static EqualEqual_KeyKey(A: Key,B: Key): boolean;
	static Key_GetDisplayName(Key: Key): string;
	static Key_IsFloatAxis(Key: Key): boolean;
	static Key_IsGamepadKey(Key: Key): boolean;
	static Key_IsKeyboardKey(Key: Key): boolean;
	static Key_IsModifierKey(Key: Key): boolean;
	static Key_IsMouseButton(Key: Key): boolean;
	static Key_IsVectorAxis(Key: Key): boolean;
}

declare type ETouchIndex = 'Touch1' | 'Touch2' | 'Touch3' | 'Touch4' | 'Touch5' | 'Touch6' | 'Touch7' | 'Touch8' | 'Touch9' | 'Touch10' | 'CursorPointerIndex' | 'MAX_TOUCHES';
declare var ETouchIndex : { Touch1:'Touch1',Touch2:'Touch2',Touch3:'Touch3',Touch4:'Touch4',Touch5:'Touch5',Touch6:'Touch6',Touch7:'Touch7',Touch8:'Touch8',Touch9:'Touch9',Touch10:'Touch10',CursorPointerIndex:'CursorPointerIndex',MAX_TOUCHES:'MAX_TOUCHES', };
declare class PrimitiveComponentPostPhysicsTickFunction extends TickFunction { 
	clone() : PrimitiveComponentPostPhysicsTickFunction;
	static C(Other: UObject | any): PrimitiveComponentPostPhysicsTickFunction;
}

declare class SubsurfaceProfileStruct { 
	ScatterRadius: number;
	SubsurfaceColor: LinearColor;
	FalloffColor: LinearColor;
	clone() : SubsurfaceProfileStruct;
	static C(Other: UObject | any): SubsurfaceProfileStruct;
}

declare class SubsurfaceProfile extends UObject { 
	Settings: SubsurfaceProfileStruct;
	static Load(ResourceName: string): SubsurfaceProfile;
	static Find(Outer: UObject, ResourceName: string): SubsurfaceProfile;
	static GetDefaultObject(): SubsurfaceProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsurfaceProfile;
	static C(Other: UObject | any): SubsurfaceProfile;
}

declare class LightmassMaterialInterfaceSettings { 
	bCastShadowAsMasked: boolean;
	EmissiveBoost: number;
	DiffuseBoost: number;
	ExportResolutionScale: number;
	bOverrideCastShadowAsMasked: boolean;
	bOverrideEmissiveBoost: boolean;
	bOverrideDiffuseBoost: boolean;
	bOverrideExportResolutionScale: boolean;
	clone() : LightmassMaterialInterfaceSettings;
	static C(Other: UObject | any): LightmassMaterialInterfaceSettings;
}

declare class SoftObjectPath { 
	AssetPathName: string;
	SubPathString: string;
	clone() : SoftObjectPath;
	static C(Other: UObject | any): SoftObjectPath;
	BreakSoftObjectPath(PathString?: string): {PathString: string};
	static BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath,PathString?: string): {PathString: string};
	static MakeSoftObjectPath(PathString: string): SoftObjectPath;
}

declare class MaterialTextureInfo { 
	SamplingScale: number;
	UVChannelIndex: number;
	TextureName: string;
	TextureReference: SoftObjectPath;
	TextureIndex: number;
	clone() : MaterialTextureInfo;
	static C(Other: UObject | any): MaterialTextureInfo;
}

declare class ThumbnailInfo extends UObject { 
	static Load(ResourceName: string): ThumbnailInfo;
	static Find(Outer: UObject, ResourceName: string): ThumbnailInfo;
	static GetDefaultObject(): ThumbnailInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailInfo;
	static C(Other: UObject | any): ThumbnailInfo;
}

declare type EEdGraphPinDirection = 'EGPD_Input' | 'EGPD_Output';
declare var EEdGraphPinDirection : { EGPD_Input:'EGPD_Input',EGPD_Output:'EGPD_Output', };
declare class EdGraphTerminalType { 
	TerminalCategory: string;
	TerminalSubCategory: string;
	TerminalSubCategoryObject: any;
	bTerminalIsConst: boolean;
	bTerminalIsWeakPointer: boolean;
	clone() : EdGraphTerminalType;
	static C(Other: UObject | any): EdGraphTerminalType;
}

declare type EPinContainerType = 'None' | 'Array' | 'Set' | 'Map';
declare var EPinContainerType : { None:'None',Array:'Array',Set:'Set',Map:'Map', };
declare class EdGraphPinType { 
	PinCategory: string;
	PinSubCategory: string;
	PinSubCategoryObject: any;
	PinSubCategoryMemberReference: SimpleMemberReference;
	PinValueType: EdGraphTerminalType;
	ContainerType: ContainerType;
	bIsArray: boolean;
	bIsReference: boolean;
	bIsConst: boolean;
	bIsWeakPointer: boolean;
	clone() : EdGraphPinType;
	static C(Other: UObject | any): EdGraphPinType;
}

declare class EdGraphPin_Deprecated extends UObject { 
	PinName: string;
	PinFriendlyName: string;
	PinToolTip: string;
	Direction: EEdGraphPinDirection;
	PinType: EdGraphPinType;
	DefaultValue: string;
	AutogeneratedDefaultValue: string;
	DefaultObject: UObject;
	DefaultTextValue: string;
	LinkedTo: EdGraphPin_Deprecated[];
	SubPins: EdGraphPin_Deprecated[];
	ParentPin: EdGraphPin_Deprecated;
	ReferencePassThroughConnection: EdGraphPin_Deprecated;
	bHidden: boolean;
	bNotConnectable: boolean;
	bDefaultValueIsReadOnly: boolean;
	bDefaultValueIsIgnored: boolean;
	bIsDiffing: boolean;
	bAdvancedView: boolean;
	bDisplayAsMutableRef: boolean;
	PersistentGuid: Guid;
	static Load(ResourceName: string): EdGraphPin_Deprecated;
	static Find(Outer: UObject, ResourceName: string): EdGraphPin_Deprecated;
	static GetDefaultObject(): EdGraphPin_Deprecated;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphPin_Deprecated;
	static C(Other: UObject | any): EdGraphPin_Deprecated;
}

declare type ENodeAdvancedPins = 'NoPins' | 'Shown' | 'Hidden';
declare var ENodeAdvancedPins : { NoPins:'NoPins',Shown:'Shown',Hidden:'Hidden', };
declare type ENodeEnabledState = 'Enabled' | 'Disabled' | 'DevelopmentOnly';
declare var ENodeEnabledState : { Enabled:'Enabled',Disabled:'Disabled',DevelopmentOnly:'DevelopmentOnly', };
declare class JavascriptEdGraphPin { 
	clone() : JavascriptEdGraphPin;
	static C(Other: UObject | any): JavascriptEdGraphPin;
	BreakAllPinLinks(): void;
	BreakLinkTo(B: JavascriptEdGraphPin): void;
	GetDirection(): EEdGraphPinDirection;
	GetLinkedTo(): JavascriptEdGraphPin[];
	GetOwningNode(): EdGraphNode;
	GetPinName(): string;
	GetPinType(): EdGraphPinType;
	IsValid(): boolean;
	MakeLinkTo(B: JavascriptEdGraphPin): void;
	SetPinType(PinType: EdGraphPinType): void;
	static BreakAllPinLinks(A: JavascriptEdGraphPin): void;
	static BreakLinkTo(A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): void;
	static GetDirection(A: JavascriptEdGraphPin): EEdGraphPinDirection;
	static GetLinkedTo(A: JavascriptEdGraphPin): JavascriptEdGraphPin[];
	static GetOwningNode(A: JavascriptEdGraphPin): EdGraphNode;
	static GetPinName(A: JavascriptEdGraphPin): string;
	static GetPinType(A: JavascriptEdGraphPin): EdGraphPinType;
	static IsValid(A: JavascriptEdGraphPin): boolean;
	static MakeLinkTo(A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): void;
	static SetPinType(Pin: JavascriptEdGraphPin,PinType: EdGraphPinType): void;
	static GetDefaultObject(): JavascriptEdGraphPin;
}

declare class EdGraphNode extends UObject { 
	DeprecatedPins: EdGraphPin_Deprecated[];
	NodePosX: number;
	NodePosY: number;
	NodeWidth: number;
	NodeHeight: number;
	AdvancedPinDisplay: ENodeAdvancedPins;
	EnabledState: EnabledState;
	bUserSetEnabledState: boolean;
	bIsNodeEnabled: boolean;
	bCanResizeNode: boolean;
	bHasCompilerMessage: boolean;
	bCommentBubblePinned: boolean;
	bCommentBubbleVisible: boolean;
	bCommentBubbleMakeVisible: boolean;
	bCanRenameNode: boolean;
	NodeUpgradeMessage: string;
	NodeComment: string;
	ErrorType: number;
	ErrorMsg: string;
	NodeGuid: Guid;
	static Load(ResourceName: string): EdGraphNode;
	static Find(Outer: UObject, ResourceName: string): EdGraphNode;
	static GetDefaultObject(): EdGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode;
	static C(Other: UObject | any): EdGraphNode;
	AutowireNewNode(FromPin: JavascriptEdGraphPin): void;
	CanDuplicateNode(): boolean;
	CanUserDeleteNode(): boolean;
	DestroyNode(): void;
	FindPin(PinName: string,Direction: EEdGraphPinDirection): JavascriptEdGraphPin;
	GetPins(): JavascriptEdGraphPin[];
	static AutowireNewNode(UNode: EdGraphNode,FromPin: JavascriptEdGraphPin): void;
	static CanDuplicateNode(UNode: EdGraphNode): boolean;
	static CanUserDeleteNode(UNode: EdGraphNode): boolean;
	static DestroyNode(UNode: EdGraphNode): void;
	static FindPin(UNode: EdGraphNode,PinName: string,Direction: EEdGraphPinDirection): JavascriptEdGraphPin;
	static GetPins(UNode: EdGraphNode): JavascriptEdGraphPin[];
}

declare class MaterialExpressionComment extends MaterialExpression { 
	SizeX: number;
	SizeY: number;
	Text: string;
	CommentColor: LinearColor;
	FontSize: number;
	static Load(ResourceName: string): MaterialExpressionComment;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionComment;
	static GetDefaultObject(): MaterialExpressionComment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComment;
	static C(Other: UObject | any): MaterialExpressionComment;
}

declare class MaterialFunction extends UObject { 
	StateId: Guid;
	ParentFunction: MaterialFunction;
	Description: string;
	bExposeToLibrary: boolean;
	LibraryCategories: string[];
	LibraryCategoriesText: string[];
	FunctionExpressions: MaterialExpression[];
	FunctionEditorComments: MaterialExpressionComment[];
	PreviewMaterial: Material;
	bReentrantFlag: boolean;
	CombinedInputTypes: any;
	CombinedOutputTypes: any;
	ThumbnailInfo: ThumbnailInfo;
	static Load(ResourceName: string): MaterialFunction;
	static Find(Outer: UObject, ResourceName: string): MaterialFunction;
	static GetDefaultObject(): MaterialFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunction;
	static C(Other: UObject | any): MaterialFunction;
	CreateMaterialExpressionInFunction(ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	DeleteAllMaterialExpressionsInFunction(): void;
	DeleteMaterialExpressionInFunction(Expression: MaterialExpression): void;
	GetNumMaterialExpressionsInFunction(): number;
	UpdateMaterialFunction(PreviewMaterial: Material): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunction,PreviewMaterial: Material): void;
}

declare class ExpressionOutput { 
	OutputName: string;
	Mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	clone() : ExpressionOutput;
	static C(Other: UObject | any): ExpressionOutput;
}

declare type EMaterialProperty = 'MP_EmissiveColor' | 'MP_Opacity' | 'MP_OpacityMask' | 'MP_DiffuseColor' | 'MP_SpecularColor' | 'MP_BaseColor' | 'MP_Metallic' | 'MP_Specular' | 'MP_Roughness' | 'MP_Normal' | 'MP_WorldPositionOffset' | 'MP_WorldDisplacement' | 'MP_TessellationMultiplier' | 'MP_SubsurfaceColor' | 'MP_CustomData0' | 'MP_CustomData1' | 'MP_AmbientOcclusion' | 'MP_Refraction' | 'MP_CustomizedUVs0' | 'MP_CustomizedUVs1' | 'MP_CustomizedUVs2' | 'MP_CustomizedUVs3' | 'MP_CustomizedUVs4' | 'MP_CustomizedUVs5' | 'MP_CustomizedUVs6' | 'MP_CustomizedUVs7' | 'MP_PixelDepthOffset' | 'MP_MaterialAttributes' | 'MP_CustomOutput';
declare var EMaterialProperty : { MP_EmissiveColor:'MP_EmissiveColor',MP_Opacity:'MP_Opacity',MP_OpacityMask:'MP_OpacityMask',MP_DiffuseColor:'MP_DiffuseColor',MP_SpecularColor:'MP_SpecularColor',MP_BaseColor:'MP_BaseColor',MP_Metallic:'MP_Metallic',MP_Specular:'MP_Specular',MP_Roughness:'MP_Roughness',MP_Normal:'MP_Normal',MP_WorldPositionOffset:'MP_WorldPositionOffset',MP_WorldDisplacement:'MP_WorldDisplacement',MP_TessellationMultiplier:'MP_TessellationMultiplier',MP_SubsurfaceColor:'MP_SubsurfaceColor',MP_CustomData0:'MP_CustomData0',MP_CustomData1:'MP_CustomData1',MP_AmbientOcclusion:'MP_AmbientOcclusion',MP_Refraction:'MP_Refraction',MP_CustomizedUVs0:'MP_CustomizedUVs0',MP_CustomizedUVs1:'MP_CustomizedUVs1',MP_CustomizedUVs2:'MP_CustomizedUVs2',MP_CustomizedUVs3:'MP_CustomizedUVs3',MP_CustomizedUVs4:'MP_CustomizedUVs4',MP_CustomizedUVs5:'MP_CustomizedUVs5',MP_CustomizedUVs6:'MP_CustomizedUVs6',MP_CustomizedUVs7:'MP_CustomizedUVs7',MP_PixelDepthOffset:'MP_PixelDepthOffset',MP_MaterialAttributes:'MP_MaterialAttributes',MP_CustomOutput:'MP_CustomOutput', };
declare class MaterialExpression extends UObject { 
	MaterialExpressionEditorX: number;
	MaterialExpressionEditorY: number;
	GraphNode: EdGraphNode;
	MaterialExpressionGuid: Guid;
	Material: Material;
	UFunction: MaterialFunction;
	Desc: string;
	BorderColor: Color;
	bRealtimePreview: boolean;
	bNeedToUpdatePreview: boolean;
	bIsParameterExpression: boolean;
	bCommentBubbleVisible: boolean;
	bShowOutputNameOnPin: boolean;
	bShowMaskColorsOnPin: boolean;
	bHidePreviewWindow: boolean;
	bCollapsed: boolean;
	bShaderInputData: boolean;
	bShowInputs: boolean;
	bShowOutputs: boolean;
	MenuCategories: string[];
	Outputs: ExpressionOutput[];
	static Load(ResourceName: string): MaterialExpression;
	static Find(Outer: UObject, ResourceName: string): MaterialExpression;
	static GetDefaultObject(): MaterialExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpression;
	static C(Other: UObject | any): MaterialExpression;
	ConnectMaterialExpressions(FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	ConnectMaterialProperty(FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
}

declare class MaterialInput { 
	Expression: MaterialExpression;
	OutputIndex: number;
	InputName: string;
	Mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	ExpressionName: string;
	clone() : MaterialInput;
	static C(Other: UObject | any): MaterialInput;
}

declare class ColorMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: Color;
	clone() : ColorMaterialInput;
	static C(Other: UObject | any): ColorMaterialInput;
}

declare class ScalarMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: number;
	clone() : ScalarMaterialInput;
	static C(Other: UObject | any): ScalarMaterialInput;
}

declare class VectorMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: Vector;
	clone() : VectorMaterialInput;
	static C(Other: UObject | any): VectorMaterialInput;
}

declare type EMaterialDomain = 'MD_Surface' | 'MD_DeferredDecal' | 'MD_LightFunction' | 'MD_Volume' | 'MD_PostProcess' | 'MD_UI';
declare var EMaterialDomain : { MD_Surface:'MD_Surface',MD_DeferredDecal:'MD_DeferredDecal',MD_LightFunction:'MD_LightFunction',MD_Volume:'MD_Volume',MD_PostProcess:'MD_PostProcess',MD_UI:'MD_UI', };
declare type EBlendMode = 'BLEND_Opaque' | 'BLEND_Masked' | 'BLEND_Translucent' | 'BLEND_Additive' | 'BLEND_Modulate' | 'BLEND_AlphaComposite';
declare var EBlendMode : { BLEND_Opaque:'BLEND_Opaque',BLEND_Masked:'BLEND_Masked',BLEND_Translucent:'BLEND_Translucent',BLEND_Additive:'BLEND_Additive',BLEND_Modulate:'BLEND_Modulate',BLEND_AlphaComposite:'BLEND_AlphaComposite', };
declare type EDecalBlendMode = 'DBM_Translucent' | 'DBM_Stain' | 'DBM_Normal' | 'DBM_Emissive' | 'DBM_DBuffer_ColorNormalRoughness' | 'DBM_DBuffer_Color' | 'DBM_DBuffer_ColorNormal' | 'DBM_DBuffer_ColorRoughness' | 'DBM_DBuffer_Normal' | 'DBM_DBuffer_NormalRoughness' | 'DBM_DBuffer_Roughness' | 'DBM_Volumetric_DistanceFunction';
declare var EDecalBlendMode : { DBM_Translucent:'DBM_Translucent',DBM_Stain:'DBM_Stain',DBM_Normal:'DBM_Normal',DBM_Emissive:'DBM_Emissive',DBM_DBuffer_ColorNormalRoughness:'DBM_DBuffer_ColorNormalRoughness',DBM_DBuffer_Color:'DBM_DBuffer_Color',DBM_DBuffer_ColorNormal:'DBM_DBuffer_ColorNormal',DBM_DBuffer_ColorRoughness:'DBM_DBuffer_ColorRoughness',DBM_DBuffer_Normal:'DBM_DBuffer_Normal',DBM_DBuffer_NormalRoughness:'DBM_DBuffer_NormalRoughness',DBM_DBuffer_Roughness:'DBM_DBuffer_Roughness',DBM_Volumetric_DistanceFunction:'DBM_Volumetric_DistanceFunction', };
declare type EMaterialDecalResponse = 'MDR_None' | 'MDR_ColorNormalRoughness' | 'MDR_Color' | 'MDR_ColorNormal' | 'MDR_ColorRoughness' | 'MDR_Normal' | 'MDR_NormalRoughness' | 'MDR_Roughness';
declare var EMaterialDecalResponse : { MDR_None:'MDR_None',MDR_ColorNormalRoughness:'MDR_ColorNormalRoughness',MDR_Color:'MDR_Color',MDR_ColorNormal:'MDR_ColorNormal',MDR_ColorRoughness:'MDR_ColorRoughness',MDR_Normal:'MDR_Normal',MDR_NormalRoughness:'MDR_NormalRoughness',MDR_Roughness:'MDR_Roughness', };
declare type EMaterialShadingModel = 'MSM_Unlit' | 'MSM_DefaultLit' | 'MSM_Subsurface' | 'MSM_PreintegratedSkin' | 'MSM_ClearCoat' | 'MSM_SubsurfaceProfile' | 'MSM_TwoSidedFoliage' | 'MSM_Hair' | 'MSM_Cloth' | 'MSM_Eye';
declare var EMaterialShadingModel : { MSM_Unlit:'MSM_Unlit',MSM_DefaultLit:'MSM_DefaultLit',MSM_Subsurface:'MSM_Subsurface',MSM_PreintegratedSkin:'MSM_PreintegratedSkin',MSM_ClearCoat:'MSM_ClearCoat',MSM_SubsurfaceProfile:'MSM_SubsurfaceProfile',MSM_TwoSidedFoliage:'MSM_TwoSidedFoliage',MSM_Hair:'MSM_Hair',MSM_Cloth:'MSM_Cloth',MSM_Eye:'MSM_Eye', };
declare class Vector2MaterialInput extends MaterialInput { 
	UseConstant: boolean;
	ConstantX: number;
	ConstantY: number;
	clone() : Vector2MaterialInput;
	static C(Other: UObject | any): Vector2MaterialInput;
}

declare class ExpressionInput { 
	Expression: MaterialExpression;
	OutputIndex: number;
	InputName: string;
	Mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	ExpressionName: string;
	clone() : ExpressionInput;
	static C(Other: UObject | any): ExpressionInput;
}

declare class MaterialAttributesInput extends ExpressionInput { 
	PropertyConnectedBitmask: number;
	clone() : MaterialAttributesInput;
	static C(Other: UObject | any): MaterialAttributesInput;
}

declare type ETranslucencyLightingMode = 'TLM_VolumetricNonDirectional' | 'TLM_VolumetricDirectional' | 'TLM_VolumetricPerVertexNonDirectional' | 'TLM_VolumetricPerVertexDirectional' | 'TLM_Surface' | 'TLM_SurfacePerPixelLighting';
declare var ETranslucencyLightingMode : { TLM_VolumetricNonDirectional:'TLM_VolumetricNonDirectional',TLM_VolumetricDirectional:'TLM_VolumetricDirectional',TLM_VolumetricPerVertexNonDirectional:'TLM_VolumetricPerVertexNonDirectional',TLM_VolumetricPerVertexDirectional:'TLM_VolumetricPerVertexDirectional',TLM_Surface:'TLM_Surface',TLM_SurfacePerPixelLighting:'TLM_SurfacePerPixelLighting', };
declare type EMaterialTessellationMode = 'MTM_NoTessellation' | 'MTM_FlatTessellation' | 'MTM_PNTriangles';
declare var EMaterialTessellationMode : { MTM_NoTessellation:'MTM_NoTessellation',MTM_FlatTessellation:'MTM_FlatTessellation',MTM_PNTriangles:'MTM_PNTriangles', };
declare class ParameterGroupData { 
	GroupName: string;
	GroupSortPriority: number;
	clone() : ParameterGroupData;
	static C(Other: UObject | any): ParameterGroupData;
}

declare class MaterialFunctionInfo { 
	StateId: Guid;
	UFunction: MaterialFunction;
	clone() : MaterialFunctionInfo;
	static C(Other: UObject | any): MaterialFunctionInfo;
}

declare class CollectionParameterBase { 
	ParameterName: string;
	Id: Guid;
	clone() : CollectionParameterBase;
	static C(Other: UObject | any): CollectionParameterBase;
}

declare class CollectionScalarParameter extends CollectionParameterBase { 
	DefaultValue: number;
	clone() : CollectionScalarParameter;
	static C(Other: UObject | any): CollectionScalarParameter;
}

declare class CollectionVectorParameter extends CollectionParameterBase { 
	DefaultValue: LinearColor;
	clone() : CollectionVectorParameter;
	static C(Other: UObject | any): CollectionVectorParameter;
}

declare class MaterialParameterCollection extends UObject { 
	StateId: Guid;
	ScalarParameters: CollectionScalarParameter[];
	VectorParameters: CollectionVectorParameter[];
	static Load(ResourceName: string): MaterialParameterCollection;
	static Find(Outer: UObject, ResourceName: string): MaterialParameterCollection;
	static GetDefaultObject(): MaterialParameterCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollection;
	static C(Other: UObject | any): MaterialParameterCollection;
}

declare class MaterialParameterCollectionInfo { 
	StateId: Guid;
	ParameterCollection: MaterialParameterCollection;
	clone() : MaterialParameterCollectionInfo;
	static C(Other: UObject | any): MaterialParameterCollectionInfo;
}

declare type EBlendableLocation = 'BL_AfterTonemapping' | 'BL_BeforeTonemapping' | 'BL_BeforeTranslucency' | 'BL_ReplacingTonemapper';
declare var EBlendableLocation : { BL_AfterTonemapping:'BL_AfterTonemapping',BL_BeforeTonemapping:'BL_BeforeTonemapping',BL_BeforeTranslucency:'BL_BeforeTranslucency',BL_ReplacingTonemapper:'BL_ReplacingTonemapper', };
declare type ERefractionMode = 'RM_IndexOfRefraction' | 'RM_PixelNormalOffset';
declare var ERefractionMode : { RM_IndexOfRefraction:'RM_IndexOfRefraction',RM_PixelNormalOffset:'RM_PixelNormalOffset', };
declare type ETextureSourceFormat = 'TSF_Invalid' | 'TSF_G8' | 'TSF_BGRA8' | 'TSF_BGRE8' | 'TSF_RGBA16' | 'TSF_RGBA16F' | 'TSF_RGBA8' | 'TSF_RGBE8';
declare var ETextureSourceFormat : { TSF_Invalid:'TSF_Invalid',TSF_G8:'TSF_G8',TSF_BGRA8:'TSF_BGRA8',TSF_BGRE8:'TSF_BGRE8',TSF_RGBA16:'TSF_RGBA16',TSF_RGBA16F:'TSF_RGBA16F',TSF_RGBA8:'TSF_RGBA8',TSF_RGBE8:'TSF_RGBE8', };
declare class TextureSource { 
	Id: Guid;
	SizeX: number;
	SizeY: number;
	NumSlices: number;
	NumMips: number;
	bPNGCompressed: boolean;
	bGuidIsHash: boolean;
	Format: ETextureSourceFormat;
	clone() : TextureSource;
	static C(Other: UObject | any): TextureSource;
}

declare class AssetImportInfo { 
	clone() : AssetImportInfo;
	static C(Other: UObject | any): AssetImportInfo;
}

declare class AssetImportData extends UObject { 
	SourceFilePath: string;
	SourceFileTimestamp: string;
	SourceData: AssetImportInfo;
	static Load(ResourceName: string): AssetImportData;
	static Find(Outer: UObject, ResourceName: string): AssetImportData;
	static GetDefaultObject(): AssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportData;
	static C(Other: UObject | any): AssetImportData;
}

declare type ETextureCompressionQuality = 'TCQ_Default' | 'TCQ_Lowest' | 'TCQ_Low' | 'TCQ_Medium' | 'TCQ_High' | 'TCQ_Highest';
declare var ETextureCompressionQuality : { TCQ_Default:'TCQ_Default',TCQ_Lowest:'TCQ_Lowest',TCQ_Low:'TCQ_Low',TCQ_Medium:'TCQ_Medium',TCQ_High:'TCQ_High',TCQ_Highest:'TCQ_Highest', };
declare class Vector4 { 
	X: number;
	Y: number;
	Z: number;
	W: number;
	clone() : Vector4;
	static C(Other: UObject | any): Vector4;
}

declare type ETexturePowerOfTwoSetting = 'None' | 'PadToPowerOfTwo' | 'PadToSquarePowerOfTwo';
declare var ETexturePowerOfTwoSetting : { None:'None',PadToPowerOfTwo:'PadToPowerOfTwo',PadToSquarePowerOfTwo:'PadToSquarePowerOfTwo', };
declare type TextureMipGenSettings = 'TMGS_FromTextureGroup' | 'TMGS_SimpleAverage' | 'TMGS_Sharpen0' | 'TMGS_Sharpen1' | 'TMGS_Sharpen2' | 'TMGS_Sharpen3' | 'TMGS_Sharpen4' | 'TMGS_Sharpen5' | 'TMGS_Sharpen6' | 'TMGS_Sharpen7' | 'TMGS_Sharpen8' | 'TMGS_Sharpen9' | 'TMGS_Sharpen10' | 'TMGS_NoMipmaps' | 'TMGS_LeaveExistingMips' | 'TMGS_Blur1' | 'TMGS_Blur2' | 'TMGS_Blur3' | 'TMGS_Blur4' | 'TMGS_Blur5';
declare var TextureMipGenSettings : { TMGS_FromTextureGroup:'TMGS_FromTextureGroup',TMGS_SimpleAverage:'TMGS_SimpleAverage',TMGS_Sharpen0:'TMGS_Sharpen0',TMGS_Sharpen1:'TMGS_Sharpen1',TMGS_Sharpen2:'TMGS_Sharpen2',TMGS_Sharpen3:'TMGS_Sharpen3',TMGS_Sharpen4:'TMGS_Sharpen4',TMGS_Sharpen5:'TMGS_Sharpen5',TMGS_Sharpen6:'TMGS_Sharpen6',TMGS_Sharpen7:'TMGS_Sharpen7',TMGS_Sharpen8:'TMGS_Sharpen8',TMGS_Sharpen9:'TMGS_Sharpen9',TMGS_Sharpen10:'TMGS_Sharpen10',TMGS_NoMipmaps:'TMGS_NoMipmaps',TMGS_LeaveExistingMips:'TMGS_LeaveExistingMips',TMGS_Blur1:'TMGS_Blur1',TMGS_Blur2:'TMGS_Blur2',TMGS_Blur3:'TMGS_Blur3',TMGS_Blur4:'TMGS_Blur4',TMGS_Blur5:'TMGS_Blur5', };
declare type ECompositeTextureMode = 'CTM_Disabled' | 'CTM_NormalRoughnessToRed' | 'CTM_NormalRoughnessToGreen' | 'CTM_NormalRoughnessToBlue' | 'CTM_NormalRoughnessToAlpha';
declare var ECompositeTextureMode : { CTM_Disabled:'CTM_Disabled',CTM_NormalRoughnessToRed:'CTM_NormalRoughnessToRed',CTM_NormalRoughnessToGreen:'CTM_NormalRoughnessToGreen',CTM_NormalRoughnessToBlue:'CTM_NormalRoughnessToBlue',CTM_NormalRoughnessToAlpha:'CTM_NormalRoughnessToAlpha', };
declare type TextureCompressionSettings = 'TC_Default' | 'TC_Normalmap' | 'TC_Masks' | 'TC_Grayscale' | 'TC_Displacementmap' | 'TC_VectorDisplacementmap' | 'TC_HDR' | 'TC_EditorIcon' | 'TC_Alpha' | 'TC_DistanceFieldFont' | 'TC_HDR_Compressed' | 'TC_BC7';
declare var TextureCompressionSettings : { TC_Default:'TC_Default',TC_Normalmap:'TC_Normalmap',TC_Masks:'TC_Masks',TC_Grayscale:'TC_Grayscale',TC_Displacementmap:'TC_Displacementmap',TC_VectorDisplacementmap:'TC_VectorDisplacementmap',TC_HDR:'TC_HDR',TC_EditorIcon:'TC_EditorIcon',TC_Alpha:'TC_Alpha',TC_DistanceFieldFont:'TC_DistanceFieldFont',TC_HDR_Compressed:'TC_HDR_Compressed',TC_BC7:'TC_BC7', };
declare type TextureFilter = 'TF_Nearest' | 'TF_Bilinear' | 'TF_Trilinear' | 'TF_Default';
declare var TextureFilter : { TF_Nearest:'TF_Nearest',TF_Bilinear:'TF_Bilinear',TF_Trilinear:'TF_Trilinear',TF_Default:'TF_Default', };
declare type TextureGroup = 'TEXTUREGROUP_World' | 'TEXTUREGROUP_WorldNormalMap' | 'TEXTUREGROUP_WorldSpecular' | 'TEXTUREGROUP_Character' | 'TEXTUREGROUP_CharacterNormalMap' | 'TEXTUREGROUP_CharacterSpecular' | 'TEXTUREGROUP_Weapon' | 'TEXTUREGROUP_WeaponNormalMap' | 'TEXTUREGROUP_WeaponSpecular' | 'TEXTUREGROUP_Vehicle' | 'TEXTUREGROUP_VehicleNormalMap' | 'TEXTUREGROUP_VehicleSpecular' | 'TEXTUREGROUP_Cinematic' | 'TEXTUREGROUP_Effects' | 'TEXTUREGROUP_EffectsNotFiltered' | 'TEXTUREGROUP_Skybox' | 'TEXTUREGROUP_UI' | 'TEXTUREGROUP_Lightmap' | 'TEXTUREGROUP_RenderTarget' | 'TEXTUREGROUP_MobileFlattened' | 'TEXTUREGROUP_ProcBuilding_Face' | 'TEXTUREGROUP_ProcBuilding_LightMap' | 'TEXTUREGROUP_Shadowmap' | 'TEXTUREGROUP_ColorLookupTable' | 'TEXTUREGROUP_Terrain_Heightmap' | 'TEXTUREGROUP_Terrain_Weightmap' | 'TEXTUREGROUP_Bokeh' | 'TEXTUREGROUP_IESLightProfile' | 'TEXTUREGROUP_Pixels2D' | 'TEXTUREGROUP_HierarchicalLOD';
declare var TextureGroup : { TEXTUREGROUP_World:'TEXTUREGROUP_World',TEXTUREGROUP_WorldNormalMap:'TEXTUREGROUP_WorldNormalMap',TEXTUREGROUP_WorldSpecular:'TEXTUREGROUP_WorldSpecular',TEXTUREGROUP_Character:'TEXTUREGROUP_Character',TEXTUREGROUP_CharacterNormalMap:'TEXTUREGROUP_CharacterNormalMap',TEXTUREGROUP_CharacterSpecular:'TEXTUREGROUP_CharacterSpecular',TEXTUREGROUP_Weapon:'TEXTUREGROUP_Weapon',TEXTUREGROUP_WeaponNormalMap:'TEXTUREGROUP_WeaponNormalMap',TEXTUREGROUP_WeaponSpecular:'TEXTUREGROUP_WeaponSpecular',TEXTUREGROUP_Vehicle:'TEXTUREGROUP_Vehicle',TEXTUREGROUP_VehicleNormalMap:'TEXTUREGROUP_VehicleNormalMap',TEXTUREGROUP_VehicleSpecular:'TEXTUREGROUP_VehicleSpecular',TEXTUREGROUP_Cinematic:'TEXTUREGROUP_Cinematic',TEXTUREGROUP_Effects:'TEXTUREGROUP_Effects',TEXTUREGROUP_EffectsNotFiltered:'TEXTUREGROUP_EffectsNotFiltered',TEXTUREGROUP_Skybox:'TEXTUREGROUP_Skybox',TEXTUREGROUP_UI:'TEXTUREGROUP_UI',TEXTUREGROUP_Lightmap:'TEXTUREGROUP_Lightmap',TEXTUREGROUP_RenderTarget:'TEXTUREGROUP_RenderTarget',TEXTUREGROUP_MobileFlattened:'TEXTUREGROUP_MobileFlattened',TEXTUREGROUP_ProcBuilding_Face:'TEXTUREGROUP_ProcBuilding_Face',TEXTUREGROUP_ProcBuilding_LightMap:'TEXTUREGROUP_ProcBuilding_LightMap',TEXTUREGROUP_Shadowmap:'TEXTUREGROUP_Shadowmap',TEXTUREGROUP_ColorLookupTable:'TEXTUREGROUP_ColorLookupTable',TEXTUREGROUP_Terrain_Heightmap:'TEXTUREGROUP_Terrain_Heightmap',TEXTUREGROUP_Terrain_Weightmap:'TEXTUREGROUP_Terrain_Weightmap',TEXTUREGROUP_Bokeh:'TEXTUREGROUP_Bokeh',TEXTUREGROUP_IESLightProfile:'TEXTUREGROUP_IESLightProfile',TEXTUREGROUP_Pixels2D:'TEXTUREGROUP_Pixels2D',TEXTUREGROUP_HierarchicalLOD:'TEXTUREGROUP_HierarchicalLOD', };
declare class Texture extends UObject { 
	Source: TextureSource;
	LightingGuid: Guid;
	SourceFilePath: string;
	AssetImportData: AssetImportData;
	AdjustBrightness: number;
	AdjustBrightnessCurve: number;
	AdjustVibrance: number;
	AdjustSaturation: number;
	AdjustRGBCurve: number;
	AdjustHue: number;
	AdjustMinAlpha: number;
	AdjustMaxAlpha: number;
	CompressionNoAlpha: boolean;
	CompressionNone: boolean;
	DeferCompression: boolean;
	MaxTextureSize: number;
	CompressionQuality: ETextureCompressionQuality;
	bDitherMipMapAlpha: boolean;
	AlphaCoverageThresholds: Vector4;
	bPreserveBorder: boolean;
	bFlipGreenChannel: boolean;
	bForcePVRTC4: boolean;
	PowerOfTwoMode: ETexturePowerOfTwoSetting;
	PaddingColor: Color;
	bChromaKeyTexture: boolean;
	ChromaKeyThreshold: number;
	ChromaKeyColor: Color;
	MipGenSettings: TextureMipGenSettings;
	CompositeTexture: Texture;
	CompositeTextureMode: ECompositeTextureMode;
	CompositePower: number;
	LODBias: number;
	NumCinematicMipLevels: number;
	SRGB: boolean;
	bUseLegacyGamma: boolean;
	NeverStream: boolean;
	bNoTiling: boolean;
	bUseCinematicMipLevels: boolean;
	AssetUserData: AssetUserData[];
	CachedCombinedLODBias: number;
	bAsyncResourceReleaseHasBeenStarted: boolean;
	CompressionSettings: TextureCompressionSettings;
	Filter: TextureFilter;
	LODGroup: TextureGroup;
	static Load(ResourceName: string): Texture;
	static Find(Outer: UObject, ResourceName: string): Texture;
	static GetDefaultObject(): Texture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture;
	static C(Other: UObject | any): Texture;
	SetSplashScreen(Scale: Vector2D,Offset: Vector2D,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	SetSpectatorScreenTexture(): void;
	static SetSplashScreen(Texture: Texture,Scale: Vector2D,Offset: Vector2D,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static SetSpectatorScreenTexture(InTexture: Texture): void;
}

declare type EMaterialUsage = 'MATUSAGE_SkeletalMesh' | 'MATUSAGE_ParticleSprites' | 'MATUSAGE_BeamTrails' | 'MATUSAGE_MeshParticles' | 'MATUSAGE_StaticLighting' | 'MATUSAGE_MorphTargets' | 'MATUSAGE_SplineMesh' | 'MATUSAGE_InstancedStaticMeshes' | 'MATUSAGE_Clothing' | 'MATUSAGE_NiagaraSprites' | 'MATUSAGE_NiagaraRibbons' | 'MATUSAGE_NiagaraMeshParticles';
declare var EMaterialUsage : { MATUSAGE_SkeletalMesh:'MATUSAGE_SkeletalMesh',MATUSAGE_ParticleSprites:'MATUSAGE_ParticleSprites',MATUSAGE_BeamTrails:'MATUSAGE_BeamTrails',MATUSAGE_MeshParticles:'MATUSAGE_MeshParticles',MATUSAGE_StaticLighting:'MATUSAGE_StaticLighting',MATUSAGE_MorphTargets:'MATUSAGE_MorphTargets',MATUSAGE_SplineMesh:'MATUSAGE_SplineMesh',MATUSAGE_InstancedStaticMeshes:'MATUSAGE_InstancedStaticMeshes',MATUSAGE_Clothing:'MATUSAGE_Clothing',MATUSAGE_NiagaraSprites:'MATUSAGE_NiagaraSprites',MATUSAGE_NiagaraRibbons:'MATUSAGE_NiagaraRibbons',MATUSAGE_NiagaraMeshParticles:'MATUSAGE_NiagaraMeshParticles', };
declare class Material extends MaterialInterface { 
	PhysMaterial: PhysicalMaterial;
	DiffuseColor: ColorMaterialInput;
	SpecularColor: ColorMaterialInput;
	BaseColor: ColorMaterialInput;
	Metallic: ScalarMaterialInput;
	Specular: ScalarMaterialInput;
	Roughness: ScalarMaterialInput;
	Normal: VectorMaterialInput;
	EmissiveColor: ColorMaterialInput;
	Opacity: ScalarMaterialInput;
	OpacityMask: ScalarMaterialInput;
	MaterialDomain: EMaterialDomain;
	BlendMode: EBlendMode;
	DecalBlendMode: EDecalBlendMode;
	MaterialDecalResponse: EMaterialDecalResponse;
	ShadingModel: EMaterialShadingModel;
	OpacityMaskClipValue: number;
	bCastDynamicShadowAsMasked: boolean;
	WorldPositionOffset: VectorMaterialInput;
	WorldDisplacement: VectorMaterialInput;
	TessellationMultiplier: ScalarMaterialInput;
	SubsurfaceColor: ColorMaterialInput;
	ClearCoat: ScalarMaterialInput;
	ClearCoatRoughness: ScalarMaterialInput;
	AmbientOcclusion: ScalarMaterialInput;
	Refraction: ScalarMaterialInput;
	CustomizedUVs: Vector2MaterialInput;
	MaterialAttributes: MaterialAttributesInput;
	PixelDepthOffset: ScalarMaterialInput;
	bEnableSeparateTranslucency: boolean;
	bEnableMobileSeparateTranslucency: boolean;
	bEnableResponsiveAA: boolean;
	bScreenSpaceReflections: boolean;
	TwoSided: boolean;
	DitheredLODTransition: boolean;
	DitherOpacityMask: boolean;
	bAllowNegativeEmissiveColor: boolean;
	NumCustomizedUVs: number;
	TranslucencyLightingMode: ETranslucencyLightingMode;
	TranslucencyDirectionalLightingIntensity: number;
	AllowTranslucentCustomDepthWrites: boolean;
	TranslucentShadowDensityScale: number;
	TranslucentSelfShadowDensityScale: number;
	TranslucentSelfShadowSecondDensityScale: number;
	TranslucentSelfShadowSecondOpacity: number;
	TranslucentBackscatteringExponent: number;
	TranslucentMultipleScatteringExtinction: LinearColor;
	TranslucentShadowStartOffset: number;
	bDisableDepthTest: boolean;
	bGenerateSphericalParticleNormals: boolean;
	bTangentSpaceNormal: boolean;
	bUseEmissiveForDynamicAreaLighting: boolean;
	bBlockGI: boolean;
	bUsedAsSpecialEngineMaterial: boolean;
	bUsedWithSkeletalMesh: boolean;
	bUsedWithEditorCompositing: boolean;
	bUsedWithParticleSprites: boolean;
	bUsedWithBeamTrails: boolean;
	bUsedWithMeshParticles: boolean;
	bUsedWithNiagaraSprites: boolean;
	bUsedWithNiagaraRibbons: boolean;
	bUsedWithNiagaraMeshParticles: boolean;
	bUsedWithStaticLighting: boolean;
	bUsedWithMorphTargets: boolean;
	bUsedWithSplineMeshes: boolean;
	bUsedWithInstancedStaticMeshes: boolean;
	bUsesDistortion: boolean;
	bUsedWithClothing: boolean;
	bUsedWithUI: boolean;
	bAutomaticallySetUsageInEditor: boolean;
	bFullyRough: boolean;
	bUseFullPrecision: boolean;
	bUseLightmapDirectionality: boolean;
	bUseHQForwardReflections: boolean;
	bUsePlanarForwardReflections: boolean;
	bNormalCurvatureToRoughness: boolean;
	D3D11TessellationMode: EMaterialTessellationMode;
	bEnableCrackFreeDisplacement: boolean;
	bEnableAdaptiveTessellation: boolean;
	MaxDisplacement: number;
	Wireframe: boolean;
	bOutputVelocityOnBasePass: boolean;
	EditorX: number;
	EditorY: number;
	EditorPitch: number;
	EditorYaw: number;
	Expressions: MaterialExpression[];
	EditorComments: MaterialExpressionComment[];
	ParameterGroupData: ParameterGroupData[];
	MaterialFunctionInfos: MaterialFunctionInfo[];
	MaterialParameterCollectionInfos: MaterialParameterCollectionInfo[];
	bCanMaskedBeAssumedOpaque: boolean;
	bIsMasked: boolean;
	bIsPreviewMaterial: boolean;
	bUseMaterialAttributes: boolean;
	bUseTranslucencyVertexFog: boolean;
	bComputeFogPerPixel: boolean;
	bAllowDevelopmentShaderCompile: boolean;
	bIsMaterialEditorStatsMaterial: boolean;
	UsageFlagWarnings: any;
	BlendableLocation: EBlendableLocation;
	BlendablePriority: number;
	BlendableOutputAlpha: boolean;
	RefractionMode: ERefractionMode;
	RefractionDepthBias: number;
	StateId: Guid;
	ExpressionTextureReferences: Texture[];
	ReferencedTextureGuids: Guid[];
	static Load(ResourceName: string): Material;
	static Find(Outer: UObject, ResourceName: string): Material;
	static GetDefaultObject(): Material;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Material;
	static C(Other: UObject | any): Material;
	CreateMaterialExpression(ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	DeleteAllMaterialExpressions(): void;
	DeleteMaterialExpression(Expression: MaterialExpression): void;
	GetNumMaterialExpressions(): number;
	RecompileMaterial(): void;
	SetMaterialUsage(Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static GetNumMaterialExpressions(Material: Material): number;
	static RecompileMaterial(Material: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
}

declare type EAttachLocation = 'KeepRelativeOffset' | 'KeepWorldPosition' | 'SnapToTarget' | 'SnapToTargetIncludingScale';
declare var EAttachLocation : { KeepRelativeOffset:'KeepRelativeOffset',KeepWorldPosition:'KeepWorldPosition',SnapToTarget:'SnapToTarget',SnapToTargetIncludingScale:'SnapToTargetIncludingScale', };
declare type EFontCacheType = 'Offline' | 'Runtime';
declare var EFontCacheType : { Offline:'Offline',Runtime:'Runtime', };
declare class FontCharacter { 
	StartU: number;
	StartV: number;
	USize: number;
	VSize: number;
	TextureIndex: number;
	VerticalOffset: number;
	clone() : FontCharacter;
	static C(Other: UObject | any): FontCharacter;
}

declare class IntPoint { 
	X: number;
	Y: number;
	clone() : IntPoint;
	static C(Other: UObject | any): IntPoint;
}

declare type TextureAddress = 'TA_Wrap' | 'TA_Clamp' | 'TA_Mirror';
declare var TextureAddress : { TA_Wrap:'TA_Wrap',TA_Clamp:'TA_Clamp',TA_Mirror:'TA_Mirror', };
declare type EImportanceWeight = 'Luminance' | 'Red' | 'Green' | 'Blue' | 'Alpha';
declare var EImportanceWeight : { Luminance:'Luminance',Red:'Red',Green:'Green',Blue:'Blue',Alpha:'Alpha', };
declare class ImportanceTexture { 
	Size: IntPoint;
	NumMips: number;
	MarginalCDF: number[];
	ConditionalCDF: number[];
	TextureData: Color[];
	Texture: any;
	Weighting: EImportanceWeight;
	clone() : ImportanceTexture;
	static C(Other: UObject | any): ImportanceTexture;
	BreakImportanceTexture(Texture?: Texture2D,WeightingFunc?: EImportanceWeight): {Texture: Texture2D, WeightingFunc: EImportanceWeight};
	ImportanceSample(Rand: Vector2D,Samples: number,Intensity: number,SamplePosition?: Vector2D,SampleColor?: LinearColor,SampleIntensity?: number,SampleSize?: number): {SamplePosition: Vector2D, SampleColor: LinearColor, SampleIntensity: number, SampleSize: number};
	static BreakImportanceTexture(ImportanceTexture: ImportanceTexture,Texture?: Texture2D,WeightingFunc?: EImportanceWeight): {Texture: Texture2D, WeightingFunc: EImportanceWeight};
	static ImportanceSample(Texture: ImportanceTexture,Rand: Vector2D,Samples: number,Intensity: number,SamplePosition?: Vector2D,SampleColor?: LinearColor,SampleIntensity?: number,SampleSize?: number): {SamplePosition: Vector2D, SampleColor: LinearColor, SampleIntensity: number, SampleSize: number};
}

declare class Margin { 
	Left: number;
	Top: number;
	Right: number;
	Bottom: number;
	clone() : Margin;
	static C(Other: UObject | any): Margin;
}

declare type ESlateColorStylingMode = 'UseColor_Specified' | 'UseColor_Specified_Link' | 'UseColor_Foreground' | 'UseColor_Foreground_Subdued';
declare var ESlateColorStylingMode : { UseColor_Specified:'UseColor_Specified',UseColor_Specified_Link:'UseColor_Specified_Link',UseColor_Foreground:'UseColor_Foreground',UseColor_Foreground_Subdued:'UseColor_Foreground_Subdued', };
declare class SlateColor { 
	SpecifiedColor: LinearColor;
	ColorUseRule: ESlateColorStylingMode;
	clone() : SlateColor;
	static C(Other: UObject | any): SlateColor;
	static SlateColor_UseForeground(): SlateColor;
	static SlateColor_UseSubduedForeground(): SlateColor;
}

declare type ESlateBrushDrawType = 'NoDrawType' | 'Box' | 'Border' | 'Image';
declare var ESlateBrushDrawType : { NoDrawType:'NoDrawType',Box:'Box',Border:'Border',Image:'Image', };
declare type ESlateBrushTileType = 'NoTile' | 'Horizontal' | 'Vertical' | 'Both';
declare var ESlateBrushTileType : { NoTile:'NoTile',Horizontal:'Horizontal',Vertical:'Vertical',Both:'Both', };
declare type ESlateBrushMirrorType = 'NoMirror' | 'Horizontal' | 'Vertical' | 'Both';
declare var ESlateBrushMirrorType : { NoMirror:'NoMirror',Horizontal:'Horizontal',Vertical:'Vertical',Both:'Both', };
declare type ESlateBrushImageType = 'NoImage' | 'FullColor' | 'Linear';
declare var ESlateBrushImageType : { NoImage:'NoImage',FullColor:'FullColor',Linear:'Linear', };
declare class SlateBrush { 
	ImageSize: Vector2D;
	Margin: Margin;
	Tint: LinearColor;
	TintColor: SlateColor;
	ResourceObject: UObject;
	ResourceName: string;
	UVRegion: Box2D;
	DrawAs: ESlateBrushDrawType;
	Tiling: ESlateBrushTileType;
	Mirroring: ESlateBrushMirrorType;
	ImageType: ESlateBrushImageType;
	bIsDynamicallyLoaded: boolean;
	bHasUObject: boolean;
	clone() : SlateBrush;
	static C(Other: UObject | any): SlateBrush;
	GetBrushResource(): {Brush: SlateBrush, $: UObject};
	GetBrushResourceAsMaterial(): {Brush: SlateBrush, $: MaterialInterface};
	GetBrushResourceAsTexture2D(): {Brush: SlateBrush, $: Texture2D};
	GetDynamicMaterial(): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	SetBrushResourceToMaterial(Material?: MaterialInterface): {Brush: SlateBrush};
	SetBrushResourceToTexture(Texture?: Texture2D): {Brush: SlateBrush};
	EqualEqual_SlateBrush(B: SlateBrush): boolean;
	static GetBrushResource(Brush?: SlateBrush): {Brush: SlateBrush, $: UObject};
	static GetBrushResourceAsMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInterface};
	static GetBrushResourceAsTexture2D(Brush?: SlateBrush): {Brush: SlateBrush, $: Texture2D};
	static GetDynamicMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	static SetBrushResourceToMaterial(Brush?: SlateBrush,Material?: MaterialInterface): {Brush: SlateBrush};
	static SetBrushResourceToTexture(Brush?: SlateBrush,Texture?: Texture2D): {Brush: SlateBrush};
	static EqualEqual_SlateBrush(A: SlateBrush,B: SlateBrush): boolean;
	static NoResourceBrush(): SlateBrush;
}

declare class Texture2D extends Texture { 
	StreamingIndex: number;
	LevelIndex: number;
	FirstResourceMemMip: number;
	ImportedSize: IntPoint;
	ForceMipLevelsToBeResidentTimestamp: any;
	bTemporarilyDisableStreaming: boolean;
	bIsStreamable: boolean;
	bHasStreamingUpdatePending: boolean;
	bForceMiplevelsToBeResident: boolean;
	bIgnoreStreamingMipBias: boolean;
	bGlobalForceMipLevelsToBeResident: boolean;
	bHasBeenPaintedInEditor: boolean;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	static Load(ResourceName: string): Texture2D;
	static Find(Outer: UObject, ResourceName: string): Texture2D;
	static GetDefaultObject(): Texture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2D;
	Blueprint_GetSizeY(): number;
	Blueprint_GetSizeX(): number;
	static C(Other: UObject | any): Texture2D;
	AddLoadingSplashScreen(TranslationInMeters: Vector,Rotation: Rotator,SizeInMeters: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	ShowLoadingIcon(): void;
	MakeImportanceTexture(WeightingFunc: EImportanceWeight): ImportanceTexture;
	MakeBrushFromTexture(Width: number,Height: number): SlateBrush;
	static AddLoadingSplashScreen(Texture: Texture2D,TranslationInMeters: Vector,Rotation: Rotator,SizeInMeters: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	static ShowLoadingIcon(Texture: Texture2D): void;
	static MakeImportanceTexture(Texture: Texture2D,WeightingFunc: EImportanceWeight): ImportanceTexture;
	static MakeBrushFromTexture(Texture: Texture2D,Width: number,Height: number): SlateBrush;
}

declare type EFontImportCharacterSet = 'FontICS_Default' | 'FontICS_Ansi' | 'FontICS_Symbol';
declare var EFontImportCharacterSet : { FontICS_Default:'FontICS_Default',FontICS_Ansi:'FontICS_Ansi',FontICS_Symbol:'FontICS_Symbol', };
declare class FontImportOptionsData { 
	FontName: string;
	Height: number;
	bEnableAntialiasing: boolean;
	bEnableBold: boolean;
	bEnableItalic: boolean;
	bEnableUnderline: boolean;
	bAlphaOnly: boolean;
	CharacterSet: EFontImportCharacterSet;
	Chars: string;
	UnicodeRange: string;
	CharsFilePath: string;
	CharsFileWildcard: string;
	bCreatePrintableOnly: boolean;
	bIncludeASCIIRange: boolean;
	ForegroundColor: LinearColor;
	bEnableDropShadow: boolean;
	TexturePageWidth: number;
	TexturePageMaxHeight: number;
	XPadding: number;
	YPadding: number;
	ExtendBoxTop: number;
	ExtendBoxBottom: number;
	ExtendBoxRight: number;
	ExtendBoxLeft: number;
	bEnableLegacyMode: boolean;
	Kerning: number;
	bUseDistanceFieldAlpha: boolean;
	DistanceFieldScaleFactor: number;
	DistanceFieldScanRadiusScale: number;
	clone() : FontImportOptionsData;
	static C(Other: UObject | any): FontImportOptionsData;
}

declare type EFontHinting = 'Default' | 'Auto' | 'AutoLight' | 'Monochrome' | 'None';
declare var EFontHinting : { Default:'Default',Auto:'Auto',AutoLight:'AutoLight',Monochrome:'Monochrome',None:'None', };
declare type EFontLoadingPolicy = 'LazyLoad' | 'Stream' | 'Inline';
declare var EFontLoadingPolicy : { LazyLoad:'LazyLoad',Stream:'Stream',Inline:'Inline', };
declare class FontBulkData extends UObject { 
	static Load(ResourceName: string): FontBulkData;
	static Find(Outer: UObject, ResourceName: string): FontBulkData;
	static GetDefaultObject(): FontBulkData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontBulkData;
	static C(Other: UObject | any): FontBulkData;
}

declare class FontData { 
	FontFilename: string;
	Hinting: Hinting;
	LoadingPolicy: LoadingPolicy;
	FontFaceAsset: UObject;
	BulkDataPtr: FontBulkData;
	FontData: number[];
	clone() : FontData;
	static C(Other: UObject | any): FontData;
}

declare class TypefaceEntry { 
	Name: string;
	Font: FontData;
	clone() : TypefaceEntry;
	static C(Other: UObject | any): TypefaceEntry;
}

declare class Typeface { 
	Fonts: TypefaceEntry[];
	clone() : Typeface;
	static C(Other: UObject | any): Typeface;
}

declare type ERangeBoundTypes = 'Exclusive' | 'Inclusive' | 'Open';
declare var ERangeBoundTypes : { Exclusive:'Exclusive',Inclusive:'Inclusive',Open:'Open', };
declare class Int32RangeBound { 
	Type: ERangeBoundTypes;
	Value: number;
	clone() : Int32RangeBound;
	static C(Other: UObject | any): Int32RangeBound;
}

declare class Int32Range { 
	LowerBound: Int32RangeBound;
	UpperBound: Int32RangeBound;
	clone() : Int32Range;
	static C(Other: UObject | any): Int32Range;
}

declare class CompositeSubFont { 
	Typeface: Typeface;
	CharacterRanges: Int32Range[];
	ScalingFactor: number;
	EditorName: string;
	clone() : CompositeSubFont;
	static C(Other: UObject | any): CompositeSubFont;
}

declare class CompositeFont { 
	DefaultTypeface: Typeface;
	SubTypefaces: CompositeSubFont[];
	clone() : CompositeFont;
	static C(Other: UObject | any): CompositeFont;
}

declare class Font extends UObject { 
	FontCacheType: FontCacheType;
	Characters: FontCharacter[];
	Textures: Texture2D[];
	IsRemapped: number;
	EmScale: number;
	Ascent: number;
	Descent: number;
	Leading: number;
	Kerning: number;
	ImportOptions: FontImportOptionsData;
	NumCharacters: number;
	MaxCharHeight: number[];
	ScalingFactor: number;
	LegacyFontSize: number;
	LegacyFontName: string;
	CompositeFont: CompositeFont;
	static Load(ResourceName: string): Font;
	static Find(Outer: UObject, ResourceName: string): Font;
	static GetDefaultObject(): Font;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Font;
	static C(Other: UObject | any): Font;
}

declare class FontParameterValue { 
	ParameterName: string;
	FontValue: Font;
	FontPage: number;
	ExpressionGUID: Guid;
	clone() : FontParameterValue;
	static C(Other: UObject | any): FontParameterValue;
}

declare class ScalarParameterValue { 
	ParameterName: string;
	ParameterValue: number;
	ExpressionGUID: Guid;
	clone() : ScalarParameterValue;
	static C(Other: UObject | any): ScalarParameterValue;
}

declare class TextureParameterValue { 
	ParameterName: string;
	ParameterValue: Texture;
	ExpressionGUID: Guid;
	clone() : TextureParameterValue;
	static C(Other: UObject | any): TextureParameterValue;
}

declare class VectorParameterValue { 
	ParameterName: string;
	ParameterValue: LinearColor;
	ExpressionGUID: Guid;
	clone() : VectorParameterValue;
	static C(Other: UObject | any): VectorParameterValue;
}

declare class MaterialInstanceBasePropertyOverrides { 
	bOverride_OpacityMaskClipValue: boolean;
	bOverride_BlendMode: boolean;
	bOverride_ShadingModel: boolean;
	bOverride_DitheredLODTransition: boolean;
	bOverride_CastDynamicShadowAsMasked: boolean;
	bOverride_TwoSided: boolean;
	OpacityMaskClipValue: number;
	BlendMode: EBlendMode;
	ShadingModel: EMaterialShadingModel;
	TwoSided: boolean;
	DitheredLODTransition: boolean;
	bCastDynamicShadowAsMasked: boolean;
	clone() : MaterialInstanceBasePropertyOverrides;
	static C(Other: UObject | any): MaterialInstanceBasePropertyOverrides;
}

declare class MaterialInstance extends MaterialInterface { 
	PhysMaterial: PhysicalMaterial;
	Parent: MaterialInterface;
	bHasStaticPermutationResource: boolean;
	bOverrideSubsurfaceProfile: boolean;
	FontParameterValues: FontParameterValue[];
	ScalarParameterValues: ScalarParameterValue[];
	TextureParameterValues: TextureParameterValue[];
	VectorParameterValues: VectorParameterValue[];
	bOverrideBaseProperties: boolean;
	BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
	ReferencedTextureGuids: Guid[];
	static Load(ResourceName: string): MaterialInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialInstance;
	static GetDefaultObject(): MaterialInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstance;
	static C(Other: UObject | any): MaterialInstance;
}

declare class MaterialInstanceDynamic extends MaterialInstance { 
	static Load(ResourceName: string): MaterialInstanceDynamic;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceDynamic;
	static GetDefaultObject(): MaterialInstanceDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceDynamic;
	SetVectorParameterValue(ParameterName: string,Value: LinearColor): void;
	SetTextureParameterValue(ParameterName: string,Value: Texture): void;
	SetScalarParameterValue(ParameterName: string,Value: number): void;
	K2_InterpolateMaterialInstanceParams(SourceA: MaterialInstance,SourceB: MaterialInstance,Alpha: number): void;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValue(ParameterName: string): number;
	K2_CopyMaterialInstanceParameters(Source: MaterialInterface): void;
	CopyParameterOverrides(MaterialInstance: MaterialInstance): void;
	CopyInterpParameters(Source: MaterialInstance): void;
	static C(Other: UObject | any): MaterialInstanceDynamic;
}

declare class DecalComponent extends SceneComponent { 
	DecalMaterial: MaterialInterface;
	SortOrder: number;
	FadeScreenSize: number;
	FadeStartDelay: number;
	FadeDuration: number;
	bDestroyOwnerAfterFade: boolean;
	DecalSize: Vector;
	static Load(ResourceName: string): DecalComponent;
	static Find(Outer: UObject, ResourceName: string): DecalComponent;
	static GetDefaultObject(): DecalComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DecalComponent;
	SetSortOrder(Value: number): void;
	SetFadeScreenSize(NewFadeScreenSize: number): void;
	SetFadeOut(StartDelay: number,Duration: number,DestroyOwnerAfterFade: boolean): void;
	SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
	GetFadeStartDelay(): number;
	GetFadeDuration(): number;
	GetDecalMaterial(): MaterialInterface;
	CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
	static C(Other: UObject | any): DecalComponent;
}

declare class MaterialInterface extends UObject { 
	SubsurfaceProfile: SubsurfaceProfile;
	LightmassSettings: LightmassMaterialInterfaceSettings;
	bTextureStreamingDataSorted: boolean;
	TextureStreamingDataVersion: number;
	TextureStreamingData: MaterialTextureInfo[];
	PreviewMesh: SoftObjectPath;
	ThumbnailInfo: ThumbnailInfo;
	LightingGuid: Guid;
	static Load(ResourceName: string): MaterialInterface;
	static Find(Outer: UObject, ResourceName: string): MaterialInterface;
	static GetDefaultObject(): MaterialInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInterface;
	SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident: boolean,bForceMiplevelsToBeResidentValue: boolean,ForceDuration: number,CinematicTextureGroups: number): void;
	GetPhysicalMaterial(): PhysicalMaterial;
	GetBaseMaterial(): Material;
	static C(Other: UObject | any): MaterialInterface;
	SpawnDecalAttached(DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	MakeBrushFromMaterial(Width: number,Height: number): SlateBrush;
	static SpawnDecalAttached(DecalMaterial: MaterialInterface,DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	static MakeBrushFromMaterial(Material: MaterialInterface,Width: number,Height: number): SlateBrush;
}

declare type EAutoReceiveInput = 'Disabled' | 'Player0' | 'Player1' | 'Player2' | 'Player3' | 'Player4' | 'Player5' | 'Player6' | 'Player7';
declare var EAutoReceiveInput : { Disabled:'Disabled',Player0:'Player0',Player1:'Player1',Player2:'Player2',Player3:'Player3',Player4:'Player4',Player5:'Player5',Player6:'Player6',Player7:'Player7', };
declare type EAutoPossessAI = 'Disabled' | 'PlacedInWorld' | 'Spawned' | 'PlacedInWorldOrSpawned';
declare var EAutoPossessAI : { Disabled:'Disabled',PlacedInWorld:'PlacedInWorld',Spawned:'Spawned',PlacedInWorldOrSpawned:'PlacedInWorldOrSpawned', };
declare class MeshComponent extends PrimitiveComponent { 
	OverrideMaterials: MaterialInterface[];
	static Load(ResourceName: string): MeshComponent;
	static Find(Outer: UObject, ResourceName: string): MeshComponent;
	static GetDefaultObject(): MeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshComponent;
	SetVectorParameterValueOnMaterials(ParameterName: string,ParameterValue: Vector): void;
	SetScalarParameterValueOnMaterials(ParameterName: string,ParameterValue: number): void;
	PrestreamTextures(Seconds: number,bPrioritizeCharacterTextures: boolean,CinematicTextureGroups: number): void;
	IsMaterialSlotNameValid(MaterialSlotName: string): boolean;
	GetMaterialSlotNames(): string[];
	GetMaterials(): MaterialInterface[];
	GetMaterialIndex(MaterialSlotName: string): number;
	static C(Other: UObject | any): MeshComponent;
}

declare type EBoneTranslationRetargetingMode = 'Animation' | 'Skeleton' | 'AnimationScaled' | 'AnimationRelative';
declare var EBoneTranslationRetargetingMode : { Animation:'Animation',Skeleton:'Skeleton',AnimationScaled:'AnimationScaled',AnimationRelative:'AnimationRelative', };
declare class BoneNode { 
	Name: string;
	ParentIndex: number;
	TranslationRetargetingMode: EBoneTranslationRetargetingMode;
	clone() : BoneNode;
	static C(Other: UObject | any): BoneNode;
}

declare class VirtualBone { 
	SourceBoneName: string;
	TargetBoneName: string;
	VirtualBoneName: string;
	clone() : VirtualBone;
	static C(Other: UObject | any): VirtualBone;
}

declare class SkeletalMeshSocket extends UObject { 
	SocketName: string;
	BoneName: string;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale: Vector;
	bForceAlwaysAnimated: boolean;
	static Load(ResourceName: string): SkeletalMeshSocket;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshSocket;
	static GetDefaultObject(): SkeletalMeshSocket;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshSocket;
	InitializeSocketFromLocation(SkelComp: SkeletalMeshComponent,WorldLocation: Vector,WorldNormal: Vector): void;
	GetSocketLocation(SkelComp: SkeletalMeshComponent): Vector;
	static C(Other: UObject | any): SkeletalMeshSocket;
}

declare class SmartNameContainer { 
	clone() : SmartNameContainer;
	static C(Other: UObject | any): SmartNameContainer;
}

declare class BoneReference { 
	BoneName: string;
	clone() : BoneReference;
	static C(Other: UObject | any): BoneReference;
}

declare class BlendProfileBoneEntry { 
	BoneReference: BoneReference;
	BlendScale: number;
	clone() : BlendProfileBoneEntry;
	static C(Other: UObject | any): BlendProfileBoneEntry;
}

declare class BlendProfile extends UObject { 
	OwningSkeleton: Skeleton;
	ProfileEntries: BlendProfileBoneEntry[];
	static Load(ResourceName: string): BlendProfile;
	static Find(Outer: UObject, ResourceName: string): BlendProfile;
	static GetDefaultObject(): BlendProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendProfile;
	static C(Other: UObject | any): BlendProfile;
}

declare class AnimSlotGroup { 
	GroupName: string;
	SlotNames: string[];
	clone() : AnimSlotGroup;
	static C(Other: UObject | any): AnimSlotGroup;
}

declare type EConstraintTransform = 'Absolute' | 'Relative';
declare var EConstraintTransform : { Absolute:'Absolute',Relative:'Relative', };
declare class RigTransformConstraint { 
	TranformType: EConstraintTransform;
	ParentSpace: string;
	Weight: number;
	clone() : RigTransformConstraint;
	static C(Other: UObject | any): RigTransformConstraint;
}

declare class TransformBaseConstraint { 
	TransformConstraints: RigTransformConstraint[];
	clone() : TransformBaseConstraint;
	static C(Other: UObject | any): TransformBaseConstraint;
}

declare class TransformBase { 
	UNode: string;
	Constraints: TransformBaseConstraint;
	clone() : TransformBase;
	static C(Other: UObject | any): TransformBase;
}

declare class UNode { 
	Name: string;
	ParentName: string;
	Transform: Transform;
	DisplayName: string;
	bAdvanced: boolean;
	clone() : UNode;
	static C(Other: UObject | any): UNode;
}

declare class Rig extends UObject { 
	TransformBases: TransformBase[];
	Nodes: UNode[];
	static Load(ResourceName: string): Rig;
	static Find(Outer: UObject, ResourceName: string): Rig;
	static GetDefaultObject(): Rig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Rig;
	static C(Other: UObject | any): Rig;
}

declare class NameMapping { 
	NodeName: string;
	BoneName: string;
	clone() : NameMapping;
	static C(Other: UObject | any): NameMapping;
}

declare class RigConfiguration { 
	Rig: Rig;
	BoneMappingTable: NameMapping[];
	clone() : RigConfiguration;
	static C(Other: UObject | any): RigConfiguration;
}

declare class PreviewAttachedObjectPair { 
	AttachedObject: any;
	UObject: UObject;
	AttachedTo: string;
	clone() : PreviewAttachedObjectPair;
	static C(Other: UObject | any): PreviewAttachedObjectPair;
}

declare class PreviewAssetAttachContainer { 
	AttachedObjects: PreviewAttachedObjectPair[];
	clone() : PreviewAssetAttachContainer;
	static C(Other: UObject | any): PreviewAssetAttachContainer;
}

declare class Skeleton extends UObject { 
	BoneTree: BoneNode[];
	RefLocalPoses: Transform[];
	VirtualBoneGuid: Guid;
	VirtualBones: VirtualBone[];
	Sockets: SkeletalMeshSocket[];
	SmartNames: SmartNameContainer;
	BlendProfiles: BlendProfile[];
	SlotGroups: AnimSlotGroup[];
	PreviewSkeletalMesh: any;
	AdditionalPreviewSkeletalMeshes: any;
	RigConfig: RigConfiguration;
	AnimationNotifies: string[];
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): Skeleton;
	static Find(Outer: UObject, ResourceName: string): Skeleton;
	static GetDefaultObject(): Skeleton;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Skeleton;
	static C(Other: UObject | any): Skeleton;
}

declare class BoxSphereBounds { 
	Origin: Vector;
	BoxExtent: Vector;
	SphereRadius: number;
	clone() : BoxSphereBounds;
	static C(Other: UObject | any): BoxSphereBounds;
}

declare class MeshUVChannelInfo { 
	bInitialized: boolean;
	bOverrideDensities: boolean;
	LocalUVDensities: number;
	clone() : MeshUVChannelInfo;
	static C(Other: UObject | any): MeshUVChannelInfo;
}

declare class SkeletalMaterial { 
	MaterialInterface: MaterialInterface;
	bEnableShadowCasting: boolean;
	bRecomputeTangent: boolean;
	MaterialSlotName: string;
	ImportedMaterialSlotName: string;
	UVChannelData: MeshUVChannelInfo;
	clone() : SkeletalMaterial;
	static C(Other: UObject | any): SkeletalMaterial;
}

declare type EAxis = 'None' | 'X' | 'Y' | 'Z';
declare var EAxis : { None:'None',X:'X',Y:'Y',Z:'Z', };
declare class BoneMirrorInfo { 
	SourceIndex: number;
	BoneFlipAxis: EAxis;
	clone() : BoneMirrorInfo;
	static C(Other: UObject | any): BoneMirrorInfo;
}

declare type ETriangleSortOption = 'TRISORT_None' | 'TRISORT_CenterRadialDistance' | 'TRISORT_Random' | 'TRISORT_MergeContiguous' | 'TRISORT_Custom' | 'TRISORT_CustomLeftRight';
declare var ETriangleSortOption : { TRISORT_None:'TRISORT_None',TRISORT_CenterRadialDistance:'TRISORT_CenterRadialDistance',TRISORT_Random:'TRISORT_Random',TRISORT_MergeContiguous:'TRISORT_MergeContiguous',TRISORT_Custom:'TRISORT_Custom',TRISORT_CustomLeftRight:'TRISORT_CustomLeftRight', };
declare type ETriangleSortAxis = 'TSA_X_Axis' | 'TSA_Y_Axis' | 'TSA_Z_Axis';
declare var ETriangleSortAxis : { TSA_X_Axis:'TSA_X_Axis',TSA_Y_Axis:'TSA_Y_Axis',TSA_Z_Axis:'TSA_Z_Axis', };
declare class TriangleSortSettings { 
	TriangleSorting: ETriangleSortOption;
	CustomLeftRightAxis: ETriangleSortAxis;
	CustomLeftRightBoneName: string;
	clone() : TriangleSortSettings;
	static C(Other: UObject | any): TriangleSortSettings;
}

declare type SkeletalMeshOptimizationType = 'SMOT_NumOfTriangles' | 'SMOT_MaxDeviation';
declare var SkeletalMeshOptimizationType : { SMOT_NumOfTriangles:'SMOT_NumOfTriangles',SMOT_MaxDeviation:'SMOT_MaxDeviation', };
declare type SkeletalMeshOptimizationImportance = 'SMOI_Off' | 'SMOI_Lowest' | 'SMOI_Low' | 'SMOI_Normal' | 'SMOI_High' | 'SMOI_Highest';
declare var SkeletalMeshOptimizationImportance : { SMOI_Off:'SMOI_Off',SMOI_Lowest:'SMOI_Lowest',SMOI_Low:'SMOI_Low',SMOI_Normal:'SMOI_Normal',SMOI_High:'SMOI_High',SMOI_Highest:'SMOI_Highest', };
declare class AnimMetaData extends UObject { 
	static Load(ResourceName: string): AnimMetaData;
	static Find(Outer: UObject, ResourceName: string): AnimMetaData;
	static GetDefaultObject(): AnimMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMetaData;
	static C(Other: UObject | any): AnimMetaData;
}

declare class AssetMapping { 
	SourceAsset: AnimationAsset;
	TargetAsset: AnimationAsset;
	clone() : AssetMapping;
	static C(Other: UObject | any): AssetMapping;
}

declare class AssetMappingTable extends UObject { 
	MappedAssets: AssetMapping[];
	static Load(ResourceName: string): AssetMappingTable;
	static Find(Outer: UObject, ResourceName: string): AssetMappingTable;
	static GetDefaultObject(): AssetMappingTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetMappingTable;
	static C(Other: UObject | any): AssetMappingTable;
}

declare class SmartName { 
	DisplayName: string;
	clone() : SmartName;
	static C(Other: UObject | any): SmartName;
}

declare class PoseData { 
	LocalSpacePose: Transform[];
	LocalSpacePoseMask: boolean[];
	CurveData: number[];
	clone() : PoseData;
	static C(Other: UObject | any): PoseData;
}

declare class AnimCurveBase { 
	LastObservedName: string;
	Name: SmartName;
	CurveTypeFlags: number;
	clone() : AnimCurveBase;
	static C(Other: UObject | any): AnimCurveBase;
}

declare class PoseDataContainer { 
	PoseNames: SmartName[];
	Poses: PoseData[];
	Tracks: string[];
	TrackMap: any;
	Curves: AnimCurveBase[];
	clone() : PoseDataContainer;
	static C(Other: UObject | any): PoseDataContainer;
}

declare class PoseAsset extends AnimationAsset { 
	PoseContainer: PoseDataContainer;
	bAdditivePose: boolean;
	BasePoseIndex: number;
	RetargetSource: string;
	SourceAnimation: AnimSequence;
	static Load(ResourceName: string): PoseAsset;
	static Find(Outer: UObject, ResourceName: string): PoseAsset;
	static GetDefaultObject(): PoseAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseAsset;
	static C(Other: UObject | any): PoseAsset;
}

declare class AnimationAsset extends UObject { 
	Skeleton: Skeleton;
	MetaData: AnimMetaData[];
	ParentAsset: AnimationAsset;
	ChildrenAssets: AnimationAsset[];
	AssetMappingTable: AssetMappingTable;
	AssetUserData: AssetUserData[];
	ThumbnailInfo: ThumbnailInfo;
	PreviewPoseAsset: PoseAsset;
	PreviewSkeletalMesh: any;
	static Load(ResourceName: string): AnimationAsset;
	static Find(Outer: UObject, ResourceName: string): AnimationAsset;
	static GetDefaultObject(): AnimationAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationAsset;
	static C(Other: UObject | any): AnimationAsset;
}

declare class AnimCompositeBase extends AnimSequenceBase { 
	static Load(ResourceName: string): AnimCompositeBase;
	static Find(Outer: UObject, ResourceName: string): AnimCompositeBase;
	static GetDefaultObject(): AnimCompositeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompositeBase;
	static C(Other: UObject | any): AnimCompositeBase;
}

declare type EAlphaBlendOption = 'Linear' | 'Cubic' | 'HermiteCubic' | 'Sinusoidal' | 'QuadraticInOut' | 'CubicInOut' | 'QuarticInOut' | 'QuinticInOut' | 'CircularIn' | 'CircularOut' | 'CircularInOut' | 'ExpIn' | 'ExpOut' | 'ExpInOut' | 'Custom';
declare var EAlphaBlendOption : { Linear:'Linear',Cubic:'Cubic',HermiteCubic:'HermiteCubic',Sinusoidal:'Sinusoidal',QuadraticInOut:'QuadraticInOut',CubicInOut:'CubicInOut',QuarticInOut:'QuarticInOut',QuinticInOut:'QuinticInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut',ExpIn:'ExpIn',ExpOut:'ExpOut',ExpInOut:'ExpInOut',Custom:'Custom', };
declare class CurveBase extends UObject { 
	AssetImportData: AssetImportData;
	ImportPath: string;
	static Load(ResourceName: string): CurveBase;
	static Find(Outer: UObject, ResourceName: string): CurveBase;
	static GetDefaultObject(): CurveBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveBase;
	GetValueRange(MinValue?: number,MaxValue?: number): {MinValue: number, MaxValue: number};
	GetTimeRange(MinTime?: number,MaxTime?: number): {MinTime: number, MaxTime: number};
	static C(Other: UObject | any): CurveBase;
}

declare class KeyHandleMap { 
	clone() : KeyHandleMap;
	static C(Other: UObject | any): KeyHandleMap;
}

declare class IndexedCurve { 
	KeyHandlesToIndices: KeyHandleMap;
	clone() : IndexedCurve;
	static C(Other: UObject | any): IndexedCurve;
}

declare type ERichCurveExtrapolation = 'RCCE_Cycle' | 'RCCE_CycleWithOffset' | 'RCCE_Oscillate' | 'RCCE_Linear' | 'RCCE_Constant' | 'RCCE_None';
declare var ERichCurveExtrapolation : { RCCE_Cycle:'RCCE_Cycle',RCCE_CycleWithOffset:'RCCE_CycleWithOffset',RCCE_Oscillate:'RCCE_Oscillate',RCCE_Linear:'RCCE_Linear',RCCE_Constant:'RCCE_Constant',RCCE_None:'RCCE_None', };
declare type ERichCurveInterpMode = 'RCIM_Linear' | 'RCIM_Constant' | 'RCIM_Cubic' | 'RCIM_None';
declare var ERichCurveInterpMode : { RCIM_Linear:'RCIM_Linear',RCIM_Constant:'RCIM_Constant',RCIM_Cubic:'RCIM_Cubic',RCIM_None:'RCIM_None', };
declare type ERichCurveTangentMode = 'RCTM_Auto' | 'RCTM_User' | 'RCTM_Break' | 'RCTM_None';
declare var ERichCurveTangentMode : { RCTM_Auto:'RCTM_Auto',RCTM_User:'RCTM_User',RCTM_Break:'RCTM_Break',RCTM_None:'RCTM_None', };
declare type ERichCurveTangentWeightMode = 'RCTWM_WeightedNone' | 'RCTWM_WeightedArrive' | 'RCTWM_WeightedLeave' | 'RCTWM_WeightedBoth';
declare var ERichCurveTangentWeightMode : { RCTWM_WeightedNone:'RCTWM_WeightedNone',RCTWM_WeightedArrive:'RCTWM_WeightedArrive',RCTWM_WeightedLeave:'RCTWM_WeightedLeave',RCTWM_WeightedBoth:'RCTWM_WeightedBoth', };
declare class RichCurveKey { 
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	Time: number;
	Value: number;
	ArriveTangent: number;
	ArriveTangentWeight: number;
	LeaveTangent: number;
	LeaveTangentWeight: number;
	clone() : RichCurveKey;
	static C(Other: UObject | any): RichCurveKey;
}

declare class RichCurve extends IndexedCurve { 
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	DefaultValue: number;
	Keys: RichCurveKey[];
	clone() : RichCurve;
	static C(Other: UObject | any): RichCurve;
}

declare class CurveFloat extends CurveBase { 
	FloatCurve: RichCurve;
	bIsEventCurve: boolean;
	static Load(ResourceName: string): CurveFloat;
	static Find(Outer: UObject, ResourceName: string): CurveFloat;
	static GetDefaultObject(): CurveFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveFloat;
	GetFloatValue(InTime: number): number;
	static C(Other: UObject | any): CurveFloat;
}

declare class AlphaBlend { 
	BlendOption: BlendOption;
	CustomCurve: CurveFloat;
	BlendTime: number;
	clone() : AlphaBlend;
	static C(Other: UObject | any): AlphaBlend;
}

declare class AnimSyncMarker { 
	MarkerName: string;
	Time: number;
	TrackIndex: number;
	clone() : AnimSyncMarker;
	static C(Other: UObject | any): AnimSyncMarker;
}

declare class MarkerSyncData { 
	AuthoredSyncMarkers: AnimSyncMarker[];
	clone() : MarkerSyncData;
	static C(Other: UObject | any): MarkerSyncData;
}

declare class CompositeSection extends AnimLinkableElement { 
	SectionName: string;
	StartTime: number;
	NextSectionName: string;
	MetaData: AnimMetaData[];
	clone() : CompositeSection;
	static C(Other: UObject | any): CompositeSection;
}

declare class AnimSegment { 
	AnimReference: AnimSequenceBase;
	StartPos: number;
	AnimStartTime: number;
	AnimEndTime: number;
	AnimPlayRate: number;
	LoopingCount: number;
	clone() : AnimSegment;
	static C(Other: UObject | any): AnimSegment;
}

declare class AnimTrack { 
	AnimSegments: AnimSegment[];
	clone() : AnimTrack;
	static C(Other: UObject | any): AnimTrack;
}

declare class SlotAnimationTrack { 
	SlotName: string;
	AnimTrack: AnimTrack;
	clone() : SlotAnimationTrack;
	static C(Other: UObject | any): SlotAnimationTrack;
}

declare class BranchingPoint extends AnimLinkableElement { 
	EventName: string;
	DisplayTime: number;
	TriggerTimeOffset: number;
	clone() : BranchingPoint;
	static C(Other: UObject | any): BranchingPoint;
}

declare type ERootMotionRootLock = 'RefPose' | 'AnimFirstFrame' | 'Zero';
declare var ERootMotionRootLock : { RefPose:'RefPose',AnimFirstFrame:'AnimFirstFrame',Zero:'Zero', };
declare type EAnimNotifyEventType = 'Begin' | 'End';
declare var EAnimNotifyEventType : { Begin:'Begin',End:'End', };
declare class BranchingPointMarker { 
	NotifyIndex: number;
	TriggerTime: number;
	NotifyEventType: EAnimNotifyEventType;
	clone() : BranchingPointMarker;
	static C(Other: UObject | any): BranchingPointMarker;
}

declare class TimeStretchCurveMarker { 
	Time: number;
	Alpha: number;
	clone() : TimeStretchCurveMarker;
	static C(Other: UObject | any): TimeStretchCurveMarker;
}

declare class TimeStretchCurve { 
	SamplingRate: number;
	CurveValueMinPrecision: number;
	Markers: TimeStretchCurveMarker[];
	Sum_dT_i_by_C_i: number;
	clone() : TimeStretchCurve;
	static C(Other: UObject | any): TimeStretchCurve;
}

declare class AnimMontage extends AnimCompositeBase { 
	BlendIn: AlphaBlend;
	BlendInTime: number;
	BlendOut: AlphaBlend;
	BlendOutTime: number;
	BlendOutTriggerTime: number;
	SyncGroup: string;
	SyncSlotIndex: number;
	MarkerData: MarkerSyncData;
	CompositeSections: CompositeSection[];
	SlotAnimTracks: SlotAnimationTrack[];
	BranchingPoints: BranchingPoint[];
	bEnableRootMotionTranslation: boolean;
	bEnableRootMotionRotation: boolean;
	RootMotionRootLock: ERootMotionRootLock;
	PreviewBasePose: AnimSequence;
	BranchingPointMarkers: BranchingPointMarker[];
	BranchingPointStateNotifyIndices: number[];
	TimeStretchCurve: TimeStretchCurve;
	TimeStretchCurveName: string;
	static Load(ResourceName: string): AnimMontage;
	static Find(Outer: UObject, ResourceName: string): AnimMontage;
	static GetDefaultObject(): AnimMontage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMontage;
	static C(Other: UObject | any): AnimMontage;
}

declare type EAnimLinkMethod = 'Absolute' | 'Relative' | 'Proportional';
declare var EAnimLinkMethod : { Absolute:'Absolute',Relative:'Relative',Proportional:'Proportional', };
declare class AnimLinkableElement { 
	LinkedMontage: AnimMontage;
	SlotIndex: number;
	SegmentIndex: number;
	LinkMethod: EAnimLinkMethod;
	CachedLinkMethod: EAnimLinkMethod;
	SegmentBeginTime: number;
	SegmentLength: number;
	LinkValue: number;
	LinkedSequence: AnimSequenceBase;
	clone() : AnimLinkableElement;
	static C(Other: UObject | any): AnimLinkableElement;
}

declare class AnimNotify extends UObject { 
	NotifyColor: Color;
	static Load(ResourceName: string): AnimNotify;
	static Find(Outer: UObject, ResourceName: string): AnimNotify;
	static GetDefaultObject(): AnimNotify;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify;
	Received_Notify(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): boolean;
	GetNotifyName(): string;
	static C(Other: UObject | any): AnimNotify;
}

declare class AnimNotifyState extends UObject { 
	NotifyColor: Color;
	static Load(ResourceName: string): AnimNotifyState;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyState;
	static GetDefaultObject(): AnimNotifyState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState;
	Received_NotifyTick(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,FrameDeltaTime: number): boolean;
	Received_NotifyEnd(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): boolean;
	Received_NotifyBegin(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,TotalDuration: number): boolean;
	GetNotifyName(): string;
	static C(Other: UObject | any): AnimNotifyState;
}

declare type EMontageNotifyTickType = 'Queued' | 'BranchingPoint';
declare var EMontageNotifyTickType : { Queued:'Queued',BranchingPoint:'BranchingPoint', };
declare type ENotifyFilterType = 'NoFiltering' | 'LOD';
declare var ENotifyFilterType : { NoFiltering:'NoFiltering',LOD:'LOD', };
declare class AnimNotifyEvent extends AnimLinkableElement { 
	DisplayTime: number;
	TriggerTimeOffset: number;
	EndTriggerTimeOffset: number;
	TriggerWeightThreshold: number;
	NotifyName: string;
	Notify: AnimNotify;
	NotifyStateClass: AnimNotifyState;
	Duration: number;
	EndLink: AnimLinkableElement;
	bConvertedFromBranchingPoint: boolean;
	MontageTickType: EMontageNotifyTickType;
	NotifyTriggerChance: number;
	NotifyFilterType: ENotifyFilterType;
	NotifyFilterLOD: number;
	bTriggerOnDedicatedServer: boolean;
	NotifyColor: Color;
	TrackIndex: number;
	clone() : AnimNotifyEvent;
	static C(Other: UObject | any): AnimNotifyEvent;
}

declare class FloatCurve extends AnimCurveBase { 
	FloatCurve: RichCurve;
	clone() : FloatCurve;
	static C(Other: UObject | any): FloatCurve;
}

declare class VectorCurve extends AnimCurveBase { 
	FloatCurves: RichCurve;
	clone() : VectorCurve;
	static C(Other: UObject | any): VectorCurve;
}

declare class TransformCurve extends AnimCurveBase { 
	TranslationCurve: VectorCurve;
	RotationCurve: VectorCurve;
	ScaleCurve: VectorCurve;
	clone() : TransformCurve;
	static C(Other: UObject | any): TransformCurve;
}

declare class RawCurveTracks { 
	FloatCurves: FloatCurve[];
	VectorCurves: VectorCurve[];
	TransformCurves: TransformCurve[];
	clone() : RawCurveTracks;
	static C(Other: UObject | any): RawCurveTracks;
}

declare class AnimNotifyTrack { 
	TrackName: string;
	TrackColor: LinearColor;
	clone() : AnimNotifyTrack;
	static C(Other: UObject | any): AnimNotifyTrack;
}

declare class AnimSequenceBase extends AnimationAsset { 
	Notifies: AnimNotifyEvent[];
	SequenceLength: number;
	RateScale: number;
	RawCurveData: RawCurveTracks;
	AnimNotifyTracks: AnimNotifyTrack[];
	static Load(ResourceName: string): AnimSequenceBase;
	static Find(Outer: UObject, ResourceName: string): AnimSequenceBase;
	static GetDefaultObject(): AnimSequenceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceBase;
	GetPlayLength(): number;
	static C(Other: UObject | any): AnimSequenceBase;
}

declare class TrackToSkeletonMap { 
	BoneTreeIndex: number;
	clone() : TrackToSkeletonMap;
	static C(Other: UObject | any): TrackToSkeletonMap;
}

declare type AnimationCompressionFormat = 'ACF_None' | 'ACF_Float96NoW' | 'ACF_Fixed48NoW' | 'ACF_IntervalFixed32NoW' | 'ACF_Fixed32NoW' | 'ACF_Float32NoW' | 'ACF_Identity';
declare var AnimationCompressionFormat : { ACF_None:'ACF_None',ACF_Float96NoW:'ACF_Float96NoW',ACF_Fixed48NoW:'ACF_Fixed48NoW',ACF_IntervalFixed32NoW:'ACF_IntervalFixed32NoW',ACF_Fixed32NoW:'ACF_Fixed32NoW',ACF_Float32NoW:'ACF_Float32NoW',ACF_Identity:'ACF_Identity', };
declare class AnimCompress extends UObject { 
	Description: string;
	bNeedsSkeleton: boolean;
	TranslationCompressionFormat: AnimationCompressionFormat;
	RotationCompressionFormat: AnimationCompressionFormat;
	ScaleCompressionFormat: AnimationCompressionFormat;
	MaxCurveError: number;
	static Load(ResourceName: string): AnimCompress;
	static Find(Outer: UObject, ResourceName: string): AnimCompress;
	static GetDefaultObject(): AnimCompress;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress;
	static C(Other: UObject | any): AnimCompress;
}

declare type EAdditiveAnimationType = 'AAT_None' | 'AAT_LocalSpaceBase' | 'AAT_RotationOffsetMeshSpace';
declare var EAdditiveAnimationType : { AAT_None:'AAT_None',AAT_LocalSpaceBase:'AAT_LocalSpaceBase',AAT_RotationOffsetMeshSpace:'AAT_RotationOffsetMeshSpace', };
declare type EAdditiveBasePoseType = 'ABPT_None' | 'ABPT_RefPose' | 'ABPT_AnimScaled' | 'ABPT_AnimFrame';
declare var EAdditiveBasePoseType : { ABPT_None:'ABPT_None',ABPT_RefPose:'ABPT_RefPose',ABPT_AnimScaled:'ABPT_AnimScaled',ABPT_AnimFrame:'ABPT_AnimFrame', };
declare type EAnimInterpolationType = 'Linear' | 'Step';
declare var EAnimInterpolationType : { Linear:'Linear',Step:'Step', };
declare type ERawCurveTrackTypes = 'RCT_Float' | 'RCT_Vector' | 'RCT_Transform';
declare var ERawCurveTrackTypes : { RCT_Float:'RCT_Float',RCT_Vector:'RCT_Vector',RCT_Transform:'RCT_Transform', };
declare class AnimSequence extends AnimSequenceBase { 
	NumFrames: number;
	TrackToSkeletonMapTable: TrackToSkeletonMap[];
	RawDataGuid: Guid;
	AnimationTrackNames: string[];
	CompressionScheme: AnimCompress;
	AdditiveAnimType: EAdditiveAnimationType;
	RefPoseType: EAdditiveBasePoseType;
	RefPoseSeq: AnimSequence;
	RefFrameIndex: number;
	EncodingPkgVersion: number;
	RetargetSource: string;
	Interpolation: Interpolation;
	bEnableRootMotion: boolean;
	RootMotionRootLock: ERootMotionRootLock;
	bForceRootLock: boolean;
	bRootMotionSettingsCopiedFromMontage: boolean;
	CompressCommandletVersion: number;
	bDoNotOverrideCompression: boolean;
	bWasCompressedWithoutTranslations: boolean;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	bNeedsRebake: boolean;
	AuthoredSyncMarkers: AnimSyncMarker[];
	static Load(ResourceName: string): AnimSequence;
	static Find(Outer: UObject, ResourceName: string): AnimSequence;
	static GetDefaultObject(): AnimSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequence;
	static C(Other: UObject | any): AnimSequence;
	AddAnimationNotifyEvent(NotifyTrackName: string,StartTime: number,Duration: number,NotifyClass: UnrealEngineClass): AnimNotify;
	AddAnimationNotifyEventObject(StartTime: number,Notify: AnimNotify,NotifyTrackName: string): void;
	AddAnimationNotifyTrack(NotifyTrackName: string,TrackColor: LinearColor): void;
	AddAnimationSyncMarker(MarkerName: string,Time: number,NotifyTrackName: string): void;
	AddCurve(CurveName: string,CurveType: CurveType,bMetaDataCurve: boolean): void;
	AddFloatCurveKey(CurveName: string,Time: number,Value: number): void;
	AddFloatCurveKeys(CurveName: string,Times: number[],Values: number[]): void;
	AddMetaData(MetaDataClass: UnrealEngineClass,MetaDataInstance: AnimMetaData): void;
	AddMetaDataObject(MetaDataObject: AnimMetaData): void;
	AddTransformationCurveKey(CurveName: string,Time: number,Transform: Transform): void;
	AddTransformationCurveKeys(CurveName: string,Times: number[],Transforms: Transform[]): void;
	AddVectorCurveKey(CurveName: string,Time: number,Vector: Vector): void;
	AddVectorCurveKeys(CurveName: string,Times: number[],Vectors: Vector[]): void;
	AddVirtualBone(SourceBoneName: string,TargetBoneName: string,VirtualBoneName?: string): {VirtualBoneName: string};
	ContainsMetaDataOfClass(MetaDataClass: UnrealEngineClass): boolean;
	DoesBoneNameExist(BoneName: string,bExists?: boolean): {bExists: boolean};
	DoesCurveExist(CurveName: string,CurveType: CurveType): boolean;
	FindBonePathToRoot(BoneName: string,BonePath?: string[]): {BonePath: string[]};
	GetAdditiveAnimationType(AdditiveAnimationType?: EAdditiveAnimationType): {AdditiveAnimationType: EAdditiveAnimationType};
	GetAdditiveBasePoseType(AdditiveBasePoseType?: EAdditiveBasePoseType): {AdditiveBasePoseType: EAdditiveBasePoseType};
	GetAnimationInterpolationType(InterpolationType?: InterpolationType): {InterpolationType: InterpolationType};
	GetAnimationNotifyEventNames(EventNames?: string[]): {EventNames: string[]};
	GetAnimationNotifyEvents(NotifyEvents?: AnimNotifyEvent[]): {NotifyEvents: AnimNotifyEvent[]};
	GetAnimationNotifyEventsForTrack(NotifyTrackName: string,Events?: AnimNotifyEvent[]): {Events: AnimNotifyEvent[]};
	GetAnimationNotifyTrackNames(TrackNames?: string[]): {TrackNames: string[]};
	GetAnimationSyncMarkers(Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	GetAnimationSyncMarkersForTrack(NotifyTrackName: string,Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	GetAnimationTrackNames(TrackNames?: string[]): {TrackNames: string[]};
	GetBonePoseForFrame(BoneName: string,Frame: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	GetBonePoseForTime(BoneName: string,Time: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	GetBonePosesForFrame(BoneNames: string[],Frame: number,bExtractRootMotion: boolean,Poses?: Transform[]): {Poses: Transform[]};
	GetBonePosesForTime(BoneNames: string[],Time: number,bExtractRootMotion: boolean,Poses?: Transform[]): {Poses: Transform[]};
	GetCompressionScheme(CompressionScheme?: AnimCompress): {CompressionScheme: AnimCompress};
	GetFloatKeys(CurveName: string,Times?: number[],Values?: number[]): {Times: number[], Values: number[]};
	GetFrameAtTime(Time: number,Frame?: number): {Frame: number};
	GetMetaData(MetaData: AnimMetaData[]): void;
	GetMetaDataOfClass(MetaDataClass: UnrealEngineClass,MetaDataOfClass: AnimMetaData[]): void;
	GetNumFrames(NumFrames?: number): {NumFrames: number};
	GetRateScale(RateScale?: number): {RateScale: number};
	GetRawTrackData(TrackName: string,PositionKeys?: Vector[],RotationKeys?: Quat[],ScalingKeys?: Vector[]): {PositionKeys: Vector[], RotationKeys: Quat[], ScalingKeys: Vector[]};
	GetRawTrackPositionData(TrackName: string,PositionData?: Vector[]): {PositionData: Vector[]};
	GetRawTrackRotationData(TrackName: string,RotationData?: Quat[]): {RotationData: Quat[]};
	GetRawTrackScaleData(TrackName: string,ScaleData?: Vector[]): {ScaleData: Vector[]};
	GetRootMotionLockType(LockType?: ERootMotionRootLock): {LockType: ERootMotionRootLock};
	GetSequenceLength(Length?: number): {Length: number};
	GetTimeAtFrame(Frame: number,Time?: number): {Time: number};
	GetTransformationKeys(CurveName: string,Times?: number[],Values?: Transform[]): {Times: number[], Values: Transform[]};
	GetUniqueMarkerNames(MarkerNames?: string[]): {MarkerNames: string[]};
	GetVectorKeys(CurveName: string,Times?: number[],Values?: Vector[]): {Times: number[], Values: Vector[]};
	IsRootMotionEnabled(): boolean;
	IsRootMotionLockForced(): boolean;
	IsValidAnimationSyncMarkerName(MarkerName: string): boolean;
	IsValidAnimNotifyTrackName(NotifyTrackName: string): boolean;
	IsValidRawAnimationTrackName(TrackName: string): boolean;
	IsValidTime(Time: number,IsValid?: boolean): {IsValid: boolean};
	RemoveAllAnimationNotifyTracks(): void;
	RemoveAllAnimationSyncMarkers(): void;
	RemoveAllCurveData(): void;
	RemoveAllMetaData(): void;
	RemoveAllVirtualBones(): void;
	RemoveAnimationNotifyEventsByName(NotifyName: string): number;
	RemoveAnimationNotifyEventsByTrack(NotifyTrackName: string): number;
	RemoveAnimationNotifyTrack(NotifyTrackName: string): void;
	RemoveAnimationSyncMarkersByName(MarkerName: string): number;
	RemoveAnimationSyncMarkersByTrack(NotifyTrackName: string): number;
	RemoveCurve(CurveName: string,bRemoveNameFromSkeleton: boolean): void;
	RemoveMetaData(MetaDataObject: AnimMetaData): void;
	RemoveMetaDataOfClass(MetaDataClass: UnrealEngineClass): void;
	RemoveVirtualBone(VirtualBoneName: string): void;
	RemoveVirtualBones(VirtualBoneNames: string[]): void;
	SetAdditiveAnimationType(AdditiveAnimationType: EAdditiveAnimationType): void;
	SetAdditiveBasePoseType(AdditiveBasePoseType: EAdditiveBasePoseType): void;
	SetAnimationInterpolationType(InterpolationType: InterpolationType): void;
	SetCompressionScheme(CompressionScheme: AnimCompress): void;
	SetIsRootMotionLockForced(bForced: boolean): void;
	SetRateScale(RateScale: number): void;
	SetRootMotionEnabled(bEnabled: boolean): void;
	SetRootMotionLockType(RootMotionLockType: ERootMotionRootLock): void;
	static AddAnimationNotifyEvent(AnimationSequence: AnimSequence,NotifyTrackName: string,StartTime: number,Duration: number,NotifyClass: UnrealEngineClass): AnimNotify;
	static AddAnimationNotifyEventObject(AnimationSequence: AnimSequence,StartTime: number,Notify: AnimNotify,NotifyTrackName: string): void;
	static AddAnimationNotifyTrack(AnimationSequence: AnimSequence,NotifyTrackName: string,TrackColor: LinearColor): void;
	static AddAnimationSyncMarker(AnimationSequence: AnimSequence,MarkerName: string,Time: number,NotifyTrackName: string): void;
	static AddCurve(AnimationSequence: AnimSequence,CurveName: string,CurveType: CurveType,bMetaDataCurve: boolean): void;
	static AddFloatCurveKey(AnimationSequence: AnimSequence,CurveName: string,Time: number,Value: number): void;
	static AddFloatCurveKeys(AnimationSequence: AnimSequence,CurveName: string,Times: number[],Values: number[]): void;
	static AddMetaData(AnimationSequence: AnimSequence,MetaDataClass: UnrealEngineClass,MetaDataInstance: AnimMetaData): void;
	static AddMetaDataObject(AnimationSequence: AnimSequence,MetaDataObject: AnimMetaData): void;
	static AddTransformationCurveKey(AnimationSequence: AnimSequence,CurveName: string,Time: number,Transform: Transform): void;
	static AddTransformationCurveKeys(AnimationSequence: AnimSequence,CurveName: string,Times: number[],Transforms: Transform[]): void;
	static AddVectorCurveKey(AnimationSequence: AnimSequence,CurveName: string,Time: number,Vector: Vector): void;
	static AddVectorCurveKeys(AnimationSequence: AnimSequence,CurveName: string,Times: number[],Vectors: Vector[]): void;
	static AddVirtualBone(AnimationSequence: AnimSequence,SourceBoneName: string,TargetBoneName: string,VirtualBoneName?: string): {VirtualBoneName: string};
	static ContainsMetaDataOfClass(AnimationSequence: AnimSequence,MetaDataClass: UnrealEngineClass): boolean;
	static DoesBoneNameExist(AnimationSequence: AnimSequence,BoneName: string,bExists?: boolean): {bExists: boolean};
	static DoesCurveExist(AnimationSequence: AnimSequence,CurveName: string,CurveType: CurveType): boolean;
	static FindBonePathToRoot(AnimationSequence: AnimSequence,BoneName: string,BonePath?: string[]): {BonePath: string[]};
	static GetAdditiveAnimationType(AnimationSequence: AnimSequence,AdditiveAnimationType?: EAdditiveAnimationType): {AdditiveAnimationType: EAdditiveAnimationType};
	static GetAdditiveBasePoseType(AnimationSequence: AnimSequence,AdditiveBasePoseType?: EAdditiveBasePoseType): {AdditiveBasePoseType: EAdditiveBasePoseType};
	static GetAnimationInterpolationType(AnimationSequence: AnimSequence,InterpolationType?: InterpolationType): {InterpolationType: InterpolationType};
	static GetAnimationNotifyEventNames(AnimationSequence: AnimSequence,EventNames?: string[]): {EventNames: string[]};
	static GetAnimationNotifyEvents(AnimationSequence: AnimSequence,NotifyEvents?: AnimNotifyEvent[]): {NotifyEvents: AnimNotifyEvent[]};
	static GetAnimationNotifyEventsForTrack(AnimationSequence: AnimSequence,NotifyTrackName: string,Events?: AnimNotifyEvent[]): {Events: AnimNotifyEvent[]};
	static GetAnimationNotifyTrackNames(AnimationSequence: AnimSequence,TrackNames?: string[]): {TrackNames: string[]};
	static GetAnimationSyncMarkers(AnimationSequence: AnimSequence,Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	static GetAnimationSyncMarkersForTrack(AnimationSequence: AnimSequence,NotifyTrackName: string,Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	static GetAnimationTrackNames(AnimationSequence: AnimSequence,TrackNames?: string[]): {TrackNames: string[]};
	static GetBonePoseForFrame(AnimationSequence: AnimSequence,BoneName: string,Frame: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	static GetBonePoseForTime(AnimationSequence: AnimSequence,BoneName: string,Time: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	static GetBonePosesForFrame(AnimationSequence: AnimSequence,BoneNames: string[],Frame: number,bExtractRootMotion: boolean,Poses?: Transform[]): {Poses: Transform[]};
	static GetBonePosesForTime(AnimationSequence: AnimSequence,BoneNames: string[],Time: number,bExtractRootMotion: boolean,Poses?: Transform[]): {Poses: Transform[]};
	static GetCompressionScheme(AnimationSequence: AnimSequence,CompressionScheme?: AnimCompress): {CompressionScheme: AnimCompress};
	static GetFloatKeys(AnimationSequence: AnimSequence,CurveName: string,Times?: number[],Values?: number[]): {Times: number[], Values: number[]};
	static GetFrameAtTime(AnimationSequence: AnimSequence,Time: number,Frame?: number): {Frame: number};
	static GetMetaData(AnimationSequence: AnimSequence,MetaData: AnimMetaData[]): void;
	static GetMetaDataOfClass(AnimationSequence: AnimSequence,MetaDataClass: UnrealEngineClass,MetaDataOfClass: AnimMetaData[]): void;
	static GetNumFrames(AnimationSequence: AnimSequence,NumFrames?: number): {NumFrames: number};
	static GetRateScale(AnimationSequence: AnimSequence,RateScale?: number): {RateScale: number};
	static GetRawTrackData(AnimationSequence: AnimSequence,TrackName: string,PositionKeys?: Vector[],RotationKeys?: Quat[],ScalingKeys?: Vector[]): {PositionKeys: Vector[], RotationKeys: Quat[], ScalingKeys: Vector[]};
	static GetRawTrackPositionData(AnimationSequence: AnimSequence,TrackName: string,PositionData?: Vector[]): {PositionData: Vector[]};
	static GetRawTrackRotationData(AnimationSequence: AnimSequence,TrackName: string,RotationData?: Quat[]): {RotationData: Quat[]};
	static GetRawTrackScaleData(AnimationSequence: AnimSequence,TrackName: string,ScaleData?: Vector[]): {ScaleData: Vector[]};
	static GetRootMotionLockType(AnimationSequence: AnimSequence,LockType?: ERootMotionRootLock): {LockType: ERootMotionRootLock};
	static GetSequenceLength(AnimationSequence: AnimSequence,Length?: number): {Length: number};
	static GetTimeAtFrame(AnimationSequence: AnimSequence,Frame: number,Time?: number): {Time: number};
	static GetTransformationKeys(AnimationSequence: AnimSequence,CurveName: string,Times?: number[],Values?: Transform[]): {Times: number[], Values: Transform[]};
	static GetUniqueMarkerNames(AnimationSequence: AnimSequence,MarkerNames?: string[]): {MarkerNames: string[]};
	static GetVectorKeys(AnimationSequence: AnimSequence,CurveName: string,Times?: number[],Values?: Vector[]): {Times: number[], Values: Vector[]};
	static IsRootMotionEnabled(AnimationSequence: AnimSequence): boolean;
	static IsRootMotionLockForced(AnimationSequence: AnimSequence): boolean;
	static IsValidAnimationSyncMarkerName(AnimationSequence: AnimSequence,MarkerName: string): boolean;
	static IsValidAnimNotifyTrackName(AnimationSequence: AnimSequence,NotifyTrackName: string): boolean;
	static IsValidRawAnimationTrackName(AnimationSequence: AnimSequence,TrackName: string): boolean;
	static IsValidTime(AnimationSequence: AnimSequence,Time: number,IsValid?: boolean): {IsValid: boolean};
	static RemoveAllAnimationNotifyTracks(AnimationSequence: AnimSequence): void;
	static RemoveAllAnimationSyncMarkers(AnimationSequence: AnimSequence): void;
	static RemoveAllCurveData(AnimationSequence: AnimSequence): void;
	static RemoveAllMetaData(AnimationSequence: AnimSequence): void;
	static RemoveAllVirtualBones(AnimationSequence: AnimSequence): void;
	static RemoveAnimationNotifyEventsByName(AnimationSequence: AnimSequence,NotifyName: string): number;
	static RemoveAnimationNotifyEventsByTrack(AnimationSequence: AnimSequence,NotifyTrackName: string): number;
	static RemoveAnimationNotifyTrack(AnimationSequence: AnimSequence,NotifyTrackName: string): void;
	static RemoveAnimationSyncMarkersByName(AnimationSequence: AnimSequence,MarkerName: string): number;
	static RemoveAnimationSyncMarkersByTrack(AnimationSequence: AnimSequence,NotifyTrackName: string): number;
	static RemoveCurve(AnimationSequence: AnimSequence,CurveName: string,bRemoveNameFromSkeleton: boolean): void;
	static RemoveMetaData(AnimationSequence: AnimSequence,MetaDataObject: AnimMetaData): void;
	static RemoveMetaDataOfClass(AnimationSequence: AnimSequence,MetaDataClass: UnrealEngineClass): void;
	static RemoveVirtualBone(AnimationSequence: AnimSequence,VirtualBoneName: string): void;
	static RemoveVirtualBones(AnimationSequence: AnimSequence,VirtualBoneNames: string[]): void;
	static SetAdditiveAnimationType(AnimationSequence: AnimSequence,AdditiveAnimationType: EAdditiveAnimationType): void;
	static SetAdditiveBasePoseType(AnimationSequence: AnimSequence,AdditiveBasePoseType: EAdditiveBasePoseType): void;
	static SetAnimationInterpolationType(AnimationSequence: AnimSequence,InterpolationType: InterpolationType): void;
	static SetCompressionScheme(AnimationSequence: AnimSequence,CompressionScheme: AnimCompress): void;
	static SetIsRootMotionLockForced(AnimationSequence: AnimSequence,bForced: boolean): void;
	static SetRateScale(AnimationSequence: AnimSequence,RateScale: number): void;
	static SetRootMotionEnabled(AnimationSequence: AnimSequence,bEnabled: boolean): void;
	static SetRootMotionLockType(AnimationSequence: AnimSequence,RootMotionLockType: ERootMotionRootLock): void;
}

declare class SkeletalMeshOptimizationSettings { 
	ReductionMethod: SkeletalMeshOptimizationType;
	NumOfTrianglesPercentage: number;
	MaxDeviationPercentage: number;
	WeldingThreshold: number;
	bRecalcNormals: boolean;
	NormalsThreshold: number;
	SilhouetteImportance: SkeletalMeshOptimizationImportance;
	TextureImportance: SkeletalMeshOptimizationImportance;
	ShadingImportance: SkeletalMeshOptimizationImportance;
	SkinningImportance: SkeletalMeshOptimizationImportance;
	BoneReductionRatio: number;
	MaxBonesPerVertex: number;
	BonesToRemove: BoneReference[];
	BaseLOD: number;
	BakePose: AnimSequence;
	clone() : SkeletalMeshOptimizationSettings;
	static C(Other: UObject | any): SkeletalMeshOptimizationSettings;
}

declare class SkeletalMeshLODInfo { 
	ScreenSize: number;
	LODHysteresis: number;
	LODMaterialMap: number[];
	bEnableShadowCasting: boolean[];
	TriangleSortSettings: TriangleSortSettings[];
	bHasBeenSimplified: boolean;
	ReductionSettings: SkeletalMeshOptimizationSettings;
	RemovedBones: string[];
	BonesToRemove: BoneReference[];
	BakePose: AnimSequence;
	SourceImportFilename: string;
	bHasPerLODVertexColors: boolean;
	clone() : SkeletalMeshLODInfo;
	static C(Other: UObject | any): SkeletalMeshLODInfo;
}

declare class KShapeElem { 
	clone() : KShapeElem;
	static C(Other: UObject | any): KShapeElem;
}

declare class Matrix { 
	XPlane: Plane;
	YPlane: Plane;
	ZPlane: Plane;
	WPlane: Plane;
	clone() : Matrix;
	static C(Other: UObject | any): Matrix;
}

declare class KSphereElem extends KShapeElem { 
	TM: Matrix;
	Center: Vector;
	Radius: number;
	clone() : KSphereElem;
	static C(Other: UObject | any): KSphereElem;
}

declare class KBoxElem extends KShapeElem { 
	TM: Matrix;
	Orientation: Quat;
	Center: Vector;
	Rotation: Rotator;
	X: number;
	Y: number;
	Z: number;
	clone() : KBoxElem;
	static C(Other: UObject | any): KBoxElem;
}

declare class KSphylElem extends KShapeElem { 
	TM: Matrix;
	Orientation: Quat;
	Center: Vector;
	Rotation: Rotator;
	Radius: number;
	Length: number;
	clone() : KSphylElem;
	static C(Other: UObject | any): KSphylElem;
}

declare class KConvexElem extends KShapeElem { 
	VertexData: Vector[];
	ElemBox: Box;
	Transform: Transform;
	clone() : KConvexElem;
	static C(Other: UObject | any): KConvexElem;
}

declare class KAggregateGeom { 
	SphereElems: KSphereElem[];
	BoxElems: KBoxElem[];
	SphylElems: KSphylElem[];
	ConvexElems: KConvexElem[];
	clone() : KAggregateGeom;
	static C(Other: UObject | any): KAggregateGeom;
}

declare type EPhysicsType = 'PhysType_Default' | 'PhysType_Kinematic' | 'PhysType_Simulated';
declare var EPhysicsType : { PhysType_Default:'PhysType_Default',PhysType_Kinematic:'PhysType_Kinematic',PhysType_Simulated:'PhysType_Simulated', };
declare type EBodyCollisionResponse = 'BodyCollision_Enabled' | 'BodyCollision_Disabled';
declare var EBodyCollisionResponse : { BodyCollision_Enabled:'BodyCollision_Enabled',BodyCollision_Disabled:'BodyCollision_Disabled', };
declare type ECollisionTraceFlag = 'CTF_UseDefault' | 'CTF_UseSimpleAndComplex' | 'CTF_UseSimpleAsComplex' | 'CTF_UseComplexAsSimple';
declare var ECollisionTraceFlag : { CTF_UseDefault:'CTF_UseDefault',CTF_UseSimpleAndComplex:'CTF_UseSimpleAndComplex',CTF_UseSimpleAsComplex:'CTF_UseSimpleAsComplex',CTF_UseComplexAsSimple:'CTF_UseComplexAsSimple', };
declare class BodySetup extends UObject { 
	AggGeom: KAggregateGeom;
	BoneName: string;
	PhysicsType: EPhysicsType;
	bAlwaysFullAnimWeight: boolean;
	bConsiderForBounds: boolean;
	bMeshCollideAll: boolean;
	bDoubleSidedGeometry: boolean;
	bGenerateNonMirroredCollision: boolean;
	bSharedCookedData: boolean;
	bGenerateMirroredCollision: boolean;
	PhysMaterial: PhysicalMaterial;
	CollisionReponse: EBodyCollisionResponse;
	CollisionTraceFlag: ECollisionTraceFlag;
	DefaultInstance: BodyInstance;
	WalkableSlopeOverride: WalkableSlopeOverride;
	BuildScale: number;
	BuildScale3D: Vector;
	static Load(ResourceName: string): BodySetup;
	static Find(Outer: UObject, ResourceName: string): BodySetup;
	static GetDefaultObject(): BodySetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BodySetup;
	static C(Other: UObject | any): BodySetup;
}

declare class PhysicalAnimationData { 
	BodyName: string;
	bIsLocalSimulation: boolean;
	OrientationStrength: number;
	AngularVelocityStrength: number;
	PositionStrength: number;
	VelocityStrength: number;
	MaxLinearForce: number;
	MaxAngularForce: number;
	clone() : PhysicalAnimationData;
	static C(Other: UObject | any): PhysicalAnimationData;
}

declare class PhysicalAnimationProfile { 
	ProfileName: string;
	PhysicalAnimationData: PhysicalAnimationData;
	clone() : PhysicalAnimationProfile;
	static C(Other: UObject | any): PhysicalAnimationProfile;
}

declare class SkeletalBodySetup extends BodySetup { 
	CurrentPhysicalAnimationProfile: PhysicalAnimationProfile;
	PhysicalAnimationData: PhysicalAnimationProfile[];
	static Load(ResourceName: string): SkeletalBodySetup;
	static Find(Outer: UObject, ResourceName: string): SkeletalBodySetup;
	static GetDefaultObject(): SkeletalBodySetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalBodySetup;
	static C(Other: UObject | any): SkeletalBodySetup;
}

declare class ConstraintBaseParams { 
	Stiffness: number;
	Damping: number;
	Restitution: number;
	ContactDistance: number;
	bSoftConstraint: boolean;
	clone() : ConstraintBaseParams;
	static C(Other: UObject | any): ConstraintBaseParams;
}

declare type ELinearConstraintMotion = 'LCM_Free' | 'LCM_Limited' | 'LCM_Locked';
declare var ELinearConstraintMotion : { LCM_Free:'LCM_Free',LCM_Limited:'LCM_Limited',LCM_Locked:'LCM_Locked', };
declare class LinearConstraint extends ConstraintBaseParams { 
	Limit: number;
	XMotion: ELinearConstraintMotion;
	YMotion: ELinearConstraintMotion;
	ZMotion: ELinearConstraintMotion;
	clone() : LinearConstraint;
	static C(Other: UObject | any): LinearConstraint;
}

declare type EAngularConstraintMotion = 'ACM_Free' | 'ACM_Limited' | 'ACM_Locked';
declare var EAngularConstraintMotion : { ACM_Free:'ACM_Free',ACM_Limited:'ACM_Limited',ACM_Locked:'ACM_Locked', };
declare class ConeConstraint extends ConstraintBaseParams { 
	Swing1LimitDegrees: number;
	Swing2LimitDegrees: number;
	Swing1Motion: EAngularConstraintMotion;
	Swing2Motion: EAngularConstraintMotion;
	clone() : ConeConstraint;
	static C(Other: UObject | any): ConeConstraint;
}

declare class TwistConstraint extends ConstraintBaseParams { 
	TwistLimitDegrees: number;
	TwistMotion: EAngularConstraintMotion;
	clone() : TwistConstraint;
	static C(Other: UObject | any): TwistConstraint;
}

declare class ConstraintDrive { 
	Stiffness: number;
	Damping: number;
	MaxForce: number;
	bEnablePositionDrive: boolean;
	bEnableVelocityDrive: boolean;
	clone() : ConstraintDrive;
	static C(Other: UObject | any): ConstraintDrive;
}

declare class LinearDriveConstraint { 
	PositionTarget: Vector;
	VelocityTarget: Vector;
	XDrive: ConstraintDrive;
	YDrive: ConstraintDrive;
	ZDrive: ConstraintDrive;
	bEnablePositionDrive: boolean;
	clone() : LinearDriveConstraint;
	static C(Other: UObject | any): LinearDriveConstraint;
}

declare type EAngularDriveMode = 'SLERP' | 'TwistAndSwing';
declare var EAngularDriveMode : { SLERP:'SLERP',TwistAndSwing:'TwistAndSwing', };
declare class AngularDriveConstraint { 
	TwistDrive: ConstraintDrive;
	SwingDrive: ConstraintDrive;
	SlerpDrive: ConstraintDrive;
	OrientationTarget: Rotator;
	AngularVelocityTarget: Vector;
	AngularDriveMode: EAngularDriveMode;
	clone() : AngularDriveConstraint;
	static C(Other: UObject | any): AngularDriveConstraint;
}

declare class ConstraintProfileProperties { 
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearBreakThreshold: number;
	AngularBreakThreshold: number;
	LinearLimit: LinearConstraint;
	ConeLimit: ConeConstraint;
	TwistLimit: TwistConstraint;
	LinearDrive: LinearDriveConstraint;
	AngularDrive: AngularDriveConstraint;
	bDisableCollision: boolean;
	bParentDominates: boolean;
	bEnableProjection: boolean;
	bAngularBreakable: boolean;
	bLinearBreakable: boolean;
	clone() : ConstraintProfileProperties;
	static C(Other: UObject | any): ConstraintProfileProperties;
}

declare class ConstraintInstance { 
	JointName: string;
	ConstraintBone1: string;
	ConstraintBone2: string;
	Pos1: Vector;
	PriAxis1: Vector;
	SecAxis1: Vector;
	Pos2: Vector;
	PriAxis2: Vector;
	SecAxis2: Vector;
	AngularRotationOffset: Rotator;
	bScaleLinearLimits: boolean;
	ProfileInstance: ConstraintProfileProperties;
	bDisableCollision: boolean;
	bEnableProjection: boolean;
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearXMotion: ELinearConstraintMotion;
	LinearYMotion: ELinearConstraintMotion;
	LinearZMotion: ELinearConstraintMotion;
	LinearLimitSize: number;
	bLinearLimitSoft: boolean;
	LinearLimitStiffness: number;
	LinearLimitDamping: number;
	bLinearBreakable: boolean;
	LinearBreakThreshold: number;
	AngularSwing1Motion: EAngularConstraintMotion;
	AngularTwistMotion: EAngularConstraintMotion;
	AngularSwing2Motion: EAngularConstraintMotion;
	bSwingLimitSoft: boolean;
	bTwistLimitSoft: boolean;
	Swing1LimitAngle: number;
	TwistLimitAngle: number;
	Swing2LimitAngle: number;
	SwingLimitStiffness: number;
	SwingLimitDamping: number;
	TwistLimitStiffness: number;
	TwistLimitDamping: number;
	bAngularBreakable: boolean;
	AngularBreakThreshold: number;
	bLinearXPositionDrive: boolean;
	bLinearXVelocityDrive: boolean;
	bLinearYPositionDrive: boolean;
	bLinearYVelocityDrive: boolean;
	bLinearZPositionDrive: boolean;
	bLinearZVelocityDrive: boolean;
	bLinearPositionDrive: boolean;
	bLinearVelocityDrive: boolean;
	LinearPositionTarget: Vector;
	LinearVelocityTarget: Vector;
	LinearDriveSpring: number;
	LinearDriveDamping: number;
	LinearDriveForceLimit: number;
	bSwingPositionDrive: boolean;
	bSwingVelocityDrive: boolean;
	bTwistPositionDrive: boolean;
	bTwistVelocityDrive: boolean;
	bAngularSlerpDrive: boolean;
	bAngularOrientationDrive: boolean;
	bEnableSwingDrive: boolean;
	bEnableTwistDrive: boolean;
	bAngularVelocityDrive: boolean;
	AngularPositionTarget: Quat;
	AngularDriveMode: EAngularDriveMode;
	AngularOrientationTarget: Rotator;
	AngularVelocityTarget: Vector;
	AngularDriveSpring: number;
	AngularDriveDamping: number;
	AngularDriveForceLimit: number;
	clone() : ConstraintInstance;
	static C(Other: UObject | any): ConstraintInstance;
}

declare class PhysicsConstraintProfileHandle { 
	ProfileProperties: ConstraintProfileProperties;
	ProfileName: string;
	clone() : PhysicsConstraintProfileHandle;
	static C(Other: UObject | any): PhysicsConstraintProfileHandle;
}

declare class PhysicsConstraintTemplate extends UObject { 
	DefaultInstance: ConstraintInstance;
	ProfileHandles: PhysicsConstraintProfileHandle[];
	DefaultProfile: ConstraintProfileProperties;
	JointName: string;
	ConstraintBone1: string;
	ConstraintBone2: string;
	Pos1: Vector;
	PriAxis1: Vector;
	SecAxis1: Vector;
	Pos2: Vector;
	PriAxis2: Vector;
	SecAxis2: Vector;
	bEnableProjection: boolean;
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearXMotion: ELinearConstraintMotion;
	LinearYMotion: ELinearConstraintMotion;
	LinearZMotion: ELinearConstraintMotion;
	LinearLimitSize: number;
	bLinearLimitSoft: boolean;
	LinearLimitStiffness: number;
	LinearLimitDamping: number;
	bLinearBreakable: boolean;
	LinearBreakThreshold: number;
	AngularSwing1Motion: EAngularConstraintMotion;
	AngularSwing2Motion: EAngularConstraintMotion;
	AngularTwistMotion: EAngularConstraintMotion;
	bSwingLimitSoft: boolean;
	bTwistLimitSoft: boolean;
	Swing1LimitAngle: number;
	Swing2LimitAngle: number;
	TwistLimitAngle: number;
	SwingLimitStiffness: number;
	SwingLimitDamping: number;
	TwistLimitStiffness: number;
	TwistLimitDamping: number;
	bAngularBreakable: boolean;
	AngularBreakThreshold: number;
	static Load(ResourceName: string): PhysicsConstraintTemplate;
	static Find(Outer: UObject, ResourceName: string): PhysicsConstraintTemplate;
	static GetDefaultObject(): PhysicsConstraintTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintTemplate;
	static C(Other: UObject | any): PhysicsConstraintTemplate;
}

declare class PhysicsAsset extends UObject { 
	DefaultSkelMesh: SkeletalMesh;
	PreviewSkeletalMesh: any;
	PhysicalAnimationProfiles: string[];
	ConstraintProfiles: string[];
	CurrentPhysicalAnimationProfileName: string;
	CurrentConstraintProfileName: string;
	BoundsBodies: number[];
	SkeletalBodySetups: SkeletalBodySetup[];
	ConstraintSetup: PhysicsConstraintTemplate[];
	bUseAsyncScene: boolean;
	ThumbnailInfo: ThumbnailInfo;
	BodySetup: BodySetup[];
	static Load(ResourceName: string): PhysicsAsset;
	static Find(Outer: UObject, ResourceName: string): PhysicsAsset;
	static GetDefaultObject(): PhysicsAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsAsset;
	static C(Other: UObject | any): PhysicsAsset;
}

declare class NodeMappingContainer extends UObject { 
	NodeMapping: any;
	SourceAsset: any;
	static Load(ResourceName: string): NodeMappingContainer;
	static Find(Outer: UObject, ResourceName: string): NodeMappingContainer;
	static GetDefaultObject(): NodeMappingContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeMappingContainer;
	static C(Other: UObject | any): NodeMappingContainer;
}

declare class MorphTarget extends UObject { 
	BaseSkelMesh: SkeletalMesh;
	static Load(ResourceName: string): MorphTarget;
	static Find(Outer: UObject, ResourceName: string): MorphTarget;
	static GetDefaultObject(): MorphTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MorphTarget;
	static C(Other: UObject | any): MorphTarget;
}

declare class ClothPhysicsProperties_Legacy { 
	VerticalResistance: number;
	HorizontalResistance: number;
	BendResistance: number;
	ShearResistance: number;
	Friction: number;
	Damping: number;
	TetherStiffness: number;
	TetherLimit: number;
	Drag: number;
	StiffnessFrequency: number;
	GravityScale: number;
	MassScale: number;
	InertiaBlend: number;
	SelfCollisionThickness: number;
	SelfCollisionSquashScale: number;
	SelfCollisionStiffness: number;
	SolverFrequency: number;
	FiberCompression: number;
	FiberExpansion: number;
	FiberResistance: number;
	clone() : ClothPhysicsProperties_Legacy;
	static C(Other: UObject | any): ClothPhysicsProperties_Legacy;
}

declare class ClothingAssetData_Legacy { 
	AssetName: string;
	ApexFileName: string;
	bClothPropertiesChanged: boolean;
	PhysicsProperties: ClothPhysicsProperties_Legacy;
	clone() : ClothingAssetData_Legacy;
	static C(Other: UObject | any): ClothingAssetData_Legacy;
}

declare type ERootMotionMode = 'NoRootMotionExtraction' | 'IgnoreRootMotion' | 'RootMotionFromEverything' | 'RootMotionFromMontagesOnly';
declare var ERootMotionMode : { NoRootMotionExtraction:'NoRootMotionExtraction',IgnoreRootMotion:'IgnoreRootMotion',RootMotionFromEverything:'RootMotionFromEverything',RootMotionFromMontagesOnly:'RootMotionFromMontagesOnly', };
declare class SoftClassPath extends SoftObjectPath { 
	clone() : SoftClassPath;
	static C(Other: UObject | any): SoftClassPath;
}

declare class PoseSnapshot { 
	LocalTransforms: Transform[];
	BoneNames: string[];
	SkeletalMeshName: string;
	SnapshotName: string;
	bIsValid: boolean;
	clone() : PoseSnapshot;
	static C(Other: UObject | any): PoseSnapshot;
}

declare type EMontagePlayReturnType = 'MontageLength' | 'Duration';
declare var EMontagePlayReturnType : { MontageLength:'MontageLength',Duration:'Duration', };
declare class MarkerSyncAnimPosition { 
	PreviousMarkerName: string;
	NextMarkerName: string;
	PositionBetweenMarkers: number;
	clone() : MarkerSyncAnimPosition;
	static C(Other: UObject | any): MarkerSyncAnimPosition;
}

declare class AnimInstance extends UObject { 
	DeltaTime: number;
	CurrentSkeleton: Skeleton;
	RootMotionMode: ERootMotionMode;
	bRunUpdatesInWorkerThreads: boolean;
	bCanUseParallelUpdateAnimation: boolean;
	bUseMultiThreadedAnimationUpdate: boolean;
	bWarnAboutBlueprintUsage: boolean;
	OnMontageBlendingOut: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	OnMontageStarted: UnrealEngineMulticastDelegate<(Montage: AnimMontage) => void>;
	OnMontageEnded: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	OnAllMontageInstancesEnded: UnrealEngineMulticastDelegate<() => void>;
	bQueueMontageEvents: boolean;
	PostCompileValidationClassName: SoftClassPath;
	ActiveAnimNotifyState: AnimNotifyEvent[];
	static Load(ResourceName: string): AnimInstance;
	static Find(Outer: UObject, ResourceName: string): AnimInstance;
	static GetDefaultObject(): AnimInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimInstance;
	UnlockAIResources(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	TryGetPawnOwner(): Pawn;
	StopSlotAnimation(InBlendOutTime: number,SlotNodeName: string): void;
	SnapshotPose(Snapshot?: PoseSnapshot): {Snapshot: PoseSnapshot};
	SetRootMotionMode(Value: ERootMotionMode): void;
	SetMorphTarget(MorphTargetName: string,Value: number): void;
	SavePoseSnapshot(SnapshotName: string): void;
	PlaySlotAnimationAsDynamicMontage(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number,BlendOutTriggerTime: number,InTimeToStartMontageAt: number): AnimMontage;
	PlaySlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number): number;
	Montage_Stop(InBlendOutTime: number,Montage: AnimMontage): void;
	Montage_SetPosition(Montage: AnimMontage,NewPosition: number): void;
	Montage_SetPlayRate(Montage: AnimMontage,NewPlayRate: number): void;
	Montage_SetNextSection(SectionNameToChange: string,NextSection: string,Montage: AnimMontage): void;
	Montage_Resume(Montage: AnimMontage): void;
	Montage_Play(MontageToPlay: AnimMontage,InPlayRate: number,ReturnValueType: ReturnValueType,InTimeToStartMontageAt: number): number;
	Montage_Pause(Montage: AnimMontage): void;
	Montage_JumpToSectionsEnd(SectionName: string,Montage: AnimMontage): void;
	Montage_JumpToSection(SectionName: string,Montage: AnimMontage): void;
	Montage_IsPlaying(Montage: AnimMontage): boolean;
	Montage_IsActive(Montage: AnimMontage): boolean;
	Montage_GetPosition(Montage: AnimMontage): number;
	Montage_GetPlayRate(Montage: AnimMontage): number;
	Montage_GetIsStopped(Montage: AnimMontage): boolean;
	Montage_GetCurrentSection(Montage: AnimMontage): string;
	Montage_GetBlendTime(Montage: AnimMontage): number;
	LockAIResources(bLockMovement: boolean,LockAILogic: boolean): void;
	IsSyncGroupBetweenMarkers(InSyncGroupName: string,PreviousMarker: string,NextMarker: string,bRespectMarkerOrder: boolean): boolean;
	IsPlayingSlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string): boolean;
	IsAnyMontagePlaying(): boolean;
	HasMarkerBeenHitThisFrame(SyncGroup: string,MarkerName: string): boolean;
	GetTimeToClosestMarker(SyncGroup: string,MarkerName: string,OutMarkerTime?: number): {OutMarkerTime: number, $: boolean};
	GetSyncGroupPosition(InSyncGroupName: string): MarkerSyncAnimPosition;
	GetRelevantAnimTimeRemainingFraction(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeRemaining(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeFraction(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTime(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimLength(MachineIndex: number,StateIndex: number): number;
	GetOwningComponent(): SkeletalMeshComponent;
	GetOwningActor(): Actor;
	GetInstanceTransitionTimeElapsedFraction(MachineIndex: number,TransitionIndex: number): number;
	GetInstanceTransitionTimeElapsed(MachineIndex: number,TransitionIndex: number): number;
	GetInstanceTransitionCrossfadeDuration(MachineIndex: number,TransitionIndex: number): number;
	GetInstanceStateWeight(MachineIndex: number,StateIndex: number): number;
	GetInstanceMachineWeight(MachineIndex: number): number;
	GetInstanceCurrentStateElapsedTime(MachineIndex: number): number;
	GetInstanceAssetPlayerTimeFromEndFraction(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerTimeFromEnd(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerTimeFraction(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerTime(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerLength(AssetPlayerIndex: number): number;
	GetCurveValue(CurveName: string): number;
	GetCurrentStateName(MachineIndex: number): string;
	GetCurrentActiveMontage(): AnimMontage;
	ClearMorphTargets(): void;
	CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	BlueprintUpdateAnimation(DeltaTimeX: number): void;
	BlueprintPostEvaluateAnimation(): void;
	BlueprintInitializeAnimation(): void;
	BlueprintBeginPlay(): void;
	static C(Other: UObject | any): AnimInstance;
	LockAIResourcesWithAnimation(bLockMovement: boolean,LockAILogic: boolean): void;
	UnlockAIResourcesWithAnimation(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
}

declare class ClothingAssetBase extends UObject { 
	ImportedFilePath: string;
	AssetGuid: Guid;
	static Load(ResourceName: string): ClothingAssetBase;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetBase;
	static GetDefaultObject(): ClothingAssetBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetBase;
	static C(Other: UObject | any): ClothingAssetBase;
}

declare class BlueprintCore extends UObject { 
	SkeletonGeneratedClass: UnrealEngineClass;
	GeneratedClass: UnrealEngineClass;
	bLegacyNeedToPurgeSkelRefs: boolean;
	bLegacyGeneratedClassIsAuthoritative: boolean;
	BlueprintGuid: Guid;
	static Load(ResourceName: string): BlueprintCore;
	static Find(Outer: UObject, ResourceName: string): BlueprintCore;
	static GetDefaultObject(): BlueprintCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintCore;
	static C(Other: UObject | any): BlueprintCore;
}

declare type EBlueprintNativizationFlag = 'Disabled' | 'Dependency' | 'ExplicitlyEnabled';
declare var EBlueprintNativizationFlag : { Disabled:'Disabled',Dependency:'Dependency',ExplicitlyEnabled:'ExplicitlyEnabled', };
declare type EBlueprintCompileMode = 'Default' | 'Development' | 'FinalRelease';
declare var EBlueprintCompileMode : { Default:'Default',Development:'Development',FinalRelease:'FinalRelease', };
declare class Struct extends Field { 
	static Load(ResourceName: string): Struct;
	static Find(Outer: UObject, ResourceName: string): Struct;
	static GetDefaultObject(): Struct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Struct;
	static C(Other: UObject | any): Struct;
}

declare class BlueprintComponentChangedPropertyInfo { 
	PropertyName: string;
	ArrayIndex: number;
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject | any): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	bIsValid: boolean;
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject | any): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject | any): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	VariableName: string;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsFalseRoot: boolean;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	InternalVariableName: string;
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static GetDefaultObject(): SCS_Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject | any): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	AllNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static GetDefaultObject(): SimpleConstructionScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject | any): SimpleConstructionScript;
}

declare class EdGraphSchema extends UObject { 
	static Load(ResourceName: string): EdGraphSchema;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema;
	static GetDefaultObject(): EdGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema;
	static C(Other: UObject | any): EdGraphSchema;
	SetNodeMetaData(UNode: EdGraphNode,KeyValue: string): boolean;
	TryConnection(A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): void;
	static SetNodeMetaData(Schema: EdGraphSchema,UNode: EdGraphNode,KeyValue: string): boolean;
	static TryConnection(Schema: EdGraphSchema,A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): void;
}

declare class EdGraph extends UObject { 
	Schema: UnrealEngineClass;
	Nodes: EdGraphNode[];
	bEditable: boolean;
	bAllowDeletion: boolean;
	bAllowRenaming: boolean;
	SubGraphs: EdGraph[];
	GraphGuid: Guid;
	InterfaceGuid: Guid;
	static Load(ResourceName: string): EdGraph;
	static Find(Outer: UObject, ResourceName: string): EdGraph;
	static GetDefaultObject(): EdGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraph;
	static C(Other: UObject | any): EdGraph;
}

declare type ETimelineLengthMode = 'TL_TimelineLength' | 'TL_LastKeyFrame';
declare var ETimelineLengthMode : { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame', };
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject | any): TTTrackBase;
}

declare class TTEventTrack extends TTTrackBase { 
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject | any): TTEventTrack;
}

declare class TTFloatTrack extends TTTrackBase { 
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject | any): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static GetDefaultObject(): CurveVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject | any): CurveVector;
}

declare class TTVectorTrack extends TTTrackBase { 
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject | any): TTVectorTrack;
}

declare class CurveLinearColor extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveLinearColor;
	static Find(Outer: UObject, ResourceName: string): CurveLinearColor;
	static GetDefaultObject(): CurveLinearColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveLinearColor;
	GetLinearColorValue(InTime: number): LinearColor;
	static C(Other: UObject | any): CurveLinearColor;
}

declare class TTLinearColorTrack extends TTTrackBase { 
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject | any): TTLinearColorTrack;
}

declare class TimelineTemplate extends UObject { 
	TimelineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bValidatedAsWired: boolean;
	bIgnoreTimeDilation: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static GetDefaultObject(): TimelineTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject | any): TimelineTemplate;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject | any): ComponentKey;
}

declare class ComponentOverrideRecord { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject | any): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	UnnecessaryComponents: ActorComponent[];
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static GetDefaultObject(): InheritableComponentHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject | any): InheritableComponentHandler;
}

declare type EBlueprintType = 'BPTYPE_Normal' | 'BPTYPE_Const' | 'BPTYPE_MacroLibrary' | 'BPTYPE_Interface' | 'BPTYPE_LevelScript' | 'BPTYPE_FunctionLibrary';
declare var EBlueprintType : { BPTYPE_Normal:'BPTYPE_Normal',BPTYPE_Const:'BPTYPE_Const',BPTYPE_MacroLibrary:'BPTYPE_MacroLibrary',BPTYPE_Interface:'BPTYPE_Interface',BPTYPE_LevelScript:'BPTYPE_LevelScript',BPTYPE_FunctionLibrary:'BPTYPE_FunctionLibrary', };
declare type EBlueprintStatus = 'BS_Unknown' | 'BS_Dirty' | 'BS_Error' | 'BS_UpToDate' | 'BS_BeingCreated' | 'BS_UpToDateWithWarnings';
declare var EBlueprintStatus : { BS_Unknown:'BS_Unknown',BS_Dirty:'BS_Dirty',BS_Error:'BS_Error',BS_UpToDate:'BS_UpToDate',BS_BeingCreated:'BS_BeingCreated',BS_UpToDateWithWarnings:'BS_UpToDateWithWarnings', };
declare type ELifetimeCondition = 'COND_None' | 'COND_InitialOnly' | 'COND_OwnerOnly' | 'COND_SkipOwner' | 'COND_SimulatedOnly' | 'COND_AutonomousOnly' | 'COND_SimulatedOrPhysics' | 'COND_InitialOrOwner' | 'COND_Custom' | 'COND_ReplayOrOwner' | 'COND_ReplayOnly' | 'COND_SimulatedOnlyNoReplay' | 'COND_SimulatedOrPhysicsNoReplay' | 'COND_SkipReplay' | 'COND_Max';
declare var ELifetimeCondition : { COND_None:'COND_None',COND_InitialOnly:'COND_InitialOnly',COND_OwnerOnly:'COND_OwnerOnly',COND_SkipOwner:'COND_SkipOwner',COND_SimulatedOnly:'COND_SimulatedOnly',COND_AutonomousOnly:'COND_AutonomousOnly',COND_SimulatedOrPhysics:'COND_SimulatedOrPhysics',COND_InitialOrOwner:'COND_InitialOrOwner',COND_Custom:'COND_Custom',COND_ReplayOrOwner:'COND_ReplayOrOwner',COND_ReplayOnly:'COND_ReplayOnly',COND_SimulatedOnlyNoReplay:'COND_SimulatedOnlyNoReplay',COND_SimulatedOrPhysicsNoReplay:'COND_SimulatedOrPhysicsNoReplay',COND_SkipReplay:'COND_SkipReplay',COND_Max:'COND_Max', };
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: any;
	RepNotifyFunc: string;
	ReplicationCondition: ELifetimeCondition;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject | any): BPVariableDescription;
}

declare class Interface extends UObject { 
	static Load(ResourceName: string): Interface;
	static Find(Outer: UObject, ResourceName: string): Interface;
	static GetDefaultObject(): Interface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface;
	static C(Other: UObject | any): Interface;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject | any): BPInterfaceDescription;
}

declare class EditedDocumentInfo { 
	EditedObject: UObject;
	SavedViewOffset: Vector2D;
	SavedZoomAmount: number;
	clone() : EditedDocumentInfo;
	static C(Other: UObject | any): EditedDocumentInfo;
}

declare class Breakpoint extends UObject { 
	bEnabled: boolean;
	UNode: EdGraphNode;
	bStepOnce: boolean;
	bStepOnce_WasPreviouslyDisabled: boolean;
	bStepOnce_RemoveAfterHit: boolean;
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static GetDefaultObject(): Breakpoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject | any): Breakpoint;
}

declare class EdGraphPinReference { 
	OwningNode: any;
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject | any): EdGraphPinReference;
}

declare class SaveGame extends UObject { 
	static Load(ResourceName: string): SaveGame;
	static Find(Outer: UObject, ResourceName: string): SaveGame;
	static GetDefaultObject(): SaveGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SaveGame;
	static C(Other: UObject | any): SaveGame;
	SaveGameToSlot(SlotName: string,UserIndex: number): boolean;
	static SaveGameToSlot(SaveGameObject: SaveGame,SlotName: string,UserIndex: number): boolean;
}

declare class Blueprint extends BlueprintCore { 
	bRecompileOnLoad: boolean;
	ParentClass: UnrealEngineClass;
	PRIVATE_InnermostPreviousCDO: UObject;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bQueuedForCompilation: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bRunConstructionScriptInSequencer: boolean;
	bGenerateConstClass: boolean;
	bGenerateAbstractClass: boolean;
	BlueprintDescription: string;
	BlueprintCategory: string;
	HideCategories: string[];
	NativizationFlag: NativizationFlag;
	bDisplayCompilePIEWarning: boolean;
	SearchGuid: Guid;
	bDeprecate: boolean;
	CompileMode: CompileMode;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	PRIVATE_CachedMacroInfo: any;
	bDuplicatingReadOnly: boolean;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	InheritableComponentHandler: InheritableComponentHandler;
	BlueprintType: EBlueprintType;
	Status: EBlueprintStatus;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImplementedInterfaces: BPInterfaceDescription[];
	BlueprintSystemVersion: number;
	LastEditedDocuments: EditedDocumentInfo[];
	Breakpoints: Breakpoint[];
	WatchedPins: EdGraphPinReference[];
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	ComponentTemplateNameIndex: any;
	OldToNewComponentTemplateNames: any;
	ThumbnailInfo: ThumbnailInfo;
	bBeingCompiled: boolean;
	CrcLastCompiledCDO: any;
	CrcLastCompiledSignature: any;
	OriginalClass: UnrealEngineClass;
	bNativize: boolean;
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static GetDefaultObject(): Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject | any): Blueprint;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	CreateSaveGameObjectFromBlueprint(): SaveGame;
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	static CreateSaveGameObjectFromBlueprint(SaveGameBlueprint: Blueprint): SaveGame;
}

declare class SkeletalMesh extends UObject { 
	Skeleton: Skeleton;
	ImportedBounds: BoxSphereBounds;
	ExtendedBounds: BoxSphereBounds;
	PositiveBoundsExtension: Vector;
	NegativeBoundsExtension: Vector;
	Materials: SkeletalMaterial[];
	SkelMirrorTable: BoneMirrorInfo[];
	SkelMirrorAxis: EAxis;
	SkelMirrorFlipAxis: EAxis;
	LODInfo: SkeletalMeshLODInfo[];
	bUseFullPrecisionUVs: boolean;
	bHasBeenSimplified: boolean;
	bHasVertexColors: boolean;
	bEnablePerPolyCollision: boolean;
	BodySetup: BodySetup;
	PhysicsAsset: PhysicsAsset;
	ShadowPhysicsAsset: PhysicsAsset;
	NodeMappingData: NodeMappingContainer[];
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	ThumbnailInfo: ThumbnailInfo;
	bHasCustomDefaultEditorCamera: boolean;
	DefaultEditorCameraLocation: Vector;
	DefaultEditorCameraRotation: Rotator;
	DefaultEditorCameraLookAt: Vector;
	DefaultEditorCameraOrthoZoom: number;
	OptimizationSettings: SkeletalMeshOptimizationSettings[];
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	MorphTargets: MorphTarget[];
	SelectedEditorSection: number;
	SelectedEditorMaterial: number;
	SelectedClothingSection: number;
	FloorOffset: number;
	RetargetBasePose: Transform[];
	ClothingAssets: ClothingAssetData_Legacy[];
	PostProcessAnimBlueprint: UnrealEngineClass;
	MeshClothingAssets: ClothingAssetBase[];
	AssetUserData: AssetUserData[];
	Sockets: SkeletalMeshSocket[];
	static Load(ResourceName: string): SkeletalMesh;
	static Find(Outer: UObject, ResourceName: string): SkeletalMesh;
	static GetDefaultObject(): SkeletalMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMesh;
	NumSockets(): number;
	IsSectionUsingCloth(InSectionIndex: number,bCheckCorrespondingSections: boolean): boolean;
	GetSocketByIndex(Index: number): SkeletalMeshSocket;
	GetNodeMappingContainer(SourceAsset: Blueprint): NodeMappingContainer;
	GetImportedBounds(): BoxSphereBounds;
	GetBounds(): BoxSphereBounds;
	FindSocketAndIndex(InSocketName: string,OutIndex?: number): {OutIndex: number, $: SkeletalMeshSocket};
	FindSocket(InSocketName: string): SkeletalMeshSocket;
	static C(Other: UObject | any): SkeletalMesh;
}

declare class SkelMeshComponentLODInfo { 
	HiddenMaterials: boolean[];
	clone() : SkelMeshComponentLODInfo;
	static C(Other: UObject | any): SkelMeshComponentLODInfo;
}

declare type EMeshComponentUpdateFlag = 'AlwaysTickPoseAndRefreshBones' | 'AlwaysTickPose' | 'OnlyTickMontagesWhenNotRendered' | 'OnlyTickPoseWhenRendered';
declare var EMeshComponentUpdateFlag : { AlwaysTickPoseAndRefreshBones:'AlwaysTickPoseAndRefreshBones',AlwaysTickPose:'AlwaysTickPose',OnlyTickMontagesWhenNotRendered:'OnlyTickMontagesWhenNotRendered',OnlyTickPoseWhenRendered:'OnlyTickPoseWhenRendered', };
declare class SkelMeshSkinWeightInfo { 
	Bones: number;
	Weights: number;
	clone() : SkelMeshSkinWeightInfo;
	static C(Other: UObject | any): SkelMeshSkinWeightInfo;
	BreakSkinWeightInfo(Bone0?: number,Weight0?: number,Bone1?: number,Weight1?: number,Bone2?: number,Weight2?: number,Bone3?: number,Weight3?: number): {Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number};
	static BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo,Bone0?: number,Weight0?: number,Bone1?: number,Weight1?: number,Bone2?: number,Weight2?: number,Bone3?: number,Weight3?: number): {Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number};
	static MakeSkinWeightInfo(Bone0: number,Weight0: number,Bone1: number,Weight1: number,Bone2: number,Weight2: number,Bone3: number,Weight3: number): SkelMeshSkinWeightInfo;
}

declare type EPhysBodyOp = 'PBO_None' | 'PBO_Term';
declare var EPhysBodyOp : { PBO_None:'PBO_None',PBO_Term:'PBO_Term', };
declare class SkinnedMeshComponent extends MeshComponent { 
	SkeletalMesh: SkeletalMesh;
	MasterPoseComponent: any;
	bUseBoundsFromMasterPoseComponent: boolean;
	ChunkIndexPreview: number;
	SectionIndexPreview: number;
	MaterialIndexPreview: number;
	PhysicsAssetOverride: PhysicsAsset;
	ForcedLodModel: number;
	MinLodModel: number;
	LODInfo: SkelMeshComponentLODInfo[];
	StreamingDistanceMultiplier: number;
	WireframeColor: Color;
	bForceWireframe: boolean;
	bDisplayBones: boolean;
	bDisableMorphTarget: boolean;
	bHideSkin: boolean;
	bPerBoneMotionBlur: boolean;
	bComponentUseFixedSkelBounds: boolean;
	bConsiderAllBodiesForBounds: boolean;
	MeshComponentUpdateFlag: EMeshComponentUpdateFlag;
	bForceMeshObjectUpdate: boolean;
	bCanHighlightSelectedSections: boolean;
	bRecentlyRendered: boolean;
	ProgressiveDrawingFraction: number;
	CustomSortAlternateIndexMode: number;
	bCastCapsuleDirectShadow: boolean;
	bCastCapsuleIndirectShadow: boolean;
	CapsuleIndirectShadowMinVisibility: number;
	bCPUSkinning: boolean;
	CachedLocalBounds: BoxSphereBounds;
	bCachedLocalBoundsUpToDate: boolean;
	bEnableUpdateRateOptimizations: boolean;
	bDisplayDebugUpdateRateOptimizations: boolean;
	static Load(ResourceName: string): SkinnedMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SkinnedMeshComponent;
	static GetDefaultObject(): SkinnedMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkinnedMeshComponent;
	UnHideBoneByName(BoneName: string): void;
	TransformToBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	TransformFromBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	SetVertexColorOverride_LinearColor(LODIndex: number,VertexColors: LinearColor[]): void;
	SetSkinWeightOverride(LODIndex: number,SkinWeights: SkelMeshSkinWeightInfo[]): void;
	SetSkeletalMesh(NewMesh: SkeletalMesh,bReinitPose: boolean): void;
	SetPhysicsAsset(NewPhysicsAsset: PhysicsAsset,bForceReInit: boolean): void;
	SetMinLOD(InNewMinLOD: number): void;
	SetMasterPoseComponent(NewMasterBoneComponent: SkinnedMeshComponent): void;
	SetForcedLOD(InNewForcedLOD: number): void;
	SetCastCapsuleIndirectShadow(bNewValue: boolean): void;
	SetCastCapsuleDirectShadow(bNewValue: boolean): void;
	SetCapsuleIndirectShadowMinVisibility(NewValue: number): void;
	IsBoneHiddenByName(BoneName: string): boolean;
	HideBoneByName(BoneName: string,PhysBodyOption: EPhysBodyOp): void;
	GetSocketBoneName(InSocketName: string): string;
	GetParentBone(BoneName: string): string;
	GetNumBones(): number;
	GetBoneName(BoneIndex: number): string;
	GetBoneIndex(BoneName: string): number;
	FindClosestBone_K2(TestLocation: Vector,BoneLocation?: Vector,IgnoreScale?: number,bRequirePhysicsAsset?: boolean): {BoneLocation: Vector, $: string};
	ClearVertexColorOverride(LODIndex: number): void;
	ClearSkinWeightOverride(LODIndex: number): void;
	BoneIsChildOf(BoneName: string,ParentBoneName: string): boolean;
	static C(Other: UObject | any): SkinnedMeshComponent;
}

declare type EAnimationMode = 'AnimationBlueprint' | 'AnimationSingleNode' | 'AnimationCustomMode';
declare var EAnimationMode : { AnimationBlueprint:'AnimationBlueprint',AnimationSingleNode:'AnimationSingleNode',AnimationCustomMode:'AnimationCustomMode', };
declare class AnimGroupInfo { 
	Name: string;
	Color: LinearColor;
	clone() : AnimGroupInfo;
	static C(Other: UObject | any): AnimGroupInfo;
}

declare class AnimParentNodeAssetOverride { 
	NewAsset: AnimationAsset;
	ParentNodeGuid: Guid;
	clone() : AnimParentNodeAssetOverride;
	static C(Other: UObject | any): AnimParentNodeAssetOverride;
}

declare class PoseWatch extends UObject { 
	UNode: EdGraphNode;
	PoseWatchColour: Color;
	static Load(ResourceName: string): PoseWatch;
	static Find(Outer: UObject, ResourceName: string): PoseWatch;
	static GetDefaultObject(): PoseWatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseWatch;
	static C(Other: UObject | any): PoseWatch;
}

declare class AnimBlueprint extends Blueprint { 
	TargetSkeleton: Skeleton;
	Groups: AnimGroupInfo[];
	bUseMultiThreadedAnimationUpdate: boolean;
	bWarnAboutBlueprintUsage: boolean;
	ParentAssetOverrides: AnimParentNodeAssetOverride[];
	PoseWatches: PoseWatch[];
	PreviewSkeletalMesh: any;
	static Load(ResourceName: string): AnimBlueprint;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprint;
	static GetDefaultObject(): AnimBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprint;
	static C(Other: UObject | any): AnimBlueprint;
}

declare class SingleAnimationPlayData { 
	AnimToPlay: AnimationAsset;
	bSavedLooping: boolean;
	bSavedPlaying: boolean;
	SavedPosition: number;
	SavedPlayRate: number;
	clone() : SingleAnimationPlayData;
	static C(Other: UObject | any): SingleAnimationPlayData;
}

declare type EDynamicActorScene = 'Default' | 'UseSyncScene' | 'UseAsyncScene';
declare var EDynamicActorScene : { Default:'Default',UseSyncScene:'UseSyncScene',UseAsyncScene:'UseAsyncScene', };
declare type EKinematicBonesUpdateToPhysics = 'SkipSimulatingBones' | 'SkipAllBones';
declare var EKinematicBonesUpdateToPhysics : { SkipSimulatingBones:'SkipSimulatingBones',SkipAllBones:'SkipAllBones', };
declare type EPhysicsTransformUpdateMode = 'SimulationUpatesComponentTransform' | 'ComponentTransformIsKinematic';
declare var EPhysicsTransformUpdateMode : { SimulationUpatesComponentTransform:'SimulationUpatesComponentTransform',ComponentTransformIsKinematic:'ComponentTransformIsKinematic', };
declare class ClothingSimulationFactory extends UObject { 
	static Load(ResourceName: string): ClothingSimulationFactory;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationFactory;
	static GetDefaultObject(): ClothingSimulationFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationFactory;
	static C(Other: UObject | any): ClothingSimulationFactory;
}

declare class SkeletalMeshComponent extends SkinnedMeshComponent { 
	AnimationMode: EAnimationMode;
	AnimationBlueprint: AnimBlueprint;
	AnimBlueprintGeneratedClass: UnrealEngineClass;
	AnimClass: UnrealEngineClass;
	AnimScriptInstance: AnimInstance;
	SubInstances: AnimInstance[];
	PostProcessAnimInstance: AnimInstance;
	AnimationData: SingleAnimationPlayData;
	CachedBoneSpaceTransforms: Transform[];
	CachedComponentSpaceTransforms: Transform[];
	GlobalAnimRateScale: number;
	UseAsyncScene: UseAsyncScene;
	bHasValidBodies: boolean;
	KinematicBonesUpdateType: EKinematicBonesUpdateToPhysics;
	PhysicsTransformUpdateMode: EPhysicsTransformUpdateMode;
	bBlendPhysics: boolean;
	bEnablePhysicsOnDedicatedServer: boolean;
	bUpdateJointsFromAnimation: boolean;
	bDisableClothSimulation: boolean;
	bAllowAnimCurveEvaluation: boolean;
	bDisableAnimCurves: boolean;
	DisallowedAnimCurves: string[];
	bCollideWithEnvironment: boolean;
	bCollideWithAttachedChildren: boolean;
	bLocalSpaceSimulation: boolean;
	bClothMorphTarget: boolean;
	bResetAfterTeleport: boolean;
	ClothBlendWeight: number;
	RootBoneTranslation: Vector;
	bDeferMovementFromSceneQueries: boolean;
	bNoSkeletonUpdate: boolean;
	bPauseAnims: boolean;
	bUseRefPoseOnInitAnim: boolean;
	bEnablePerPolyCollision: boolean;
	BodySetup: BodySetup;
	bForceRefpose: boolean;
	bOnlyAllowAutonomousTickPose: boolean;
	bIsAutonomousTickPose: boolean;
	bOldForceRefPose: boolean;
	bShowPrePhysBones: boolean;
	bRequiredBonesUpToDate: boolean;
	bAnimTreeInitialised: boolean;
	bIncludeComponentLocationIntoBounds: boolean;
	bEnableLineCheckWithBounds: boolean;
	bUpdateAnimationInEditor: boolean;
	CachedAnimCurveUidVersion: any;
	LineCheckBoundsScale: Vector;
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	ClothingSimulationFactory: UnrealEngineClass;
	TeleportDistanceThreshold: number;
	TeleportRotationThreshold: number;
	OnAnimInitialized: UnrealEngineMulticastDelegate<() => void>;
	SequenceToPlay: AnimSequence;
	AnimToPlay: AnimationAsset;
	bDefaultLooping: boolean;
	bDefaultPlaying: boolean;
	DefaultPosition: number;
	DefaultPlayRate: number;
	LastPoseTickFrame: any;
	LastPoseTickTime: number;
	bNeedsQueuedAnimEventsDispatched: boolean;
	static Load(ResourceName: string): SkeletalMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshComponent;
	static GetDefaultObject(): SkeletalMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshComponent;
	UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace: boolean): void;
	SuspendClothingSimulation(): void;
	Stop(): void;
	SnapshotPose(Snapshot?: PoseSnapshot): {Snapshot: PoseSnapshot};
	SetUpdateAnimationInEditor(NewUpdateState: boolean): void;
	SetTeleportRotationThreshold(Threshold: number): void;
	SetTeleportDistanceThreshold(Threshold: number): void;
	SetPosition(InPos: number,bFireNotifies: boolean): void;
	SetPlayRate(Rate: number): void;
	SetPhysicsBlendWeight(PhysicsBlendWeight: number): void;
	SetNotifyRigidBodyCollisionBelow(bNewNotifyRigidBodyCollision: boolean,BoneName: string,bIncludeSelf: boolean): void;
	SetMorphTarget(MorphTargetName: string,Value: number,bRemoveZeroWeight: boolean): void;
	SetEnablePhysicsBlending(bNewBlendPhysics: boolean): void;
	SetEnableGravityOnAllBodiesBelow(bEnableGravity: boolean,BoneName: string,bIncludeSelf: boolean): void;
	SetEnableBodyGravity(bEnableGravity: boolean,BoneName: string): void;
	SetDisableAnimCurves(bInDisableAnimCurves: boolean): void;
	SetConstraintProfileForAll(ProfileName: string,bDefaultIfNotFound: boolean): void;
	SetConstraintProfile(JointName: string,ProfileName: string,bDefaultIfNotFound: boolean): void;
	SetClothMaxDistanceScale(Scale: number): void;
	SetBodyNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean,BoneName: string): void;
	SetAnimInstanceClass(NewClass: UnrealEngineClass): void;
	SetAnimationMode(InAnimationMode: EAnimationMode): void;
	SetAnimation(NewAnimToPlay: AnimationAsset): void;
	SetAngularLimits(InBoneName: string,Swing1LimitAngle: number,TwistLimitAngle: number,Swing2LimitAngle: number): void;
	SetAllowedAnimCurvesEvaluation(List: string[],bAllow: boolean): void;
	SetAllowAnimCurveEvaluation(bInAllow: boolean): void;
	SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	SetAllMotorsAngularDriveParams(InSpring: number,InDamping: number,InForceLimit: number,bSkipCustomPhysicsType: boolean): void;
	SetAllBodiesSimulatePhysics(bNewSimulate: boolean): void;
	SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	SetAllBodiesBelowSimulatePhysics(InBoneName: string,bNewSimulate: boolean,bIncludeSelf: boolean): void;
	SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string,PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean,bIncludeSelf: boolean): void;
	ResumeClothingSimulation(): void;
	ResetClothTeleportMode(): void;
	ResetAllowedAnimCurveEvaluation(): void;
	ResetAllBodiesSimulatePhysics(): void;
	PlayAnimation(NewAnimToPlay: AnimationAsset,bLooping: boolean): void;
	Play(bLooping: boolean): void;
	OverrideAnimationData(InAnimToPlay: AnimationAsset,bIsLooping: boolean,bIsPlaying: boolean,Position: number,PlayRate: number): void;
	K2_GetClosestPointOnPhysicsAsset(WorldPosition: Vector,ClosestWorldPosition?: Vector,Normal?: Vector,BoneName?: string,Distance?: number): {ClosestWorldPosition: Vector, Normal: Vector, BoneName: string, Distance: number, $: boolean};
	IsPlaying(): boolean;
	IsClothingSimulationSuspended(): boolean;
	IsBodyGravityEnabled(BoneName: string): boolean;
	GetTeleportRotationThreshold(): number;
	GetTeleportDistanceThreshold(): number;
	GetSkeletalCenterOfMass(): Vector;
	GetPostProcessInstance(): AnimInstance;
	GetPosition(): number;
	GetPlayRate(): number;
	GetMorphTarget(MorphTargetName: string): number;
	GetDisableAnimCurves(): boolean;
	GetCurrentJointAngles(InBoneName: string,Swing1Angle?: number,TwistAngle?: number,Swing2Angle?: number): {Swing1Angle: number, TwistAngle: number, Swing2Angle: number};
	GetClothMaxDistanceScale(): number;
	GetBoneMass(BoneName: string,bScaleMass: boolean): number;
	GetAnimInstance(): AnimInstance;
	GetAnimationMode(): EAnimationMode;
	GetAllowedAnimCurveEvaluate(): boolean;
	ForceClothNextUpdateTeleportAndReset(): void;
	ForceClothNextUpdateTeleport(): void;
	FindConstraintBoneName(ConstraintIndex: number): string;
	ClearMorphTargets(): void;
	BreakConstraint(Impulse: Vector,HitLocation: Vector,InBoneName: string): void;
	BindClothToMasterPoseComponent(): void;
	AllowAnimCurveEvaluation(NameOfCurve: string,bAllow: boolean): void;
	AddImpulseToAllBodiesBelow(Impulse: Vector,BoneName: string,bVelChange: boolean,bIncludeSelf: boolean): void;
	AddForceToAllBodiesBelow(Force: Vector,BoneName: string,bAccelChange: boolean,bIncludeSelf: boolean): void;
	AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string,AddPhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	static C(Other: UObject | any): SkeletalMeshComponent;
}

declare class SpriteCategoryInfo { 
	Category: string;
	DisplayName: string;
	Description: string;
	clone() : SpriteCategoryInfo;
	static C(Other: UObject | any): SpriteCategoryInfo;
}

declare class ArrowComponent extends PrimitiveComponent { 
	ArrowColor: Color;
	ArrowSize: number;
	bIsScreenSizeScaled: boolean;
	ScreenSize: number;
	bTreatAsASprite: boolean;
	SpriteCategoryName: string;
	SpriteInfo: SpriteCategoryInfo;
	bLightAttachment: boolean;
	bUseInEditorScaling: boolean;
	static Load(ResourceName: string): ArrowComponent;
	static Find(Outer: UObject, ResourceName: string): ArrowComponent;
	static GetDefaultObject(): ArrowComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrowComponent;
	SetArrowColor(NewColor: LinearColor): void;
	static C(Other: UObject | any): ArrowComponent;
}

declare type EPlaneConstraintAxisSetting = 'Custom' | 'X' | 'Y' | 'Z' | 'UseGlobalPhysicsSetting';
declare var EPlaneConstraintAxisSetting : { Custom:'Custom',X:'X',Y:'Y',Z:'Z',UseGlobalPhysicsSetting:'UseGlobalPhysicsSetting', };
declare class MovementComponent extends ActorComponent { 
	UpdatedComponent: SceneComponent;
	UpdatedPrimitive: PrimitiveComponent;
	Velocity: Vector;
	bConstrainToPlane: boolean;
	bSnapToPlaneAtStart: boolean;
	PlaneConstraintAxisSetting: PlaneConstraintAxisSetting;
	PlaneConstraintNormal: Vector;
	PlaneConstraintOrigin: Vector;
	bUpdateOnlyIfRendered: boolean;
	bAutoUpdateTickRegistration: boolean;
	bTickBeforeOwner: boolean;
	bAutoRegisterUpdatedComponent: boolean;
	static Load(ResourceName: string): MovementComponent;
	static Find(Outer: UObject, ResourceName: string): MovementComponent;
	static GetDefaultObject(): MovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovementComponent;
	StopMovementImmediately(): void;
	SnapUpdatedComponentToPlane(): void;
	SetUpdatedComponent(NewUpdatedComponent: SceneComponent): void;
	SetPlaneConstraintOrigin(PlaneOrigin: Vector): void;
	SetPlaneConstraintNormal(PlaneNormal: Vector): void;
	SetPlaneConstraintFromVectors(Forward: Vector,Up: Vector): void;
	SetPlaneConstraintEnabled(bEnabled: boolean): void;
	SetPlaneConstraintAxisSetting(NewAxisSetting: NewAxisSetting): void;
	PhysicsVolumeChanged(NewVolume: PhysicsVolume): void;
	K2_MoveUpdatedComponent(Delta: Vector,NewRotation: Rotator,OutHit?: HitResult,bSweep?: boolean,bTeleport?: boolean): {OutHit: HitResult, $: boolean};
	K2_GetModifiedMaxSpeed(): number;
	K2_GetMaxSpeedModifier(): number;
	IsExceedingMaxSpeed(MaxSpeed: number): boolean;
	GetPlaneConstraintOrigin(): Vector;
	GetPlaneConstraintNormal(): Vector;
	GetPlaneConstraintAxisSetting(): ReturnValue;
	GetPhysicsVolume(): PhysicsVolume;
	GetMaxSpeed(): number;
	GetGravityZ(): number;
	ConstrainNormalToPlane(Normal: Vector): Vector;
	ConstrainLocationToPlane(Location: Vector): Vector;
	ConstrainDirectionToPlane(Direction: Vector): Vector;
	static C(Other: UObject | any): MovementComponent;
}

declare class MovementProperties { 
	bCanCrouch: boolean;
	bCanJump: boolean;
	bCanWalk: boolean;
	bCanSwim: boolean;
	bCanFly: boolean;
	clone() : MovementProperties;
	static C(Other: UObject | any): MovementProperties;
}

declare class NavDataConfig extends NavAgentProperties { 
	Name: string;
	Color: Color;
	DefaultQueryExtent: Vector;
	NavigationDataClass: UnrealEngineClass;
	NavigationDataClassName: SoftClassPath;
	clone() : NavDataConfig;
	static C(Other: UObject | any): NavDataConfig;
}

declare type ERuntimeGenerationType = 'Static' | 'DynamicModifiersOnly' | 'Dynamic' | 'LegacyGeneration';
declare var ERuntimeGenerationType : { Static:'Static',DynamicModifiersOnly:'DynamicModifiersOnly',Dynamic:'Dynamic',LegacyGeneration:'LegacyGeneration', };
declare class SupportedAreaData { 
	AreaClassName: string;
	AreaID: number;
	AreaClass: UnrealEngineClass;
	clone() : SupportedAreaData;
	static C(Other: UObject | any): SupportedAreaData;
}

declare class NavigationData extends Actor { 
	RenderingComp: PrimitiveComponent;
	NavDataConfig: NavDataConfig;
	bEnableDrawing: boolean;
	bForceRebuildOnLoad: boolean;
	bCanBeMainNavData: boolean;
	bCanSpawnOnRebuild: boolean;
	bRebuildAtRuntime: boolean;
	RuntimeGeneration: RuntimeGeneration;
	ObservedPathsTickInterval: number;
	DataVersion: any;
	SupportedAreas: SupportedAreaData[];
	static GetDefaultObject(): NavigationData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationData;
	static C(Other: UObject | any): NavigationData;
}

declare class NavAgentProperties extends MovementProperties { 
	AgentRadius: number;
	AgentHeight: number;
	AgentStepHeight: number;
	NavWalkingSearchHeightScale: number;
	PreferredNavData: UnrealEngineClass;
	clone() : NavAgentProperties;
	static C(Other: UObject | any): NavAgentProperties;
}

declare class NavMovementComponent extends MovementComponent { 
	NavAgentProps: NavAgentProperties;
	FixedPathBrakingDistance: number;
	bUpdateNavAgentWithOwnersCollision: boolean;
	bUseAccelerationForPaths: boolean;
	bUseFixedBrakingDistanceForPaths: boolean;
	MovementState: MovementProperties;
	static Load(ResourceName: string): NavMovementComponent;
	static Find(Outer: UObject, ResourceName: string): NavMovementComponent;
	static GetDefaultObject(): NavMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMovementComponent;
	StopMovementKeepPathing(): void;
	StopActiveMovement(): void;
	IsSwimming(): boolean;
	IsMovingOnGround(): boolean;
	IsFlying(): boolean;
	IsFalling(): boolean;
	IsCrouching(): boolean;
	static C(Other: UObject | any): NavMovementComponent;
}

declare class PawnMovementComponent extends NavMovementComponent { 
	PawnOwner: Pawn;
	static Load(ResourceName: string): PawnMovementComponent;
	static Find(Outer: UObject, ResourceName: string): PawnMovementComponent;
	static GetDefaultObject(): PawnMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnMovementComponent;
	K2_GetInputVector(): Vector;
	IsMoveInputIgnored(): boolean;
	GetPendingInputVector(): Vector;
	GetPawnOwner(): Pawn;
	GetLastInputVector(): Vector;
	ConsumeInputVector(): Vector;
	AddInputVector(WorldVector: Vector,bForce: boolean): void;
	static C(Other: UObject | any): PawnMovementComponent;
}

declare type EMovementMode = 'MOVE_None' | 'MOVE_Walking' | 'MOVE_NavWalking' | 'MOVE_Falling' | 'MOVE_Swimming' | 'MOVE_Flying' | 'MOVE_Custom';
declare var EMovementMode : { MOVE_None:'MOVE_None',MOVE_Walking:'MOVE_Walking',MOVE_NavWalking:'MOVE_NavWalking',MOVE_Falling:'MOVE_Falling',MOVE_Swimming:'MOVE_Swimming',MOVE_Flying:'MOVE_Flying',MOVE_Custom:'MOVE_Custom', };
declare type ENetworkSmoothingMode = 'Disabled' | 'Linear' | 'Exponential' | 'Replay';
declare var ENetworkSmoothingMode : { Disabled:'Disabled',Linear:'Linear',Exponential:'Exponential',Replay:'Replay', };
declare class FindFloorResult { 
	bBlockingHit: boolean;
	bWalkableFloor: boolean;
	bLineTrace: boolean;
	FloorDist: number;
	LineDist: number;
	HitResult: HitResult;
	clone() : FindFloorResult;
	static C(Other: UObject | any): FindFloorResult;
}

declare class NavAvoidanceMask { 
	bGroup0: boolean;
	bGroup1: boolean;
	bGroup2: boolean;
	bGroup3: boolean;
	bGroup4: boolean;
	bGroup5: boolean;
	bGroup6: boolean;
	bGroup7: boolean;
	bGroup8: boolean;
	bGroup9: boolean;
	bGroup10: boolean;
	bGroup11: boolean;
	bGroup12: boolean;
	bGroup13: boolean;
	bGroup14: boolean;
	bGroup15: boolean;
	bGroup16: boolean;
	bGroup17: boolean;
	bGroup18: boolean;
	bGroup19: boolean;
	bGroup20: boolean;
	bGroup21: boolean;
	bGroup22: boolean;
	bGroup23: boolean;
	bGroup24: boolean;
	bGroup25: boolean;
	bGroup26: boolean;
	bGroup27: boolean;
	bGroup28: boolean;
	bGroup29: boolean;
	bGroup30: boolean;
	bGroup31: boolean;
	clone() : NavAvoidanceMask;
	static C(Other: UObject | any): NavAvoidanceMask;
}

declare class CharacterMovementComponentPostPhysicsTickFunction extends TickFunction { 
	clone() : CharacterMovementComponentPostPhysicsTickFunction;
	static C(Other: UObject | any): CharacterMovementComponentPostPhysicsTickFunction;
}

declare class Vector_NetQuantize10 extends Vector { 
	clone() : Vector_NetQuantize10;
	static C(Other: UObject | any): Vector_NetQuantize10;
}

declare class RootMotionSourceSettings { 
	Flags: number;
	clone() : RootMotionSourceSettings;
	static C(Other: UObject | any): RootMotionSourceSettings;
}

declare class RootMotionSourceGroup { 
	bHasAdditiveSources: boolean;
	bHasOverrideSources: boolean;
	LastPreAdditiveVelocity: Vector_NetQuantize10;
	bIsAdditiveVelocityApplied: boolean;
	LastAccumulatedSettings: RootMotionSourceSettings;
	clone() : RootMotionSourceGroup;
	static C(Other: UObject | any): RootMotionSourceGroup;
}

declare class RootMotionMovementParams { 
	bHasRootMotion: boolean;
	BlendWeight: number;
	RootMotionTransform: Transform;
	clone() : RootMotionMovementParams;
	static C(Other: UObject | any): RootMotionMovementParams;
}

declare class CharacterMovementComponent extends PawnMovementComponent { 
	CharacterOwner: Character;
	bApplyGravityWhileJumping: boolean;
	GravityScale: number;
	MaxStepHeight: number;
	JumpZVelocity: number;
	JumpOffJumpZFactor: number;
	WalkableFloorAngle: number;
	WalkableFloorZ: number;
	MovementMode: EMovementMode;
	CustomMovementMode: number;
	GroundFriction: number;
	MaxWalkSpeed: number;
	MaxWalkSpeedCrouched: number;
	MaxSwimSpeed: number;
	MaxFlySpeed: number;
	MaxCustomMovementSpeed: number;
	MaxAcceleration: number;
	MinAnalogWalkSpeed: number;
	BrakingFrictionFactor: number;
	BrakingFriction: number;
	bUseSeparateBrakingFriction: boolean;
	BrakingDecelerationWalking: number;
	BrakingDecelerationFalling: number;
	BrakingDecelerationSwimming: number;
	BrakingDecelerationFlying: number;
	AirControl: number;
	AirControlBoostMultiplier: number;
	AirControlBoostVelocityThreshold: number;
	FallingLateralFriction: number;
	CrouchedHalfHeight: number;
	Buoyancy: number;
	PerchRadiusThreshold: number;
	PerchAdditionalHeight: number;
	RotationRate: Rotator;
	bUseControllerDesiredRotation: boolean;
	bOrientRotationToMovement: boolean;
	bSweepWhileNavWalking: boolean;
	bMovementInProgress: boolean;
	bEnableScopedMovementUpdates: boolean;
	bForceMaxAccel: boolean;
	bRunPhysicsWithNoController: boolean;
	bForceNextFloorCheck: boolean;
	bShrinkProxyCapsule: boolean;
	bCanWalkOffLedges: boolean;
	bCanWalkOffLedgesWhenCrouching: boolean;
	bDeferUpdateMoveComponent: boolean;
	DeferredUpdatedMoveComponent: SceneComponent;
	MaxOutOfWaterStepHeight: number;
	OutofWaterZ: number;
	Mass: number;
	bEnablePhysicsInteraction: boolean;
	bTouchForceScaledToMass: boolean;
	bPushForceScaledToMass: boolean;
	bPushForceUsingZOffset: boolean;
	bScalePushForceToVelocity: boolean;
	StandingDownwardForceScale: number;
	InitialPushForceFactor: number;
	PushForceFactor: number;
	PushForcePointZOffsetFactor: number;
	TouchForceFactor: number;
	MinTouchForce: number;
	MaxTouchForce: number;
	RepulsionForce: number;
	bForceBraking: boolean;
	CrouchedSpeedMultiplier: number;
	UpperImpactNormalScale: number;
	Acceleration: Vector;
	LastUpdateLocation: Vector;
	LastUpdateRotation: Quat;
	LastUpdateVelocity: Vector;
	ServerLastTransformUpdateTimeStamp: number;
	PendingImpulseToApply: Vector;
	PendingForceToApply: Vector;
	AnalogInputModifier: number;
	MaxSimulationTimeStep: number;
	MaxSimulationIterations: number;
	MaxDepenetrationWithGeometry: number;
	MaxDepenetrationWithGeometryAsProxy: number;
	MaxDepenetrationWithPawn: number;
	MaxDepenetrationWithPawnAsProxy: number;
	NetworkSimulatedSmoothLocationTime: number;
	NetworkSimulatedSmoothRotationTime: number;
	ListenServerNetworkSimulatedSmoothLocationTime: number;
	ListenServerNetworkSimulatedSmoothRotationTime: number;
	NetProxyShrinkRadius: number;
	NetProxyShrinkHalfHeight: number;
	NetworkMaxSmoothUpdateDistance: number;
	NetworkNoSmoothUpdateDistance: number;
	NetworkSmoothingMode: NetworkSmoothingMode;
	LedgeCheckThreshold: number;
	JumpOutOfWaterPitch: number;
	CurrentFloor: FindFloorResult;
	DefaultLandMovementMode: EMovementMode;
	DefaultWaterMovementMode: EMovementMode;
	GroundMovementMode: EMovementMode;
	bMaintainHorizontalGroundVelocity: boolean;
	bImpartBaseVelocityX: boolean;
	bImpartBaseVelocityY: boolean;
	bImpartBaseVelocityZ: boolean;
	bImpartBaseAngularVelocity: boolean;
	bJustTeleported: boolean;
	bNetworkUpdateReceived: boolean;
	bNetworkMovementModeChanged: boolean;
	bIgnoreClientMovementErrorChecksAndCorrection: boolean;
	bNotifyApex: boolean;
	bCheatFlying: boolean;
	bWantsToCrouch: boolean;
	bCrouchMaintainsBaseLocation: boolean;
	bIgnoreBaseRotation: boolean;
	bFastAttachedMove: boolean;
	bAlwaysCheckFloor: boolean;
	bUseFlatBaseForFloorChecks: boolean;
	bPerformingJumpOff: boolean;
	bWantsToLeaveNavWalking: boolean;
	bUseRVOAvoidance: boolean;
	bRequestedMoveUseAcceleration: boolean;
	bHasRequestedVelocity: boolean;
	bRequestedMoveWithMaxSpeed: boolean;
	bWasAvoidanceUpdated: boolean;
	bProjectNavMeshWalking: boolean;
	bProjectNavMeshOnBothWorldChannels: boolean;
	AvoidanceConsiderationRadius: number;
	RequestedVelocity: Vector;
	AvoidanceUID: number;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	AvoidanceWeight: number;
	PendingLaunchVelocity: Vector;
	NavMeshProjectionInterval: number;
	NavMeshProjectionTimer: number;
	NavMeshProjectionInterpSpeed: number;
	NavMeshProjectionHeightScaleUp: number;
	NavMeshProjectionHeightScaleDown: number;
	NavWalkingFloorDistTolerance: number;
	PostPhysicsTickFunction: CharacterMovementComponentPostPhysicsTickFunction;
	MinTimeBetweenTimeStampResets: number;
	CurrentRootMotion: RootMotionSourceGroup;
	RootMotionParams: RootMotionMovementParams;
	AnimRootMotionVelocity: Vector;
	bWasSimulatingRootMotion: boolean;
	bAllowPhysicsRotationDuringAnimRootMotion: boolean;
	static Load(ResourceName: string): CharacterMovementComponent;
	static Find(Outer: UObject, ResourceName: string): CharacterMovementComponent;
	static GetDefaultObject(): CharacterMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CharacterMovementComponent;
	SetWalkableFloorZ(InWalkableFloorZ: number): void;
	SetWalkableFloorAngle(InWalkableFloorAngle: number): void;
	SetMovementMode(NewMovementMode: EMovementMode,NewCustomMode: number): void;
	SetGroupsToIgnoreMask(GroupMask: NavAvoidanceMask): void;
	SetGroupsToIgnore(GroupFlags: number): void;
	SetGroupsToAvoidMask(GroupMask: NavAvoidanceMask): void;
	SetGroupsToAvoid(GroupFlags: number): void;
	SetAvoidanceGroupMask(GroupMask: NavAvoidanceMask): void;
	SetAvoidanceGroup(GroupFlags: number): void;
	SetAvoidanceEnabled(bEnable: boolean): void;
	ServerMoveOld(OldTimeStamp: number,OldAccel: Vector_NetQuantize10,OldMoveFlags: number): void;
	ServerMoveDualHybridRootMotion(TimeStamp0: number,InAccel0: Vector_NetQuantize10,PendingFlags: number,View0: any,TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,NewFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	ServerMoveDual(TimeStamp0: number,InAccel0: Vector_NetQuantize10,PendingFlags: number,View0: any,TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,NewFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	ServerMove(TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,CompressedMoveFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	K2_GetWalkableFloorZ(): number;
	K2_GetWalkableFloorAngle(): number;
	K2_GetModifiedMaxAcceleration(): number;
	K2_FindFloor(CapsuleLocation: Vector,FloorResult?: FindFloorResult): {FloorResult: FindFloorResult};
	K2_ComputeFloorDist(CapsuleLocation: Vector,LineDistance: number,SweepDistance: number,SweepRadius: number,FloorResult?: FindFloorResult): {FloorResult: FindFloorResult};
	IsWalking(): boolean;
	IsWalkable(Hit: HitResult): boolean;
	GetValidPerchRadius(): number;
	GetPerchRadiusThreshold(): number;
	GetMovementBase(): PrimitiveComponent;
	GetMinAnalogSpeed(): number;
	GetMaxJumpHeightWithJumpTime(): number;
	GetMaxJumpHeight(): number;
	GetMaxBrakingDeceleration(): number;
	GetMaxAcceleration(): number;
	GetImpartedMovementBaseVelocity(): Vector;
	GetCurrentAcceleration(): Vector;
	GetCharacterOwner(): Character;
	GetAnalogInputModifier(): number;
	DisableMovement(): void;
	ClientVeryShortAdjustPosition(TimeStamp: number,NewLoc: Vector,NewBase: PrimitiveComponent,NewBaseBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAdjustRootMotionSourcePosition(TimeStamp: number,ServerRootMotion: RootMotionSourceGroup,bHasAnimRootMotion: boolean,ServerMontageTrackPosition: number,ServerLoc: Vector,ServerRotation: Vector_NetQuantizeNormal,ServerVelZ: number,ServerBase: PrimitiveComponent,ServerBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAdjustRootMotionPosition(TimeStamp: number,ServerMontageTrackPosition: number,ServerLoc: Vector,ServerRotation: Vector_NetQuantizeNormal,ServerVelZ: number,ServerBase: PrimitiveComponent,ServerBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAdjustPosition(TimeStamp: number,NewLoc: Vector,NewVel: Vector,NewBase: PrimitiveComponent,NewBaseBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	ClientAckGoodMove(TimeStamp: number): void;
	ClearAccumulatedForces(): void;
	CapsuleTouched(OverlappedComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,OtherBodyIndex: number,bFromSweep: boolean,SweepResult: HitResult): void;
	CalcVelocity(DeltaTime: number,Friction: number,bFluid: boolean,BrakingDeceleration: number): void;
	AddImpulse(Impulse: Vector,bVelocityChange: boolean): void;
	AddForce(Force: Vector): void;
	static C(Other: UObject | any): CharacterMovementComponent;
}

declare class NavAgentSelector { 
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	clone() : NavAgentSelector;
	static C(Other: UObject | any): NavAgentSelector;
}

declare class NavArea extends UObject { 
	DefaultCost: number;
	FixedAreaEnteringCost: number;
	DrawColor: Color;
	SupportedAgents: NavAgentSelector;
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	static Load(ResourceName: string): NavArea;
	static Find(Outer: UObject, ResourceName: string): NavArea;
	static GetDefaultObject(): NavArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea;
	static C(Other: UObject | any): NavArea;
}

declare class ShapeComponent extends PrimitiveComponent { 
	ShapeColor: Color;
	ShapeBodySetup: BodySetup;
	bDrawOnlyIfSelected: boolean;
	bShouldCollideWhenPlacing: boolean;
	bDynamicObstacle: boolean;
	AreaClass: UnrealEngineClass;
	static Load(ResourceName: string): ShapeComponent;
	static Find(Outer: UObject, ResourceName: string): ShapeComponent;
	static GetDefaultObject(): ShapeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShapeComponent;
	static C(Other: UObject | any): ShapeComponent;
}

declare class CapsuleComponent extends ShapeComponent { 
	CapsuleHalfHeight: number;
	CapsuleRadius: number;
	CapsuleHeight: number;
	static Load(ResourceName: string): CapsuleComponent;
	static Find(Outer: UObject, ResourceName: string): CapsuleComponent;
	static GetDefaultObject(): CapsuleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CapsuleComponent;
	SetCapsuleSize(InRadius: number,InHalfHeight: number,bUpdateOverlaps: boolean): void;
	SetCapsuleRadius(Radius: number,bUpdateOverlaps: boolean): void;
	SetCapsuleHalfHeight(HalfHeight: number,bUpdateOverlaps: boolean): void;
	GetUnscaledCapsuleSize_WithoutHemisphere(OutRadius?: number,OutHalfHeightWithoutHemisphere?: number): {OutRadius: number, OutHalfHeightWithoutHemisphere: number};
	GetUnscaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	GetUnscaledCapsuleRadius(): number;
	GetUnscaledCapsuleHalfHeight_WithoutHemisphere(): number;
	GetUnscaledCapsuleHalfHeight(): number;
	GetShapeScale(): number;
	GetScaledCapsuleSize_WithoutHemisphere(OutRadius?: number,OutHalfHeightWithoutHemisphere?: number): {OutRadius: number, OutHalfHeightWithoutHemisphere: number};
	GetScaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	GetScaledCapsuleRadius(): number;
	GetScaledCapsuleHalfHeight_WithoutHemisphere(): number;
	GetScaledCapsuleHalfHeight(): number;
	static C(Other: UObject | any): CapsuleComponent;
}

declare class BasedMovementInfo { 
	MovementBase: PrimitiveComponent;
	BoneName: string;
	Location: Vector_NetQuantize100;
	Rotation: Rotator;
	bServerHasBaseComponent: boolean;
	bRelativeRotation: boolean;
	bServerHasVelocity: boolean;
	clone() : BasedMovementInfo;
	static C(Other: UObject | any): BasedMovementInfo;
}

declare class RepRootMotionMontage { 
	bIsActive: boolean;
	AnimMontage: AnimMontage;
	Position: number;
	Location: Vector_NetQuantize100;
	Rotation: Rotator;
	MovementBase: PrimitiveComponent;
	MovementBaseBoneName: string;
	bRelativePosition: boolean;
	bRelativeRotation: boolean;
	AuthoritativeRootMotion: RootMotionSourceGroup;
	Acceleration: Vector_NetQuantize10;
	LinearVelocity: Vector_NetQuantize10;
	clone() : RepRootMotionMontage;
	static C(Other: UObject | any): RepRootMotionMontage;
}

declare class SimulatedRootMotionReplicatedMove { 
	Time: number;
	RootMotion: RepRootMotionMontage;
	clone() : SimulatedRootMotionReplicatedMove;
	static C(Other: UObject | any): SimulatedRootMotionReplicatedMove;
}

declare class Character extends Pawn { 
	Mesh: SkeletalMeshComponent;
	ArrowComponent: ArrowComponent;
	CharacterMovement: CharacterMovementComponent;
	CapsuleComponent: CapsuleComponent;
	BasedMovement: BasedMovementInfo;
	ReplicatedBasedMovement: BasedMovementInfo;
	AnimRootMotionTranslationScale: number;
	BaseTranslationOffset: Vector;
	BaseRotationOffset: Quat;
	ReplicatedServerLastTransformUpdateTimeStamp: number;
	ReplicatedMovementMode: number;
	bInBaseReplication: boolean;
	CrouchedEyeHeight: number;
	bIsCrouched: boolean;
	bPressedJump: boolean;
	bClientUpdating: boolean;
	bClientWasFalling: boolean;
	bClientResimulateRootMotion: boolean;
	bClientResimulateRootMotionSources: boolean;
	bSimGravityDisabled: boolean;
	bClientCheckEncroachmentOnNetUpdate: boolean;
	bServerMoveIgnoreRootMotion: boolean;
	JumpKeyHoldTime: number;
	JumpMaxHoldTime: number;
	JumpMaxCount: number;
	JumpCurrentCount: number;
	bWasJumping: boolean;
	OnReachedJumpApex: UnrealEngineMulticastDelegate<() => void>;
	MovementModeChangedDelegate: UnrealEngineMulticastDelegate<(Character: Character, PrevMovementMode: EMovementMode, PreviousCustomMode: number) => void>;
	OnCharacterMovementUpdated: UnrealEngineMulticastDelegate<(DeltaSeconds: number, OldLocation: Vector, OldVelocity: Vector) => void>;
	SavedRootMotion: RootMotionSourceGroup;
	ClientRootMotionParams: RootMotionMovementParams;
	RootMotionRepMoves: SimulatedRootMotionReplicatedMove[];
	RepRootMotion: RepRootMotionMontage;
	static GetDefaultObject(): Character;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Character;
	UnCrouch(bClientSimulation: boolean): void;
	StopJumping(): void;
	StopAnimMontage(AnimMontage: AnimMontage): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	RootMotionDebugClientPrintOnScreen(InString: string): void;
	PlayAnimMontage(AnimMontage: AnimMontage,InPlayRate: number,StartSectionName: string): number;
	OnWalkingOffLedge(PreviousFloorImpactNormal: Vector,PreviousFloorContactNormal: Vector,PreviousLocation: Vector,TimeDelta: number): void;
	OnRep_RootMotion(): void;
	OnRep_ReplicatedBasedMovement(): void;
	OnRep_IsCrouched(): void;
	OnLaunched(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	OnLanded(Hit: HitResult): void;
	OnJumped(): void;
	LaunchCharacter(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	K2_UpdateCustomMovement(DeltaTime: number): void;
	K2_OnStartCrouch(HalfHeightAdjust: number,ScaledHalfHeightAdjust: number): void;
	K2_OnMovementModeChanged(PrevMovementMode: EMovementMode,NewMovementMode: EMovementMode,PrevCustomMode: number,NewCustomMode: number): void;
	K2_OnEndCrouch(HalfHeightAdjust: number,ScaledHalfHeightAdjust: number): void;
	Jump(): void;
	IsPlayingRootMotion(): boolean;
	IsPlayingNetworkedRootMotionMontage(): boolean;
	IsJumpProvidingForce(): boolean;
	GetCurrentMontage(): AnimMontage;
	GetBaseTranslationOffset(): Vector;
	GetBaseRotationOffsetRotator(): Rotator;
	GetAnimRootMotionTranslationScale(): number;
	Crouch(bClientSimulation: boolean): void;
	ClientCheatWalk(): void;
	ClientCheatGhost(): void;
	ClientCheatFly(): void;
	CanJumpInternal(): boolean;
	CanJump(): boolean;
	CacheInitialMeshOffset(MeshRelativeLocation: Vector,MeshRelativeRotation: Rotator): void;
	static C(Other: UObject | any): Character;
}

declare class BillboardComponent extends PrimitiveComponent { 
	Sprite: Texture2D;
	bIsScreenSizeScaled: boolean;
	ScreenSize: number;
	U: number;
	UL: number;
	V: number;
	VL: number;
	SpriteCategoryName: string;
	SpriteInfo: SpriteCategoryInfo;
	bUseInEditorScaling: boolean;
	static Load(ResourceName: string): BillboardComponent;
	static Find(Outer: UObject, ResourceName: string): BillboardComponent;
	static GetDefaultObject(): BillboardComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BillboardComponent;
	SetUV(NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	SetSpriteAndUV(NewSprite: Texture2D,NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	SetSprite(NewSprite: Texture2D): void;
	static C(Other: UObject | any): BillboardComponent;
}

declare class Info extends Actor { 
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): Info;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Info;
	static C(Other: UObject | any): Info;
}

declare class LocalMessage extends UObject { 
	static Load(ResourceName: string): LocalMessage;
	static Find(Outer: UObject, ResourceName: string): LocalMessage;
	static GetDefaultObject(): LocalMessage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMessage;
	static C(Other: UObject | any): LocalMessage;
}

declare class UniqueNetIdWrapper { 
	clone() : UniqueNetIdWrapper;
	static C(Other: UObject | any): UniqueNetIdWrapper;
}

declare class UniqueNetIdRepl extends UniqueNetIdWrapper { 
	clone() : UniqueNetIdRepl;
	static C(Other: UObject | any): UniqueNetIdRepl;
}

declare class PlayerState extends Info { 
	Score: number;
	Ping: number;
	PlayerName: string;
	PlayerId: number;
	bIsSpectator: boolean;
	bOnlySpectator: boolean;
	bIsABot: boolean;
	bIsInactive: boolean;
	bFromPreviousLevel: boolean;
	StartTime: number;
	EngineMessageClass: UnrealEngineClass;
	SavedNetworkAddress: string;
	UniqueId: UniqueNetIdRepl;
	static GetDefaultObject(): PlayerState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerState;
	ReceiveOverrideWith(OldPlayerState: PlayerState): void;
	ReceiveCopyProperties(NewPlayerState: PlayerState): void;
	OnRep_UniqueId(): void;
	OnRep_Score(): void;
	OnRep_PlayerName(): void;
	OnRep_bIsInactive(): void;
	static C(Other: UObject | any): PlayerState;
}

declare class DamageType extends UObject { 
	bCausedByWorld: boolean;
	bScaleMomentumByMass: boolean;
	bRadialDamageVelChange: boolean;
	DamageImpulse: number;
	DestructibleImpulse: number;
	DestructibleDamageSpreadScale: number;
	DamageFalloff: number;
	static Load(ResourceName: string): DamageType;
	static Find(Outer: UObject, ResourceName: string): DamageType;
	static GetDefaultObject(): DamageType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DamageType;
	static C(Other: UObject | any): DamageType;
}

declare class Player extends UObject { 
	PlayerController: PlayerController;
	CurrentNetSpeed: number;
	ConfiguredInternetSpeed: number;
	ConfiguredLanSpeed: number;
	static Load(ResourceName: string): Player;
	static Find(Outer: UObject, ResourceName: string): Player;
	static GetDefaultObject(): Player;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Player;
	static C(Other: UObject | any): Player;
}

declare class InterpTrackInst extends UObject { 
	static Load(ResourceName: string): InterpTrackInst;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInst;
	static GetDefaultObject(): InterpTrackInst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInst;
	static C(Other: UObject | any): InterpTrackInst;
}

declare class InterpTrackInstDirector extends InterpTrackInst { 
	OldViewTarget: Actor;
	static Load(ResourceName: string): InterpTrackInstDirector;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstDirector;
	static GetDefaultObject(): InterpTrackInstDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstDirector;
	static C(Other: UObject | any): InterpTrackInstDirector;
}

declare class ReporterBase extends UObject { 
	static Load(ResourceName: string): ReporterBase;
	static Find(Outer: UObject, ResourceName: string): ReporterBase;
	static GetDefaultObject(): ReporterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterBase;
	static C(Other: UObject | any): ReporterBase;
}

declare class ReporterGraph extends ReporterBase { 
	static Load(ResourceName: string): ReporterGraph;
	static Find(Outer: UObject, ResourceName: string): ReporterGraph;
	static GetDefaultObject(): ReporterGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterGraph;
	static C(Other: UObject | any): ReporterGraph;
}

declare class CanvasUVTri { 
	V0_Pos: Vector2D;
	V0_UV: Vector2D;
	V0_Color: LinearColor;
	V1_Pos: Vector2D;
	V1_UV: Vector2D;
	V1_Color: LinearColor;
	V2_Pos: Vector2D;
	V2_UV: Vector2D;
	V2_Color: LinearColor;
	clone() : CanvasUVTri;
	static C(Other: UObject | any): CanvasUVTri;
}

declare class Canvas extends UObject { 
	OrgX: number;
	OrgY: number;
	ClipX: number;
	ClipY: number;
	DrawColor: Color;
	bCenterX: boolean;
	bCenterY: boolean;
	bNoSmooth: boolean;
	SizeX: number;
	SizeY: number;
	ColorModulate: Plane;
	DefaultTexture: Texture2D;
	GradientTexture0: Texture2D;
	ReporterGraph: ReporterGraph;
	static Load(ResourceName: string): Canvas;
	static Find(Outer: UObject, ResourceName: string): Canvas;
	static GetDefaultObject(): Canvas;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Canvas;
	K2_TextSize(RenderFont: Font,RenderText: string,Scale: Vector2D): Vector2D;
	K2_StrLen(RenderFont: Font,RenderText: string): Vector2D;
	K2_Project(WorldLocation: Vector): Vector;
	K2_DrawTriangle(RenderTexture: Texture,Triangles: CanvasUVTri[]): void;
	K2_DrawTexture(RenderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BlendMode: EBlendMode,Rotation: number,PivotPoint: Vector2D): void;
	K2_DrawText(RenderFont: Font,RenderText: string,ScreenPosition: Vector2D,RenderColor: LinearColor,Kerning: number,ShadowColor: LinearColor,ShadowOffset: Vector2D,bCentreX: boolean,bCentreY: boolean,bOutlined: boolean,OutlineColor: LinearColor): void;
	K2_DrawPolygon(RenderTexture: Texture,ScreenPosition: Vector2D,Radius: Vector2D,NumberOfSides: number,RenderColor: LinearColor): void;
	K2_DrawMaterialTriangle(RenderMaterial: MaterialInterface,Triangles: CanvasUVTri[]): void;
	K2_DrawMaterial(RenderMaterial: MaterialInterface,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,Rotation: number,PivotPoint: Vector2D): void;
	K2_DrawLine(ScreenPositionA: Vector2D,ScreenPositionB: Vector2D,Thickness: number,RenderColor: LinearColor): void;
	K2_DrawBox(ScreenPosition: Vector2D,ScreenSize: Vector2D,Thickness: number): void;
	K2_DrawBorder(BorderTexture: Texture,BackgroundTexture: Texture,LeftBorderTexture: Texture,RightBorderTexture: Texture,TopBorderTexture: Texture,BottomBorderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BorderScale: Vector2D,BackgroundScale: Vector2D,Rotation: number,PivotPoint: Vector2D,CornerSize: Vector2D): void;
	K2_Deproject(ScreenPosition: Vector2D,WorldOrigin?: Vector,WorldDirection?: Vector): {WorldOrigin: Vector, WorldDirection: Vector};
	static C(Other: UObject | any): Canvas;
}

declare class DebugTextInfo { 
	SrcActor: Actor;
	SrcActorOffset: Vector;
	SrcActorDesiredOffset: Vector;
	DebugText: string;
	TimeRemaining: number;
	Duration: number;
	TextColor: Color;
	bAbsoluteLocation: boolean;
	bKeepAttachedToActor: boolean;
	bDrawShadow: boolean;
	OrigActorLocation: Vector;
	Font: Font;
	FontScale: number;
	clone() : DebugTextInfo;
	static C(Other: UObject | any): DebugTextInfo;
}

declare class HUD extends Actor { 
	PlayerOwner: PlayerController;
	bLostFocusPaused: boolean;
	bShowHUD: boolean;
	bShowDebugInfo: boolean;
	bShowHitBoxDebugInfo: boolean;
	bShowOverlays: boolean;
	bEnableDebugTextShadow: boolean;
	PostRenderedActors: Actor[];
	DebugDisplay: string[];
	ToggledDebugCategories: string[];
	Canvas: Canvas;
	DebugCanvas: Canvas;
	DebugTextList: DebugTextInfo[];
	ShowDebugTargetDesiredClass: UnrealEngineClass;
	ShowDebugTargetActor: Actor;
	static GetDefaultObject(): HUD;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HUD;
	ShowHUD(): void;
	ShowDebugToggleSubCategory(Category: string): void;
	ShowDebugForReticleTargetToggle(DesiredClass: UnrealEngineClass): void;
	ShowDebug(DebugType: string): void;
	RemoveDebugText(SrcActor: Actor,bLeaveDurationText: boolean): void;
	RemoveAllDebugStrings(): void;
	ReceiveHitBoxRelease(BoxName: string): void;
	ReceiveHitBoxEndCursorOver(BoxName: string): void;
	ReceiveHitBoxClick(BoxName: string): void;
	ReceiveHitBoxBeginCursorOver(BoxName: string): void;
	ReceiveDrawHUD(SizeX: number,SizeY: number): void;
	Project(Location: Vector): Vector;
	GetTextSize(Text: string,OutWidth?: number,OutHeight?: number,Font?: Font,Scale?: number): {OutWidth: number, OutHeight: number};
	GetOwningPlayerController(): PlayerController;
	GetOwningPawn(): Pawn;
	GetActorsInSelectionRectangle(ClassFilter: UnrealEngineClass,FirstPoint: Vector2D,SecondPoint: Vector2D,OutActors?: Actor[],bIncludeNonCollidingComponents?: boolean,bActorMustBeFullyEnclosed?: boolean): {OutActors: Actor[]};
	DrawTextureSimple(Texture: Texture,ScreenX: number,ScreenY: number,Scale: number,bScalePosition: boolean): void;
	DrawTexture(Texture: Texture,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,TextureU: number,TextureV: number,TextureUWidth: number,TextureVHeight: number,TintColor: LinearColor,BlendMode: EBlendMode,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	DrawText(Text: string,TextColor: LinearColor,ScreenX: number,ScreenY: number,Font: Font,Scale: number,bScalePosition: boolean): void;
	DrawRect(RectColor: LinearColor,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number): void;
	DrawMaterialTriangle(Material: MaterialInterface,V0_Pos: Vector2D,V1_Pos: Vector2D,V2_Pos: Vector2D,V0_UV: Vector2D,V1_UV: Vector2D,V2_UV: Vector2D,V0_Color: LinearColor,V1_Color: LinearColor,V2_Color: LinearColor): void;
	DrawMaterialSimple(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,Scale: number,bScalePosition: boolean): void;
	DrawMaterial(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,MaterialU: number,MaterialV: number,MaterialUWidth: number,MaterialVHeight: number,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	DrawLine(StartScreenX: number,StartScreenY: number,EndScreenX: number,EndScreenY: number,LineColor: LinearColor,LineThickness: number): void;
	Deproject(ScreenX: number,ScreenY: number,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector};
	AddHitBox(Position: Vector2D,Size: Vector2D,InName: string,bConsumesInput: boolean,Priority: number): void;
	AddDebugText(DebugText: string,SrcActor: Actor,Duration: number,Offset: Vector,DesiredOffset: Vector,TextColor: Color,bSkipOverwriteCheck: boolean,bAbsoluteLocation: boolean,bKeepAttachedToActor: boolean,InFont: Font,FontScale: number,bDrawShadow: boolean): void;
	static C(Other: UObject | any): HUD;
}

declare type ECameraProjectionMode = 'Perspective' | 'Orthographic';
declare var ECameraProjectionMode : { Perspective:'Perspective',Orthographic:'Orthographic', };
declare type EBloomMethod = 'BM_SOG' | 'BM_FFT';
declare var EBloomMethod : { BM_SOG:'BM_SOG',BM_FFT:'BM_FFT', };
declare class TextureCube extends Texture { 
	static Load(ResourceName: string): TextureCube;
	static Find(Outer: UObject, ResourceName: string): TextureCube;
	static GetDefaultObject(): TextureCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCube;
	static C(Other: UObject | any): TextureCube;
}

declare type EAutoExposureMethod = 'AEM_Histogram' | 'AEM_Basic';
declare var EAutoExposureMethod : { AEM_Histogram:'AEM_Histogram',AEM_Basic:'AEM_Basic', };
declare type EDepthOfFieldMethod = 'DOFM_BokehDOF' | 'DOFM_Gaussian' | 'DOFM_CircleDOF';
declare var EDepthOfFieldMethod : { DOFM_BokehDOF:'DOFM_BokehDOF',DOFM_Gaussian:'DOFM_Gaussian',DOFM_CircleDOF:'DOFM_CircleDOF', };
declare class WeightedBlendable { 
	Weight: number;
	UObject: UObject;
	clone() : WeightedBlendable;
	static C(Other: UObject | any): WeightedBlendable;
}

declare class WeightedBlendables { 
	Array: WeightedBlendable[];
	clone() : WeightedBlendables;
	static C(Other: UObject | any): WeightedBlendables;
}

declare class PostProcessSettings { 
	bOverride_WhiteTemp: boolean;
	bOverride_WhiteTint: boolean;
	bOverride_ColorSaturation: boolean;
	bOverride_ColorContrast: boolean;
	bOverride_ColorGamma: boolean;
	bOverride_ColorGain: boolean;
	bOverride_ColorOffset: boolean;
	bOverride_ColorSaturationShadows: boolean;
	bOverride_ColorContrastShadows: boolean;
	bOverride_ColorGammaShadows: boolean;
	bOverride_ColorGainShadows: boolean;
	bOverride_ColorOffsetShadows: boolean;
	bOverride_ColorSaturationMidtones: boolean;
	bOverride_ColorContrastMidtones: boolean;
	bOverride_ColorGammaMidtones: boolean;
	bOverride_ColorGainMidtones: boolean;
	bOverride_ColorOffsetMidtones: boolean;
	bOverride_ColorSaturationHighlights: boolean;
	bOverride_ColorContrastHighlights: boolean;
	bOverride_ColorGammaHighlights: boolean;
	bOverride_ColorGainHighlights: boolean;
	bOverride_ColorOffsetHighlights: boolean;
	bOverride_ColorCorrectionShadowsMax: boolean;
	bOverride_ColorCorrectionHighlightsMin: boolean;
	bOverride_FilmWhitePoint: boolean;
	bOverride_FilmSaturation: boolean;
	bOverride_FilmChannelMixerRed: boolean;
	bOverride_FilmChannelMixerGreen: boolean;
	bOverride_FilmChannelMixerBlue: boolean;
	bOverride_FilmContrast: boolean;
	bOverride_FilmDynamicRange: boolean;
	bOverride_FilmHealAmount: boolean;
	bOverride_FilmToeAmount: boolean;
	bOverride_FilmShadowTint: boolean;
	bOverride_FilmShadowTintBlend: boolean;
	bOverride_FilmShadowTintAmount: boolean;
	bOverride_FilmSlope: boolean;
	bOverride_FilmToe: boolean;
	bOverride_FilmShoulder: boolean;
	bOverride_FilmBlackClip: boolean;
	bOverride_FilmWhiteClip: boolean;
	bOverride_SceneColorTint: boolean;
	bOverride_SceneFringeIntensity: boolean;
	bOverride_AmbientCubemapTint: boolean;
	bOverride_AmbientCubemapIntensity: boolean;
	bOverride_BloomMethod: boolean;
	bOverride_BloomIntensity: boolean;
	bOverride_BloomThreshold: boolean;
	bOverride_Bloom1Tint: boolean;
	bOverride_Bloom1Size: boolean;
	bOverride_Bloom2Size: boolean;
	bOverride_Bloom2Tint: boolean;
	bOverride_Bloom3Tint: boolean;
	bOverride_Bloom3Size: boolean;
	bOverride_Bloom4Tint: boolean;
	bOverride_Bloom4Size: boolean;
	bOverride_Bloom5Tint: boolean;
	bOverride_Bloom5Size: boolean;
	bOverride_Bloom6Tint: boolean;
	bOverride_Bloom6Size: boolean;
	bOverride_BloomSizeScale: boolean;
	bOverride_BloomConvolutionTexture: boolean;
	bOverride_BloomConvolutionSize: boolean;
	bOverride_BloomConvolutionCenterUV: boolean;
	bOverride_BloomConvolutionPreFilter: boolean;
	bOverride_BloomConvolutionPreFilterMin: boolean;
	bOverride_BloomConvolutionPreFilterMax: boolean;
	bOverride_BloomConvolutionPreFilterMult: boolean;
	bOverride_BloomConvolutionBufferScale: boolean;
	bOverride_BloomDirtMaskIntensity: boolean;
	bOverride_BloomDirtMaskTint: boolean;
	bOverride_BloomDirtMask: boolean;
	bOverride_AutoExposureMethod: boolean;
	bOverride_AutoExposureLowPercent: boolean;
	bOverride_AutoExposureHighPercent: boolean;
	bOverride_AutoExposureMinBrightness: boolean;
	bOverride_AutoExposureMaxBrightness: boolean;
	bOverride_AutoExposureSpeedUp: boolean;
	bOverride_AutoExposureSpeedDown: boolean;
	bOverride_AutoExposureBias: boolean;
	bOverride_HistogramLogMin: boolean;
	bOverride_HistogramLogMax: boolean;
	bOverride_LensFlareIntensity: boolean;
	bOverride_LensFlareTint: boolean;
	bOverride_LensFlareTints: boolean;
	bOverride_LensFlareBokehSize: boolean;
	bOverride_LensFlareBokehShape: boolean;
	bOverride_LensFlareThreshold: boolean;
	bOverride_VignetteIntensity: boolean;
	bOverride_GrainIntensity: boolean;
	bOverride_GrainJitter: boolean;
	bOverride_AmbientOcclusionIntensity: boolean;
	bOverride_AmbientOcclusionStaticFraction: boolean;
	bOverride_AmbientOcclusionRadius: boolean;
	bOverride_AmbientOcclusionFadeDistance: boolean;
	bOverride_AmbientOcclusionFadeRadius: boolean;
	bOverride_AmbientOcclusionDistance: boolean;
	bOverride_AmbientOcclusionRadiusInWS: boolean;
	bOverride_AmbientOcclusionPower: boolean;
	bOverride_AmbientOcclusionBias: boolean;
	bOverride_AmbientOcclusionQuality: boolean;
	bOverride_AmbientOcclusionMipBlend: boolean;
	bOverride_AmbientOcclusionMipScale: boolean;
	bOverride_AmbientOcclusionMipThreshold: boolean;
	bOverride_LPVIntensity: boolean;
	bOverride_LPVDirectionalOcclusionIntensity: boolean;
	bOverride_LPVDirectionalOcclusionRadius: boolean;
	bOverride_LPVDiffuseOcclusionExponent: boolean;
	bOverride_LPVSpecularOcclusionExponent: boolean;
	bOverride_LPVDiffuseOcclusionIntensity: boolean;
	bOverride_LPVSpecularOcclusionIntensity: boolean;
	bOverride_LPVSize: boolean;
	bOverride_LPVSecondaryOcclusionIntensity: boolean;
	bOverride_LPVSecondaryBounceIntensity: boolean;
	bOverride_LPVGeometryVolumeBias: boolean;
	bOverride_LPVVplInjectionBias: boolean;
	bOverride_LPVEmissiveInjectionIntensity: boolean;
	bOverride_LPVFadeRange: boolean;
	bOverride_LPVDirectionalOcclusionFadeRange: boolean;
	bOverride_IndirectLightingColor: boolean;
	bOverride_IndirectLightingIntensity: boolean;
	bOverride_ColorGradingIntensity: boolean;
	bOverride_ColorGradingLUT: boolean;
	bOverride_DepthOfFieldFocalDistance: boolean;
	bOverride_DepthOfFieldFstop: boolean;
	bOverride_DepthOfFieldSensorWidth: boolean;
	bOverride_DepthOfFieldDepthBlurRadius: boolean;
	bOverride_DepthOfFieldDepthBlurAmount: boolean;
	bOverride_DepthOfFieldFocalRegion: boolean;
	bOverride_DepthOfFieldNearTransitionRegion: boolean;
	bOverride_DepthOfFieldFarTransitionRegion: boolean;
	bOverride_DepthOfFieldScale: boolean;
	bOverride_DepthOfFieldMaxBokehSize: boolean;
	bOverride_DepthOfFieldNearBlurSize: boolean;
	bOverride_DepthOfFieldFarBlurSize: boolean;
	bOverride_DepthOfFieldMethod: boolean;
	bOverride_MobileHQGaussian: boolean;
	bOverride_DepthOfFieldBokehShape: boolean;
	bOverride_DepthOfFieldOcclusion: boolean;
	bOverride_DepthOfFieldColorThreshold: boolean;
	bOverride_DepthOfFieldSizeThreshold: boolean;
	bOverride_DepthOfFieldSkyFocusDistance: boolean;
	bOverride_DepthOfFieldVignetteSize: boolean;
	bOverride_MotionBlurAmount: boolean;
	bOverride_MotionBlurMax: boolean;
	bOverride_MotionBlurPerObjectSize: boolean;
	bOverride_ScreenPercentage: boolean;
	bOverride_ScreenSpaceReflectionIntensity: boolean;
	bOverride_ScreenSpaceReflectionQuality: boolean;
	bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
	bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
	WhiteTemp: number;
	WhiteTint: number;
	ColorSaturation: Vector4;
	ColorContrast: Vector4;
	ColorGamma: Vector4;
	ColorGain: Vector4;
	ColorOffset: Vector4;
	ColorSaturationShadows: Vector4;
	ColorContrastShadows: Vector4;
	ColorGammaShadows: Vector4;
	ColorGainShadows: Vector4;
	ColorOffsetShadows: Vector4;
	ColorCorrectionShadowsMax: number;
	ColorSaturationMidtones: Vector4;
	ColorContrastMidtones: Vector4;
	ColorGammaMidtones: Vector4;
	ColorGainMidtones: Vector4;
	ColorOffsetMidtones: Vector4;
	ColorSaturationHighlights: Vector4;
	ColorContrastHighlights: Vector4;
	ColorGammaHighlights: Vector4;
	ColorGainHighlights: Vector4;
	ColorOffsetHighlights: Vector4;
	ColorCorrectionHighlightsMin: number;
	FilmSlope: number;
	FilmToe: number;
	FilmShoulder: number;
	FilmBlackClip: number;
	FilmWhiteClip: number;
	FilmWhitePoint: LinearColor;
	FilmShadowTint: LinearColor;
	FilmShadowTintBlend: number;
	FilmShadowTintAmount: number;
	FilmSaturation: number;
	FilmChannelMixerRed: LinearColor;
	FilmChannelMixerGreen: LinearColor;
	FilmChannelMixerBlue: LinearColor;
	FilmContrast: number;
	FilmToeAmount: number;
	FilmHealAmount: number;
	FilmDynamicRange: number;
	SceneColorTint: LinearColor;
	SceneFringeIntensity: number;
	BloomMethod: EBloomMethod;
	BloomIntensity: number;
	BloomThreshold: number;
	BloomSizeScale: number;
	Bloom1Size: number;
	Bloom2Size: number;
	Bloom3Size: number;
	Bloom4Size: number;
	Bloom5Size: number;
	Bloom6Size: number;
	Bloom1Tint: LinearColor;
	Bloom2Tint: LinearColor;
	Bloom3Tint: LinearColor;
	Bloom4Tint: LinearColor;
	Bloom5Tint: LinearColor;
	Bloom6Tint: LinearColor;
	BloomConvolutionTexture: Texture2D;
	BloomConvolutionSize: number;
	BloomConvolutionCenterUV: Vector2D;
	BloomConvolutionPreFilter: Vector;
	BloomConvolutionPreFilterMin: number;
	BloomConvolutionPreFilterMax: number;
	BloomConvolutionPreFilterMult: number;
	BloomConvolutionBufferScale: number;
	BloomDirtMask: Texture;
	BloomDirtMaskIntensity: number;
	BloomDirtMaskTint: LinearColor;
	AmbientCubemapTint: LinearColor;
	AmbientCubemapIntensity: number;
	AmbientCubemap: TextureCube;
	AutoExposureMethod: EAutoExposureMethod;
	AutoExposureLowPercent: number;
	AutoExposureHighPercent: number;
	AutoExposureMinBrightness: number;
	AutoExposureMaxBrightness: number;
	AutoExposureSpeedUp: number;
	AutoExposureSpeedDown: number;
	AutoExposureBias: number;
	HistogramLogMin: number;
	HistogramLogMax: number;
	LensFlareIntensity: number;
	LensFlareTint: LinearColor;
	LensFlareBokehSize: number;
	LensFlareThreshold: number;
	LensFlareBokehShape: Texture;
	LensFlareTints: LinearColor;
	VignetteIntensity: number;
	GrainJitter: number;
	GrainIntensity: number;
	AmbientOcclusionIntensity: number;
	AmbientOcclusionStaticFraction: number;
	AmbientOcclusionRadius: number;
	AmbientOcclusionRadiusInWS: boolean;
	AmbientOcclusionFadeDistance: number;
	AmbientOcclusionFadeRadius: number;
	AmbientOcclusionDistance: number;
	AmbientOcclusionPower: number;
	AmbientOcclusionBias: number;
	AmbientOcclusionQuality: number;
	AmbientOcclusionMipBlend: number;
	AmbientOcclusionMipScale: number;
	AmbientOcclusionMipThreshold: number;
	IndirectLightingColor: LinearColor;
	IndirectLightingIntensity: number;
	ColorGradingIntensity: number;
	ColorGradingLUT: Texture;
	DepthOfFieldMethod: EDepthOfFieldMethod;
	bMobileHQGaussian: boolean;
	DepthOfFieldFstop: number;
	DepthOfFieldSensorWidth: number;
	DepthOfFieldFocalDistance: number;
	DepthOfFieldDepthBlurAmount: number;
	DepthOfFieldDepthBlurRadius: number;
	DepthOfFieldFocalRegion: number;
	DepthOfFieldNearTransitionRegion: number;
	DepthOfFieldFarTransitionRegion: number;
	DepthOfFieldScale: number;
	DepthOfFieldMaxBokehSize: number;
	DepthOfFieldNearBlurSize: number;
	DepthOfFieldFarBlurSize: number;
	DepthOfFieldBokehShape: Texture;
	DepthOfFieldOcclusion: number;
	DepthOfFieldColorThreshold: number;
	DepthOfFieldSizeThreshold: number;
	DepthOfFieldSkyFocusDistance: number;
	DepthOfFieldVignetteSize: number;
	MotionBlurAmount: number;
	MotionBlurMax: number;
	MotionBlurPerObjectSize: number;
	LPVIntensity: number;
	LPVVplInjectionBias: number;
	LPVSize: number;
	LPVSecondaryOcclusionIntensity: number;
	LPVSecondaryBounceIntensity: number;
	LPVGeometryVolumeBias: number;
	LPVEmissiveInjectionIntensity: number;
	LPVDirectionalOcclusionIntensity: number;
	LPVDirectionalOcclusionRadius: number;
	LPVDiffuseOcclusionExponent: number;
	LPVSpecularOcclusionExponent: number;
	LPVDiffuseOcclusionIntensity: number;
	LPVSpecularOcclusionIntensity: number;
	ScreenSpaceReflectionIntensity: number;
	ScreenSpaceReflectionQuality: number;
	ScreenSpaceReflectionMaxRoughness: number;
	LPVFadeRange: number;
	LPVDirectionalOcclusionFadeRange: number;
	ScreenPercentage: number;
	WeightedBlendables: WeightedBlendables;
	Blendables: UObject[];
	clone() : PostProcessSettings;
	static C(Other: UObject | any): PostProcessSettings;
}

declare class MinimalViewInfo { 
	Location: Vector;
	Rotation: Rotator;
	FOV: number;
	OrthoWidth: number;
	OrthoNearClipPlane: number;
	OrthoFarClipPlane: number;
	AspectRatio: number;
	bConstrainAspectRatio: boolean;
	bUseFieldOfViewForLOD: boolean;
	ProjectionMode: ECameraProjectionMode;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	OffCenterProjectionOffset: Vector2D;
	clone() : MinimalViewInfo;
	static C(Other: UObject | any): MinimalViewInfo;
}

declare class CameraCacheEntry { 
	TimeStamp: number;
	POV: MinimalViewInfo;
	clone() : CameraCacheEntry;
	static C(Other: UObject | any): CameraCacheEntry;
}

declare class TViewTarget { 
	Target: Actor;
	POV: MinimalViewInfo;
	PlayerState: PlayerState;
	clone() : TViewTarget;
	static C(Other: UObject | any): TViewTarget;
}

declare class CameraModifier extends UObject { 
	bDebug: boolean;
	bExclusive: boolean;
	Priority: number;
	CameraOwner: PlayerCameraManager;
	AlphaInTime: number;
	AlphaOutTime: number;
	Alpha: number;
	static Load(ResourceName: string): CameraModifier;
	static Find(Outer: UObject, ResourceName: string): CameraModifier;
	static GetDefaultObject(): CameraModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier;
	IsDisabled(): boolean;
	GetViewTarget(): Actor;
	EnableModifier(): void;
	DisableModifier(bImmediate: boolean): void;
	BlueprintModifyPostProcess(DeltaTime: number,PostProcessBlendWeight?: number,PostProcessSettings?: PostProcessSettings): {PostProcessBlendWeight: number, PostProcessSettings: PostProcessSettings};
	BlueprintModifyCamera(DeltaTime: number,ViewLocation: Vector,ViewRotation: Rotator,FOV: number,NewViewLocation?: Vector,NewViewRotation?: Rotator,NewFOV?: number): {NewViewLocation: Vector, NewViewRotation: Rotator, NewFOV: number};
	static C(Other: UObject | any): CameraModifier;
}

declare type EParticleSystemUpdateMode = 'EPSUM_RealTime' | 'EPSUM_FixedTime';
declare var EParticleSystemUpdateMode : { EPSUM_RealTime:'EPSUM_RealTime',EPSUM_FixedTime:'EPSUM_FixedTime', };
declare type EEmitterRenderMode = 'ERM_Normal' | 'ERM_Point' | 'ERM_Cross' | 'ERM_LightsOnly' | 'ERM_None';
declare var EEmitterRenderMode : { ERM_Normal:'ERM_Normal',ERM_Point:'ERM_Point',ERM_Cross:'ERM_Cross',ERM_LightsOnly:'ERM_LightsOnly',ERM_None:'ERM_None', };
declare class ParticleModule extends UObject { 
	bSpawnModule: boolean;
	bUpdateModule: boolean;
	bFinalUpdateModule: boolean;
	bUpdateForGPUEmitter: boolean;
	bCurvesAsColor: boolean;
	b3DDrawMode: boolean;
	bSupported3DDrawMode: boolean;
	bEnabled: boolean;
	bEditable: boolean;
	LODDuplicate: boolean;
	bSupportsRandomSeed: boolean;
	bRequiresLoopingNotification: boolean;
	LODValidity: number;
	ModuleEditorColor: Color;
	static Load(ResourceName: string): ParticleModule;
	static Find(Outer: UObject, ResourceName: string): ParticleModule;
	static GetDefaultObject(): ParticleModule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModule;
	static C(Other: UObject | any): ParticleModule;
}

declare type EParticleScreenAlignment = 'PSA_FacingCameraPosition' | 'PSA_Square' | 'PSA_Rectangle' | 'PSA_Velocity' | 'PSA_AwayFromCenter' | 'PSA_TypeSpecific' | 'PSA_FacingCameraDistanceBlend';
declare var EParticleScreenAlignment : { PSA_FacingCameraPosition:'PSA_FacingCameraPosition',PSA_Square:'PSA_Square',PSA_Rectangle:'PSA_Rectangle',PSA_Velocity:'PSA_Velocity',PSA_AwayFromCenter:'PSA_AwayFromCenter',PSA_TypeSpecific:'PSA_TypeSpecific',PSA_FacingCameraDistanceBlend:'PSA_FacingCameraDistanceBlend', };
declare type EParticleSortMode = 'PSORTMODE_None' | 'PSORTMODE_ViewProjDepth' | 'PSORTMODE_DistanceToView' | 'PSORTMODE_Age_OldestFirst' | 'PSORTMODE_Age_NewestFirst';
declare var EParticleSortMode : { PSORTMODE_None:'PSORTMODE_None',PSORTMODE_ViewProjDepth:'PSORTMODE_ViewProjDepth',PSORTMODE_DistanceToView:'PSORTMODE_DistanceToView',PSORTMODE_Age_OldestFirst:'PSORTMODE_Age_OldestFirst',PSORTMODE_Age_NewestFirst:'PSORTMODE_Age_NewestFirst', };
declare class DistributionLookupTable { 
	Op: number;
	EntryCount: number;
	EntryStride: number;
	SubEntryStride: number;
	TimeScale: number;
	TimeBias: number;
	Values: number[];
	LockFlag: number;
	clone() : DistributionLookupTable;
	static C(Other: UObject | any): DistributionLookupTable;
}

declare class RawDistribution { 
	Table: DistributionLookupTable;
	clone() : RawDistribution;
	static C(Other: UObject | any): RawDistribution;
}

declare class Distribution extends UObject { 
	static Load(ResourceName: string): Distribution;
	static Find(Outer: UObject, ResourceName: string): Distribution;
	static GetDefaultObject(): Distribution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Distribution;
	static C(Other: UObject | any): Distribution;
}

declare class DistributionFloat extends Distribution { 
	bCanBeBaked: boolean;
	bBakedDataSuccesfully: boolean;
	static Load(ResourceName: string): DistributionFloat;
	static Find(Outer: UObject, ResourceName: string): DistributionFloat;
	static GetDefaultObject(): DistributionFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloat;
	static C(Other: UObject | any): DistributionFloat;
}

declare class RawDistributionFloat extends RawDistribution { 
	MinValue: number;
	MaxValue: number;
	Distribution: DistributionFloat;
	clone() : RawDistributionFloat;
	static C(Other: UObject | any): RawDistributionFloat;
}

declare type EParticleBurstMethod = 'EPBM_Instant' | 'EPBM_Interpolated';
declare var EParticleBurstMethod : { EPBM_Instant:'EPBM_Instant',EPBM_Interpolated:'EPBM_Interpolated', };
declare class ParticleBurst { 
	Count: number;
	CountLow: number;
	Time: number;
	clone() : ParticleBurst;
	static C(Other: UObject | any): ParticleBurst;
}

declare type EParticleSubUVInterpMethod = 'PSUVIM_None' | 'PSUVIM_Linear' | 'PSUVIM_Linear_Blend' | 'PSUVIM_Random' | 'PSUVIM_Random_Blend';
declare var EParticleSubUVInterpMethod : { PSUVIM_None:'PSUVIM_None',PSUVIM_Linear:'PSUVIM_Linear',PSUVIM_Linear_Blend:'PSUVIM_Linear_Blend',PSUVIM_Random:'PSUVIM_Random',PSUVIM_Random_Blend:'PSUVIM_Random_Blend', };
declare type EParticleUVFlipMode = 'None' | 'FlipUV' | 'FlipUOnly' | 'FlipVOnly' | 'RandomFlipUV' | 'RandomFlipUOnly' | 'RandomFlipVOnly' | 'RandomFlipUVIndependent';
declare var EParticleUVFlipMode : { None:'None',FlipUV:'FlipUV',FlipUOnly:'FlipUOnly',FlipVOnly:'FlipVOnly',RandomFlipUV:'RandomFlipUV',RandomFlipUOnly:'RandomFlipUOnly',RandomFlipVOnly:'RandomFlipVOnly',RandomFlipUVIndependent:'RandomFlipUVIndependent', };
declare type ESubUVBoundingVertexCount = 'BVC_FourVertices' | 'BVC_EightVertices';
declare var ESubUVBoundingVertexCount : { BVC_FourVertices:'BVC_FourVertices',BVC_EightVertices:'BVC_EightVertices', };
declare type EOpacitySourceMode = 'OSM_Alpha' | 'OSM_ColorBrightness' | 'OSM_RedChannel' | 'OSM_GreenChannel' | 'OSM_BlueChannel';
declare var EOpacitySourceMode : { OSM_Alpha:'OSM_Alpha',OSM_ColorBrightness:'OSM_ColorBrightness',OSM_RedChannel:'OSM_RedChannel',OSM_GreenChannel:'OSM_GreenChannel',OSM_BlueChannel:'OSM_BlueChannel', };
declare type EEmitterNormalsMode = 'ENM_CameraFacing' | 'ENM_Spherical' | 'ENM_Cylindrical';
declare var EEmitterNormalsMode : { ENM_CameraFacing:'ENM_CameraFacing',ENM_Spherical:'ENM_Spherical',ENM_Cylindrical:'ENM_Cylindrical', };
declare class ParticleModuleRequired extends ParticleModule { 
	Material: MaterialInterface;
	EmitterOrigin: Vector;
	EmitterRotation: Rotator;
	ScreenAlignment: EParticleScreenAlignment;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	bUseLocalSpace: boolean;
	bKillOnDeactivate: boolean;
	bKillOnCompleted: boolean;
	SortMode: EParticleSortMode;
	bUseLegacyEmitterTime: boolean;
	bRemoveHMDRoll: boolean;
	EmitterDuration: number;
	EmitterDurationLow: number;
	bEmitterDurationUseRange: boolean;
	bDurationRecalcEachLoop: boolean;
	EmitterLoops: number;
	SpawnRate: RawDistributionFloat;
	ParticleBurstMethod: EParticleBurstMethod;
	BurstList: ParticleBurst[];
	EmitterDelay: number;
	EmitterDelayLow: number;
	bEmitterDelayUseRange: boolean;
	bDelayFirstLoopOnly: boolean;
	InterpolationMethod: EParticleSubUVInterpMethod;
	SubImages_Horizontal: number;
	SubImages_Vertical: number;
	bScaleUV: boolean;
	RandomImageTime: number;
	RandomImageChanges: number;
	bOverrideSystemMacroUV: boolean;
	MacroUVPosition: Vector;
	MacroUVRadius: number;
	bUseMaxDrawCount: boolean;
	MaxDrawCount: number;
	UVFlippingMode: UVFlippingMode;
	CutoutTexture: Texture2D;
	BoundingMode: ESubUVBoundingVertexCount;
	OpacitySourceMode: EOpacitySourceMode;
	AlphaThreshold: number;
	EmitterNormalsMode: EEmitterNormalsMode;
	NormalsSphereCenter: Vector;
	NormalsCylinderDirection: Vector;
	bOrbitModuleAffectsVelocityAlignment: boolean;
	NamedMaterialOverrides: string[];
	static Load(ResourceName: string): ParticleModuleRequired;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRequired;
	static GetDefaultObject(): ParticleModuleRequired;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRequired;
	static C(Other: UObject | any): ParticleModuleRequired;
}

declare class ParticleModuleTypeDataBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleTypeDataBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataBase;
	static GetDefaultObject(): ParticleModuleTypeDataBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataBase;
	static C(Other: UObject | any): ParticleModuleTypeDataBase;
}

declare class ParticleModuleSpawnBase extends ParticleModule { 
	bProcessSpawnRate: boolean;
	bProcessBurstList: boolean;
	static Load(ResourceName: string): ParticleModuleSpawnBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawnBase;
	static GetDefaultObject(): ParticleModuleSpawnBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnBase;
	static C(Other: UObject | any): ParticleModuleSpawnBase;
}

declare class ParticleModuleSpawn extends ParticleModuleSpawnBase { 
	Rate: RawDistributionFloat;
	RateScale: RawDistributionFloat;
	ParticleBurstMethod: EParticleBurstMethod;
	BurstList: ParticleBurst[];
	BurstScale: RawDistributionFloat;
	bApplyGlobalSpawnRateScale: boolean;
	static Load(ResourceName: string): ParticleModuleSpawn;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawn;
	static GetDefaultObject(): ParticleModuleSpawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawn;
	static C(Other: UObject | any): ParticleModuleSpawn;
}

declare class ParticleModuleEventBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleEventBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventBase;
	static GetDefaultObject(): ParticleModuleEventBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventBase;
	static C(Other: UObject | any): ParticleModuleEventBase;
}

declare type EParticleEventType = 'EPET_Any' | 'EPET_Spawn' | 'EPET_Death' | 'EPET_Collision' | 'EPET_Burst' | 'EPET_Blueprint';
declare var EParticleEventType : { EPET_Any:'EPET_Any',EPET_Spawn:'EPET_Spawn',EPET_Death:'EPET_Death',EPET_Collision:'EPET_Collision',EPET_Burst:'EPET_Burst',EPET_Blueprint:'EPET_Blueprint', };
declare class ParticleModuleEventSendToGame extends UObject { 
	static Load(ResourceName: string): ParticleModuleEventSendToGame;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventSendToGame;
	static GetDefaultObject(): ParticleModuleEventSendToGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventSendToGame;
	static C(Other: UObject | any): ParticleModuleEventSendToGame;
}

declare class ParticleEvent_GenerateInfo { 
	Type: EParticleEventType;
	Frequency: number;
	ParticleFrequency: number;
	FirstTimeOnly: boolean;
	LastTimeOnly: boolean;
	UseReflectedImpactVector: boolean;
	bUseOrbitOffset: boolean;
	CustomName: string;
	ParticleModuleEventsToSendToGame: ParticleModuleEventSendToGame[];
	clone() : ParticleEvent_GenerateInfo;
	static C(Other: UObject | any): ParticleEvent_GenerateInfo;
}

declare class ParticleModuleEventGenerator extends ParticleModuleEventBase { 
	Events: ParticleEvent_GenerateInfo[];
	static Load(ResourceName: string): ParticleModuleEventGenerator;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventGenerator;
	static GetDefaultObject(): ParticleModuleEventGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventGenerator;
	static C(Other: UObject | any): ParticleModuleEventGenerator;
}

declare class ParticleModuleOrbitBase extends ParticleModule { 
	bUseEmitterTime: boolean;
	static Load(ResourceName: string): ParticleModuleOrbitBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrbitBase;
	static GetDefaultObject(): ParticleModuleOrbitBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbitBase;
	static C(Other: UObject | any): ParticleModuleOrbitBase;
}

declare type EOrbitChainMode = 'EOChainMode_Add' | 'EOChainMode_Scale' | 'EOChainMode_Link';
declare var EOrbitChainMode : { EOChainMode_Add:'EOChainMode_Add',EOChainMode_Scale:'EOChainMode_Scale',EOChainMode_Link:'EOChainMode_Link', };
declare class DistributionVector extends Distribution { 
	bCanBeBaked: boolean;
	bIsDirty: boolean;
	bBakedDataSuccesfully: boolean;
	static Load(ResourceName: string): DistributionVector;
	static Find(Outer: UObject, ResourceName: string): DistributionVector;
	static GetDefaultObject(): DistributionVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVector;
	static C(Other: UObject | any): DistributionVector;
}

declare class RawDistributionVector extends RawDistribution { 
	MinValue: number;
	MaxValue: number;
	MinValueVec: Vector;
	MaxValueVec: Vector;
	Distribution: DistributionVector;
	clone() : RawDistributionVector;
	static C(Other: UObject | any): RawDistributionVector;
}

declare class OrbitOptions { 
	bProcessDuringSpawn: boolean;
	bProcessDuringUpdate: boolean;
	bUseEmitterTime: boolean;
	clone() : OrbitOptions;
	static C(Other: UObject | any): OrbitOptions;
}

declare class ParticleModuleOrbit extends ParticleModuleOrbitBase { 
	ChainMode: EOrbitChainMode;
	OffsetAmount: RawDistributionVector;
	OffsetOptions: OrbitOptions;
	RotationAmount: RawDistributionVector;
	RotationOptions: OrbitOptions;
	RotationRateAmount: RawDistributionVector;
	RotationRateOptions: OrbitOptions;
	static Load(ResourceName: string): ParticleModuleOrbit;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrbit;
	static GetDefaultObject(): ParticleModuleOrbit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbit;
	static C(Other: UObject | any): ParticleModuleOrbit;
}

declare class ParticleModuleEventReceiverBase extends ParticleModuleEventBase { 
	EventGeneratorType: EParticleEventType;
	EventName: string;
	static Load(ResourceName: string): ParticleModuleEventReceiverBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverBase;
	static GetDefaultObject(): ParticleModuleEventReceiverBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverBase;
	static C(Other: UObject | any): ParticleModuleEventReceiverBase;
}

declare class ParticleLODLevel extends UObject { 
	Level: number;
	bEnabled: boolean;
	RequiredModule: ParticleModuleRequired;
	Modules: ParticleModule[];
	TypeDataModule: ParticleModuleTypeDataBase;
	SpawnModule: ParticleModuleSpawn;
	EventGenerator: ParticleModuleEventGenerator;
	SpawningModules: ParticleModuleSpawnBase[];
	SpawnModules: ParticleModule[];
	UpdateModules: ParticleModule[];
	OrbitModules: ParticleModuleOrbit[];
	EventReceiverModules: ParticleModuleEventReceiverBase[];
	ConvertedModules: boolean;
	PeakActiveParticles: number;
	static Load(ResourceName: string): ParticleLODLevel;
	static Find(Outer: UObject, ResourceName: string): ParticleLODLevel;
	static GetDefaultObject(): ParticleLODLevel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleLODLevel;
	static C(Other: UObject | any): ParticleLODLevel;
}

declare type EParticleSignificanceLevel = 'Low' | 'Medium' | 'High' | 'Critical' | 'Num';
declare var EParticleSignificanceLevel : { Low:'Low',Medium:'Medium',High:'High',Critical:'Critical',Num:'Num', };
declare class ParticleEmitter extends UObject { 
	EmitterName: string;
	SubUVDataOffset: number;
	EmitterRenderMode: EEmitterRenderMode;
	EmitterEditorColor: Color;
	LODLevels: ParticleLODLevel[];
	ConvertedModules: boolean;
	PeakActiveParticles: number;
	InitialAllocationCount: number;
	MediumDetailSpawnRateScale: number;
	QualityLevelSpawnRateScale: number;
	DetailMode: EDetailMode;
	bCollapsed: boolean;
	bIsSoloing: boolean;
	bCookedOut: boolean;
	bDisabledLODsKeepEmitterAlive: boolean;
	bDisableWhenInsignficant: boolean;
	SignificanceLevel: SignificanceLevel;
	static Load(ResourceName: string): ParticleEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleEmitter;
	static GetDefaultObject(): ParticleEmitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEmitter;
	static C(Other: UObject | any): ParticleEmitter;
}

declare class CurveEdEntry { 
	CurveObject: UObject;
	CurveColor: Color;
	CurveName: string;
	bHideCurve: number;
	bColorCurve: number;
	bFloatingPointColorCurve: number;
	bClamp: number;
	ClampLow: number;
	ClampHigh: number;
	clone() : CurveEdEntry;
	static C(Other: UObject | any): CurveEdEntry;
}

declare class CurveEdTab { 
	TabName: string;
	Curves: CurveEdEntry[];
	ViewStartInput: number;
	ViewEndInput: number;
	ViewStartOutput: number;
	ViewEndOutput: number;
	clone() : CurveEdTab;
	static C(Other: UObject | any): CurveEdTab;
}

declare class InterpCurveEdSetup extends UObject { 
	Tabs: CurveEdTab[];
	ActiveTab: number;
	static Load(ResourceName: string): InterpCurveEdSetup;
	static Find(Outer: UObject, ResourceName: string): InterpCurveEdSetup;
	static GetDefaultObject(): InterpCurveEdSetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpCurveEdSetup;
	static C(Other: UObject | any): InterpCurveEdSetup;
}

declare type ParticleSystemLODMethod = 'PARTICLESYSTEMLODMETHOD_Automatic' | 'PARTICLESYSTEMLODMETHOD_DirectSet' | 'PARTICLESYSTEMLODMETHOD_ActivateAutomatic';
declare var ParticleSystemLODMethod : { PARTICLESYSTEMLODMETHOD_Automatic:'PARTICLESYSTEMLODMETHOD_Automatic',PARTICLESYSTEMLODMETHOD_DirectSet:'PARTICLESYSTEMLODMETHOD_DirectSet',PARTICLESYSTEMLODMETHOD_ActivateAutomatic:'PARTICLESYSTEMLODMETHOD_ActivateAutomatic', };
declare class ParticleSystemLOD { 
	clone() : ParticleSystemLOD;
	static C(Other: UObject | any): ParticleSystemLOD;
}

declare type EParticleSystemInsignificanceReaction = 'Auto' | 'Complete' | 'DisableTick' | 'DisableTickAndKill' | 'Num';
declare var EParticleSystemInsignificanceReaction : { Auto:'Auto',Complete:'Complete',DisableTick:'DisableTick',DisableTickAndKill:'DisableTickAndKill',Num:'Num', };
declare type EParticleSystemOcclusionBoundsMethod = 'EPSOBM_None' | 'EPSOBM_ParticleBounds' | 'EPSOBM_CustomBounds';
declare var EParticleSystemOcclusionBoundsMethod : { EPSOBM_None:'EPSOBM_None',EPSOBM_ParticleBounds:'EPSOBM_ParticleBounds',EPSOBM_CustomBounds:'EPSOBM_CustomBounds', };
declare class LODSoloTrack { 
	SoloEnableSetting: number[];
	clone() : LODSoloTrack;
	static C(Other: UObject | any): LODSoloTrack;
}

declare class NamedEmitterMaterial { 
	Name: string;
	Material: MaterialInterface;
	clone() : NamedEmitterMaterial;
	static C(Other: UObject | any): NamedEmitterMaterial;
}

declare class ParticleSystem extends UObject { 
	SystemUpdateMode: EParticleSystemUpdateMode;
	UpdateTime_FPS: number;
	UpdateTime_Delta: number;
	WarmupTime: number;
	WarmupTickRate: number;
	Emitters: ParticleEmitter[];
	PreviewComponent: ParticleSystemComponent;
	ThumbnailAngle: Rotator;
	ThumbnailDistance: number;
	ThumbnailWarmup: number;
	CurveEdSetup: InterpCurveEdSetup;
	bOrientZAxisTowardCamera: boolean;
	LODDistanceCheckTime: number;
	LODMethod: ParticleSystemLODMethod;
	LODDistances: number[];
	EditorLODSetting: number;
	bRegenerateLODDuplicate: boolean;
	LODSettings: ParticleSystemLOD[];
	bUseFixedRelativeBoundingBox: boolean;
	FixedRelativeBoundingBox: Box;
	SecondsBeforeInactive: number;
	FloorMesh: string;
	FloorPosition: Vector;
	FloorRotation: Rotator;
	FloorScale: number;
	FloorScale3D: Vector;
	BackgroundColor: Color;
	bShouldResetPeakCounts: boolean;
	bHasPhysics: boolean;
	bUseRealtimeThumbnail: boolean;
	ThumbnailImageOutOfDate: boolean;
	ThumbnailImage: Texture2D;
	Delay: number;
	DelayLow: number;
	bUseDelayRange: boolean;
	bAutoDeactivate: boolean;
	MinTimeBetweenTicks: any;
	InsignificantReaction: InsignificantReaction;
	InsignificanceDelay: number;
	MaxSignificanceLevel: MaxSignificanceLevel;
	MacroUVPosition: Vector;
	MacroUVRadius: number;
	OcclusionBoundsMethod: EParticleSystemOcclusionBoundsMethod;
	CustomOcclusionBounds: Box;
	SoloTracking: LODSoloTrack[];
	NamedMaterialSlots: NamedEmitterMaterial[];
	static Load(ResourceName: string): ParticleSystem;
	static Find(Outer: UObject, ResourceName: string): ParticleSystem;
	static GetDefaultObject(): ParticleSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystem;
	ContainsEmitterType(TypeData: UnrealEngineClass): boolean;
	static C(Other: UObject | any): ParticleSystem;
	SpawnEmitterAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,Scale: Vector,LocationType: EAttachLocation,bAutoDestroy: boolean): ParticleSystemComponent;
	static SpawnEmitterAttached(EmitterTemplate: ParticleSystem,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,Scale: Vector,LocationType: EAttachLocation,bAutoDestroy: boolean): ParticleSystemComponent;
}

declare type EParticleSysParamType = 'PSPT_None' | 'PSPT_Scalar' | 'PSPT_ScalarRand' | 'PSPT_Vector' | 'PSPT_VectorRand' | 'PSPT_Color' | 'PSPT_Actor' | 'PSPT_Material';
declare var EParticleSysParamType : { PSPT_None:'PSPT_None',PSPT_Scalar:'PSPT_Scalar',PSPT_ScalarRand:'PSPT_ScalarRand',PSPT_Vector:'PSPT_Vector',PSPT_VectorRand:'PSPT_VectorRand',PSPT_Color:'PSPT_Color',PSPT_Actor:'PSPT_Actor',PSPT_Material:'PSPT_Material', };
declare class ParticleSysParam { 
	Name: string;
	ParamType: EParticleSysParamType;
	Scalar: number;
	Scalar_Low: number;
	Vector: Vector;
	Vector_Low: Vector;
	Color: Color;
	Actor: Actor;
	Material: MaterialInterface;
	clone() : ParticleSysParam;
	static C(Other: UObject | any): ParticleSysParam;
}

declare class ParticleSystemReplay extends UObject { 
	ClipIDNumber: number;
	static Load(ResourceName: string): ParticleSystemReplay;
	static Find(Outer: UObject, ResourceName: string): ParticleSystemReplay;
	static GetDefaultObject(): ParticleSystemReplay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemReplay;
	static C(Other: UObject | any): ParticleSystemReplay;
}

declare type EAttachmentRule = 'KeepRelative' | 'KeepWorld' | 'SnapToTarget';
declare var EAttachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',SnapToTarget:'SnapToTarget', };
declare type ETrailWidthMode = 'ETrailWidthMode_FromCentre' | 'ETrailWidthMode_FromFirst' | 'ETrailWidthMode_FromSecond';
declare var ETrailWidthMode : { ETrailWidthMode_FromCentre:'ETrailWidthMode_FromCentre',ETrailWidthMode_FromFirst:'ETrailWidthMode_FromFirst',ETrailWidthMode_FromSecond:'ETrailWidthMode_FromSecond', };
declare class ParticleSystemComponent extends PrimitiveComponent { 
	Template: ParticleSystem;
	EmitterMaterials: MaterialInterface[];
	SkelMeshComponents: SkeletalMeshComponent[];
	bResetOnDetach: boolean;
	bUpdateOnDedicatedServer: boolean;
	bAllowRecycling: boolean;
	bAutoManageAttachment: boolean;
	bWarmingUp: boolean;
	bOverrideLODMethod: boolean;
	bSkipUpdateDynamicDataDuringTick: boolean;
	LODMethod: ParticleSystemLODMethod;
	RequiredSignificance: RequiredSignificance;
	InstanceParameters: ParticleSysParam[];
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
	OldPosition: Vector;
	PartSysVelocity: Vector;
	WarmupTime: number;
	WarmupTickRate: number;
	SecondsBeforeInactive: number;
	MaxTimeBeforeForceUpdateTransform: number;
	EditorLODLevel: number;
	EditorDetailMode: number;
	ReplayClips: ParticleSystemReplay[];
	CustomTimeDilation: number;
	AutoAttachParent: any;
	AutoAttachSocketName: string;
	AutoAttachLocationType: EAttachLocation;
	AutoAttachLocationRule: AutoAttachLocationRule;
	AutoAttachRotationRule: AutoAttachRotationRule;
	AutoAttachScaleRule: AutoAttachScaleRule;
	OnSystemFinished: UnrealEngineMulticastDelegate<(PSystem: ParticleSystemComponent) => void>;
	static Load(ResourceName: string): ParticleSystemComponent;
	static Find(Outer: UObject, ResourceName: string): ParticleSystemComponent;
	static GetDefaultObject(): ParticleSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemComponent;
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	SetTrailSourceData(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	SetTemplate(NewTemplate: ParticleSystem): void;
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	SetFloatParameter(ParameterName: string,Param: number): void;
	SetEmitterEnable(EmitterName: string,bNewEnableState: boolean): void;
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	SetBeamTargetTangent(EmitterIndex: number,NewTangentPoint: Vector,TargetIndex: number): void;
	SetBeamTargetStrength(EmitterIndex: number,NewTargetStrength: number,TargetIndex: number): void;
	SetBeamTargetPoint(EmitterIndex: number,NewTargetPoint: Vector,TargetIndex: number): void;
	SetBeamSourceTangent(EmitterIndex: number,NewTangentPoint: Vector,SourceIndex: number): void;
	SetBeamSourceStrength(EmitterIndex: number,NewSourceStrength: number,SourceIndex: number): void;
	SetBeamSourcePoint(EmitterIndex: number,NewSourcePoint: Vector,SourceIndex: number): void;
	SetBeamEndPoint(EmitterIndex: number,NewEndPoint: Vector): void;
	SetAutoAttachParams(Parent: SceneComponent,SocketName: string,LocationType: EAttachLocation): void;
	SetAutoAttachmentParameters(Parent: SceneComponent,SocketName: string,LocationRule: LocationRule,RotationRule: RotationRule,ScaleRule: ScaleRule): void;
	SetActorParameter(ParameterName: string,Param: Actor): void;
	GetNumActiveParticles(): number;
	GetNamedMaterial(InName: string): MaterialInterface;
	GetBeamTargetTangent(EmitterIndex: number,TargetIndex: number,OutTangentPoint?: Vector): {OutTangentPoint: Vector, $: boolean};
	GetBeamTargetStrength(EmitterIndex: number,TargetIndex: number,OutTargetStrength?: number): {OutTargetStrength: number, $: boolean};
	GetBeamTargetPoint(EmitterIndex: number,TargetIndex: number,OutTargetPoint?: Vector): {OutTargetPoint: Vector, $: boolean};
	GetBeamSourceTangent(EmitterIndex: number,SourceIndex: number,OutTangentPoint?: Vector): {OutTangentPoint: Vector, $: boolean};
	GetBeamSourceStrength(EmitterIndex: number,SourceIndex: number,OutSourceStrength?: number): {OutSourceStrength: number, $: boolean};
	GetBeamSourcePoint(EmitterIndex: number,SourceIndex: number,OutSourcePoint?: Vector): {OutSourcePoint: Vector, $: boolean};
	GetBeamEndPoint(EmitterIndex: number,OutEndPoint?: Vector): {OutEndPoint: Vector, $: boolean};
	GenerateParticleEvent(InEventName: string,InEmitterTime: number,InLocation: Vector,InDirection: Vector,InVelocity: Vector): void;
	EndTrails(): void;
	CreateNamedDynamicMaterialInstance(InName: string,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	BeginTrails(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	static C(Other: UObject | any): ParticleSystemComponent;
}

declare class Emitter extends Actor { 
	ParticleSystemComponent: ParticleSystemComponent;
	bDestroyOnSystemFinish: boolean;
	bPostUpdateTickGroup: boolean;
	bCurrentlyActive: boolean;
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): Emitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Emitter;
	ToggleActive(): void;
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	SetTemplate(NewTemplate: ParticleSystem): void;
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	SetFloatParameter(ParameterName: string,Param: number): void;
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	SetActorParameter(ParameterName: string,Param: Actor): void;
	OnRep_bCurrentlyActive(): void;
	OnParticleSystemFinished(FinishedComponent: ParticleSystemComponent): void;
	IsActive(): boolean;
	Deactivate(): void;
	Activate(): void;
	static C(Other: UObject | any): Emitter;
}

declare class EmitterCameraLensEffectBase extends Emitter { 
	PS_CameraEffect: ParticleSystem;
	PS_CameraEffectNonExtremeContent: ParticleSystem;
	BaseCamera: PlayerCameraManager;
	RelativeTransform: Transform;
	BaseFOV: number;
	bAllowMultipleInstances: boolean;
	bResetWhenRetriggered: boolean;
	EmittersToTreatAsSame: UnrealEngineClass[];
	DistFromCamera: number;
	static GetDefaultObject(): EmitterCameraLensEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EmitterCameraLensEffectBase;
	static C(Other: UObject | any): EmitterCameraLensEffectBase;
}

declare type EInitialOscillatorOffset = 'EOO_OffsetRandom' | 'EOO_OffsetZero';
declare var EInitialOscillatorOffset : { EOO_OffsetRandom:'EOO_OffsetRandom',EOO_OffsetZero:'EOO_OffsetZero', };
declare class FOscillator { 
	Amplitude: number;
	Frequency: number;
	InitialOffset: EInitialOscillatorOffset;
	clone() : FOscillator;
	static C(Other: UObject | any): FOscillator;
}

declare class ROscillator { 
	Pitch: FOscillator;
	Yaw: FOscillator;
	Roll: FOscillator;
	clone() : ROscillator;
	static C(Other: UObject | any): ROscillator;
}

declare class VOscillator { 
	X: FOscillator;
	Y: FOscillator;
	Z: FOscillator;
	clone() : VOscillator;
	static C(Other: UObject | any): VOscillator;
}

declare class SubTrackGroup { 
	GroupName: string;
	TrackIndices: number[];
	bIsCollapsed: boolean;
	bIsSelected: boolean;
	clone() : SubTrackGroup;
	static C(Other: UObject | any): SubTrackGroup;
}

declare class SupportedSubTrackInfo { 
	SupportedClass: UnrealEngineClass;
	SubTrackName: string;
	GroupIndex: number;
	clone() : SupportedSubTrackInfo;
	static C(Other: UObject | any): SupportedSubTrackInfo;
}

declare type ETrackActiveCondition = 'ETAC_Always' | 'ETAC_GoreEnabled' | 'ETAC_GoreDisabled';
declare var ETrackActiveCondition : { ETAC_Always:'ETAC_Always',ETAC_GoreEnabled:'ETAC_GoreEnabled',ETAC_GoreDisabled:'ETAC_GoreDisabled', };
declare class InterpTrack extends UObject { 
	SubTracks: InterpTrack[];
	SubTrackGroups: SubTrackGroup[];
	SupportedSubTracks: SupportedSubTrackInfo[];
	TrackInstClass: UnrealEngineClass;
	ActiveCondition: ETrackActiveCondition;
	TrackTitle: string;
	bOnePerGroup: boolean;
	bDirGroupOnly: boolean;
	bDisableTrack: boolean;
	bIsSelected: boolean;
	TrackIcon: Texture2D;
	bIsAnimControlTrack: boolean;
	bSubTrackOnly: boolean;
	bVisible: boolean;
	bIsRecording: boolean;
	bIsCollapsed: boolean;
	static Load(ResourceName: string): InterpTrack;
	static Find(Outer: UObject, ResourceName: string): InterpTrack;
	static GetDefaultObject(): InterpTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrack;
	static C(Other: UObject | any): InterpTrack;
}

declare class InterpGroup extends UObject { 
	InterpTracks: InterpTrack[];
	GroupName: string;
	GroupColor: Color;
	bCollapsed: boolean;
	bVisible: boolean;
	bIsFolder: boolean;
	bIsParented: boolean;
	bIsSelected: boolean;
	static Load(ResourceName: string): InterpGroup;
	static Find(Outer: UObject, ResourceName: string): InterpGroup;
	static GetDefaultObject(): InterpGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroup;
	static C(Other: UObject | any): InterpGroup;
}

declare class CameraAnim extends UObject { 
	CameraInterpGroup: InterpGroup;
	PreviewInterpGroup: InterpGroup;
	AnimLength: number;
	BoundingBox: Box;
	bRelativeToInitialTransform: boolean;
	bRelativeToInitialFOV: boolean;
	BaseFOV: number;
	BasePostProcessSettings: PostProcessSettings;
	BasePostProcessBlendWeight: number;
	static Load(ResourceName: string): CameraAnim;
	static Find(Outer: UObject, ResourceName: string): CameraAnim;
	static GetDefaultObject(): CameraAnim;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnim;
	static C(Other: UObject | any): CameraAnim;
}

declare class InterpGroupInst extends UObject { 
	Group: InterpGroup;
	GroupActor: Actor;
	TrackInst: InterpTrackInst[];
	static Load(ResourceName: string): InterpGroupInst;
	static Find(Outer: UObject, ResourceName: string): InterpGroupInst;
	static GetDefaultObject(): InterpGroupInst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupInst;
	static C(Other: UObject | any): InterpGroupInst;
}

declare type EInterpCurveMode = 'CIM_Linear' | 'CIM_CurveAuto' | 'CIM_Constant' | 'CIM_CurveUser' | 'CIM_CurveBreak' | 'CIM_CurveAutoClamped';
declare var EInterpCurveMode : { CIM_Linear:'CIM_Linear',CIM_CurveAuto:'CIM_CurveAuto',CIM_Constant:'CIM_Constant',CIM_CurveUser:'CIM_CurveUser',CIM_CurveBreak:'CIM_CurveBreak',CIM_CurveAutoClamped:'CIM_CurveAutoClamped', };
declare class InterpCurvePointVector { 
	InVal: number;
	OutVal: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointVector;
	static C(Other: UObject | any): InterpCurvePointVector;
}

declare class InterpCurveVector { 
	Points: InterpCurvePointVector[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveVector;
	static C(Other: UObject | any): InterpCurveVector;
}

declare class InterpLookupPoint { 
	GroupName: string;
	Time: number;
	clone() : InterpLookupPoint;
	static C(Other: UObject | any): InterpLookupPoint;
}

declare class InterpLookupTrack { 
	Points: InterpLookupPoint[];
	clone() : InterpLookupTrack;
	static C(Other: UObject | any): InterpLookupTrack;
}

declare type EInterpTrackMoveRotMode = 'IMR_Keyframed' | 'IMR_LookAtGroup' | 'IMR_Ignore';
declare var EInterpTrackMoveRotMode : { IMR_Keyframed:'IMR_Keyframed',IMR_LookAtGroup:'IMR_LookAtGroup',IMR_Ignore:'IMR_Ignore', };
declare class InterpTrackMove extends InterpTrack { 
	PosTrack: InterpCurveVector;
	EulerTrack: InterpCurveVector;
	LookupTrack: InterpLookupTrack;
	LookAtGroupName: string;
	LinCurveTension: number;
	AngCurveTension: number;
	bUseQuatInterpolation: boolean;
	bShowArrowAtKeys: boolean;
	bDisableMovement: boolean;
	bShowTranslationOnCurveEd: boolean;
	bShowRotationOnCurveEd: boolean;
	bHide3DTrack: boolean;
	RotMode: EInterpTrackMoveRotMode;
	static Load(ResourceName: string): InterpTrackMove;
	static Find(Outer: UObject, ResourceName: string): InterpTrackMove;
	static GetDefaultObject(): InterpTrackMove;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackMove;
	static C(Other: UObject | any): InterpTrackMove;
}

declare class InterpTrackInstMove extends InterpTrackInst { 
	ResetLocation: Vector;
	ResetRotation: Rotator;
	static Load(ResourceName: string): InterpTrackInstMove;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstMove;
	static GetDefaultObject(): InterpTrackInstMove;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstMove;
	static C(Other: UObject | any): InterpTrackInstMove;
}

declare type ECameraAnimPlaySpace = 'CameraLocal' | 'World' | 'UserDefined';
declare var ECameraAnimPlaySpace : { CameraLocal:'CameraLocal',World:'World',UserDefined:'UserDefined', };
declare class CameraAnimInst extends UObject { 
	CamAnim: CameraAnim;
	InterpGroupInst: InterpGroupInst;
	PlayRate: number;
	MoveTrack: InterpTrackMove;
	MoveInst: InterpTrackInstMove;
	PlaySpace: ECameraAnimPlaySpace;
	static Load(ResourceName: string): CameraAnimInst;
	static Find(Outer: UObject, ResourceName: string): CameraAnimInst;
	static GetDefaultObject(): CameraAnimInst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimInst;
	Stop(bImmediate: boolean): void;
	SetScale(NewDuration: number): void;
	SetDuration(NewDuration: number): void;
	static C(Other: UObject | any): CameraAnimInst;
}

declare class CameraShake extends UObject { 
	bSingleInstance: boolean;
	OscillationDuration: number;
	OscillationBlendInTime: number;
	OscillationBlendOutTime: number;
	RotOscillation: ROscillator;
	LocOscillation: VOscillator;
	FOVOscillation: FOscillator;
	AnimPlayRate: number;
	AnimScale: number;
	AnimBlendInTime: number;
	AnimBlendOutTime: number;
	RandomAnimSegmentDuration: number;
	Anim: CameraAnim;
	bRandomAnimSegment: boolean;
	CameraOwner: PlayerCameraManager;
	ShakeScale: number;
	OscillatorTimeRemaining: number;
	AnimInst: CameraAnimInst;
	static Load(ResourceName: string): CameraShake;
	static Find(Outer: UObject, ResourceName: string): CameraShake;
	static GetDefaultObject(): CameraShake;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShake;
	ReceiveStopShake(bImmediately: boolean): void;
	ReceivePlayShake(Scale: number): void;
	ReceiveIsFinished(): boolean;
	BlueprintUpdateCameraShake(DeltaTime: number,Alpha: number,POV: MinimalViewInfo,ModifiedPOV?: MinimalViewInfo): {ModifiedPOV: MinimalViewInfo};
	static C(Other: UObject | any): CameraShake;
}

declare class CameraModifier_CameraShake extends CameraModifier { 
	ActiveShakes: CameraShake[];
	SplitScreenShakeScale: number;
	static Load(ResourceName: string): CameraModifier_CameraShake;
	static Find(Outer: UObject, ResourceName: string): CameraModifier_CameraShake;
	static GetDefaultObject(): CameraModifier_CameraShake;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier_CameraShake;
	static C(Other: UObject | any): CameraModifier_CameraShake;
}

declare class MeshBuildSettings { 
	bUseMikkTSpace: boolean;
	bRecomputeNormals: boolean;
	bRecomputeTangents: boolean;
	bRemoveDegenerates: boolean;
	bBuildAdjacencyBuffer: boolean;
	bBuildReversedIndexBuffer: boolean;
	bUseHighPrecisionTangentBasis: boolean;
	bUseFullPrecisionUVs: boolean;
	bGenerateLightmapUVs: boolean;
	MinLightmapResolution: number;
	SrcLightmapIndex: number;
	DstLightmapIndex: number;
	BuildScale: number;
	BuildScale3D: Vector;
	DistanceFieldResolutionScale: number;
	bGenerateDistanceFieldAsIfTwoSided: boolean;
	DistanceFieldBias: number;
	DistanceFieldReplacementMesh: StaticMesh;
	clone() : MeshBuildSettings;
	static C(Other: UObject | any): MeshBuildSettings;
}

declare type EMeshFeatureImportance = 'Off' | 'Lowest' | 'Low' | 'Normal' | 'High' | 'Highest';
declare var EMeshFeatureImportance : { Off:'Off',Lowest:'Lowest',Low:'Low',Normal:'Normal',High:'High',Highest:'Highest', };
declare class MeshReductionSettings { 
	PercentTriangles: number;
	MaxDeviation: number;
	PixelError: number;
	WeldingThreshold: number;
	HardAngleThreshold: number;
	SilhouetteImportance: EMeshFeatureImportance;
	TextureImportance: EMeshFeatureImportance;
	ShadingImportance: EMeshFeatureImportance;
	bRecalculateNormals: boolean;
	BaseLODModel: number;
	bGenerateUniqueLightmapUVs: boolean;
	bKeepSymmetry: boolean;
	bVisibilityAided: boolean;
	bCullOccluded: boolean;
	VisibilityAggressiveness: EMeshFeatureImportance;
	VertexColorImportance: EMeshFeatureImportance;
	clone() : MeshReductionSettings;
	static C(Other: UObject | any): MeshReductionSettings;
}

declare class StaticMeshSourceModel { 
	BuildSettings: MeshBuildSettings;
	ReductionSettings: MeshReductionSettings;
	LODDistance: number;
	ScreenSize: number;
	clone() : StaticMeshSourceModel;
	static C(Other: UObject | any): StaticMeshSourceModel;
}

declare class MeshSectionInfoMap { 
	Map: any;
	clone() : MeshSectionInfoMap;
	static C(Other: UObject | any): MeshSectionInfoMap;
}

declare class MaterialRemapIndex { 
	ImportVersionKey: any;
	MaterialRemap: number[];
	clone() : MaterialRemapIndex;
	static C(Other: UObject | any): MaterialRemapIndex;
}

declare class StaticMaterial { 
	MaterialInterface: MaterialInterface;
	MaterialSlotName: string;
	ImportedMaterialSlotName: string;
	UVChannelData: MeshUVChannelInfo;
	clone() : StaticMaterial;
	static C(Other: UObject | any): StaticMaterial;
}

declare class AssetEditorOrbitCameraPosition { 
	bIsSet: boolean;
	CamOrbitPoint: Vector;
	CamOrbitZoom: Vector;
	CamOrbitRotation: Rotator;
	clone() : AssetEditorOrbitCameraPosition;
	static C(Other: UObject | any): AssetEditorOrbitCameraPosition;
}

declare class StaticMeshSocket extends UObject { 
	SocketName: string;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale: Vector;
	Tag: string;
	PreviewStaticMesh: StaticMesh;
	bSocketCreatedAtImport: boolean;
	static Load(ResourceName: string): StaticMeshSocket;
	static Find(Outer: UObject, ResourceName: string): StaticMeshSocket;
	static GetDefaultObject(): StaticMeshSocket;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshSocket;
	static C(Other: UObject | any): StaticMeshSocket;
}

declare class NavCollisionCylinder { 
	Offset: Vector;
	Radius: number;
	Height: number;
	clone() : NavCollisionCylinder;
	static C(Other: UObject | any): NavCollisionCylinder;
}

declare class NavCollisionBox { 
	Offset: Vector;
	Extent: Vector;
	clone() : NavCollisionBox;
	static C(Other: UObject | any): NavCollisionBox;
}

declare class NavCollision extends UObject { 
	CylinderCollision: NavCollisionCylinder[];
	BoxCollision: NavCollisionBox[];
	AreaClass: UnrealEngineClass;
	bIsDynamicObstacle: boolean;
	bGatherConvexGeometry: boolean;
	static Load(ResourceName: string): NavCollision;
	static Find(Outer: UObject, ResourceName: string): NavCollision;
	static GetDefaultObject(): NavCollision;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavCollision;
	static C(Other: UObject | any): NavCollision;
}

declare class MeshSectionInfo { 
	MaterialIndex: number;
	bEnableCollision: boolean;
	bCastShadow: boolean;
	clone() : MeshSectionInfo;
	static C(Other: UObject | any): MeshSectionInfo;
}

declare class JavascriptRawMesh { 
	FaceMaterialIndices: number[];
	FaceSmoothingMasks: any[];
	VertexPositions: Vector[];
	WedgeIndices: any[];
	WedgeTangentX: Vector[];
	WedgeTangentY: Vector[];
	WedgeTangentZ: Vector[];
	WedgeTexCoords_0: Vector2D[];
	WedgeTexCoords_1: Vector2D[];
	WedgeTexCoords_2: Vector2D[];
	WedgeTexCoords_3: Vector2D[];
	WedgeTexCoords_4: Vector2D[];
	WedgeTexCoords_5: Vector2D[];
	WedgeTexCoords_6: Vector2D[];
	WedgeTexCoords_7: Vector2D[];
	WedgeColors: Color[];
	MaterialIndexToImportIndex: number[];
	clone() : JavascriptRawMesh;
	static C(Other: UObject | any): JavascriptRawMesh;
	CompactMaterialIndices(): {RawMesh: JavascriptRawMesh};
	Empty(): {RawMesh: JavascriptRawMesh};
	GetWedgePosition(WedgeIndex: number): Vector;
	IsValid(): boolean;
	IsValidOrFixable(): boolean;
	static CompactMaterialIndices(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	static Empty(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	static GetWedgePosition(RawMesh: JavascriptRawMesh,WedgeIndex: number): Vector;
	static IsValid(RawMesh: JavascriptRawMesh): boolean;
	static IsValidOrFixable(RawMesh: JavascriptRawMesh): boolean;
}

declare class StaticMesh extends UObject { 
	SourceModels: StaticMeshSourceModel[];
	SectionInfoMap: MeshSectionInfoMap;
	OriginalSectionInfoMap: MeshSectionInfoMap;
	LODGroup: string;
	bAutoComputeLODScreenSize: boolean;
	ImportVersion: number;
	MaterialRemapIndexPerImportVersion: MaterialRemapIndex[];
	LightmapUVVersion: number;
	MinLOD: number;
	Materials: MaterialInterface[];
	StaticMaterials: StaticMaterial[];
	LightmapUVDensity: number;
	LightMapResolution: number;
	LightMapCoordinateIndex: number;
	DistanceFieldSelfShadowBias: number;
	bGenerateMeshDistanceField: boolean;
	BodySetup: BodySetup;
	LODForCollision: number;
	bStripComplexCollisionForConsole: boolean;
	bHasNavigationData: boolean;
	bSupportUniformlyDistributedSampling: boolean;
	LpvBiasMultiplier: number;
	bAllowCPUAccess: boolean;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	ThumbnailInfo: ThumbnailInfo;
	EditorCameraPosition: AssetEditorOrbitCameraPosition;
	bCustomizedCollision: boolean;
	Sockets: StaticMeshSocket[];
	PositiveBoundsExtension: Vector;
	NegativeBoundsExtension: Vector;
	ExtendedBounds: BoxSphereBounds;
	ElementToIgnoreForTexFactor: number;
	AssetUserData: AssetUserData[];
	NavCollision: NavCollision;
	static Load(ResourceName: string): StaticMesh;
	static Find(Outer: UObject, ResourceName: string): StaticMesh;
	static GetDefaultObject(): StaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMesh;
	GetNumSections(InLOD: number): number;
	GetNumLODs(): number;
	GetMaterialIndex(MaterialSlotName: string): number;
	GetMaterial(MaterialIndex: number): MaterialInterface;
	GetBounds(): BoxSphereBounds;
	GetBoundingBox(): Box;
	static C(Other: UObject | any): StaticMesh;
	Build(): void;
	GetSectionInfo(LODIndex: number,SectionIndex: number): MeshSectionInfo;
	LoadRawMesh(SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	SaveRawMesh(SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	SetSectionInfo(LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
	GetSectionFromStaticMesh(LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static Build(StaticMesh: StaticMesh): void;
	static GetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number): MeshSectionInfo;
	static LoadRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	static SaveRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	static SetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
	static GetSectionFromStaticMesh(InMesh: StaticMesh,LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
}

declare class CameraComponent extends SceneComponent { 
	FieldOfView: number;
	OrthoWidth: number;
	OrthoNearClipPlane: number;
	OrthoFarClipPlane: number;
	AspectRatio: number;
	bConstrainAspectRatio: boolean;
	bUseFieldOfViewForLOD: boolean;
	bLockToHmd: boolean;
	bUsePawnControlRotation: boolean;
	ProjectionMode: ECameraProjectionMode;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	CameraMesh: StaticMesh;
	bUseControllerViewRotation: boolean;
	static Load(ResourceName: string): CameraComponent;
	static Find(Outer: UObject, ResourceName: string): CameraComponent;
	static GetDefaultObject(): CameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraComponent;
	SetUseFieldOfViewForLOD(bInUseFieldOfViewForLOD: boolean): void;
	SetProjectionMode(InProjectionMode: ECameraProjectionMode): void;
	SetPostProcessBlendWeight(InPostProcessBlendWeight: number): void;
	SetOrthoWidth(InOrthoWidth: number): void;
	SetOrthoNearClipPlane(InOrthoNearClipPlane: number): void;
	SetOrthoFarClipPlane(InOrthoFarClipPlane: number): void;
	SetFieldOfView(InFieldOfView: number): void;
	SetConstraintAspectRatio(bInConstrainAspectRatio: boolean): void;
	SetAspectRatio(InAspectRatio: number): void;
	GetCameraView(DeltaTime: number,DesiredView?: MinimalViewInfo): {DesiredView: MinimalViewInfo};
	static C(Other: UObject | any): CameraComponent;
}

declare class CameraActor extends Actor { 
	AutoActivateForPlayer: EAutoReceiveInput;
	CameraComponent: CameraComponent;
	SceneComponent: SceneComponent;
	bConstrainAspectRatio: boolean;
	AspectRatio: number;
	FOVAngle: number;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	static GetDefaultObject(): CameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraActor;
	GetAutoActivatePlayerIndex(): number;
	static C(Other: UObject | any): CameraActor;
	DrawDebugCamera(CameraColor: LinearColor,Duration: number): void;
	static DrawDebugCamera(CameraActor: CameraActor,CameraColor: LinearColor,Duration: number): void;
}

declare class PlayerCameraManager extends Actor { 
	PCOwner: PlayerController;
	TransformComponent: SceneComponent;
	DefaultFOV: number;
	DefaultOrthoWidth: number;
	DefaultAspectRatio: number;
	CameraCache: CameraCacheEntry;
	LastFrameCameraCache: CameraCacheEntry;
	ViewTarget: TViewTarget;
	PendingViewTarget: TViewTarget;
	ModifierList: CameraModifier[];
	DefaultModifiers: UnrealEngineClass[];
	FreeCamDistance: number;
	FreeCamOffset: Vector;
	ViewTargetOffset: Vector;
	CameraLensEffects: EmitterCameraLensEffectBase[];
	CachedCameraShakeMod: CameraModifier_CameraShake;
	AnimInstPool: CameraAnimInst;
	PostProcessBlendCache: PostProcessSettings[];
	ActiveAnims: CameraAnimInst[];
	FreeAnims: CameraAnimInst[];
	AnimCameraActor: CameraActor;
	bIsOrthographic: boolean;
	bDefaultConstrainAspectRatio: boolean;
	bUseClientSideCameraUpdates: boolean;
	bGameCameraCutThisFrame: boolean;
	ViewPitchMin: number;
	ViewPitchMax: number;
	ViewYawMin: number;
	ViewYawMax: number;
	ViewRollMin: number;
	ViewRollMax: number;
	static GetDefaultObject(): PlayerCameraManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerCameraManager;
	StopCameraShake(ShakeInstance: CameraShake,bImmediately: boolean): void;
	StopCameraFade(): void;
	StopCameraAnimInst(AnimInst: CameraAnimInst,bImmediate: boolean): void;
	StopAllInstancesOfCameraShake(Shake: UnrealEngineClass,bImmediately: boolean): void;
	StopAllInstancesOfCameraAnim(Anim: CameraAnim,bImmediate: boolean): void;
	StopAllCameraShakes(bImmediately: boolean): void;
	StopAllCameraAnims(bImmediate: boolean): void;
	StartCameraFade(FromAlpha: number,ToAlpha: number,Duration: number,Color: LinearColor,bShouldFadeAudio: boolean,bHoldWhenFinished: boolean): void;
	SetManualCameraFade(InFadeAmount: number,Color: LinearColor,bInFadeAudio: boolean): void;
	RemoveCameraModifier(ModifierToRemove: CameraModifier): boolean;
	RemoveCameraLensEffect(Emitter: EmitterCameraLensEffectBase): void;
	PlayCameraShake(ShakeClass: UnrealEngineClass,Scale: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): CameraShake;
	PlayCameraAnim(Anim: CameraAnim,Rate: number,Scale: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Duration: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): CameraAnimInst;
	PhotographyCameraModify(NewCameraLocation: Vector,PreviousCameraLocation: Vector,OriginalCameraLocation: Vector,ResultCameraLocation?: Vector): {ResultCameraLocation: Vector};
	OnPhotographySessionStart(): void;
	OnPhotographySessionEnd(): void;
	OnPhotographyMultiPartCaptureStart(): void;
	OnPhotographyMultiPartCaptureEnd(): void;
	GetOwningPlayerController(): PlayerController;
	GetFOVAngle(): number;
	GetCameraRotation(): Rotator;
	GetCameraLocation(): Vector;
	FindCameraModifierByClass(ModifierClass: UnrealEngineClass): CameraModifier;
	ClearCameraLensEffects(): void;
	BlueprintUpdateCamera(CameraTarget: Actor,NewCameraLocation?: Vector,NewCameraRotation?: Rotator,NewCameraFOV?: number): {NewCameraLocation: Vector, NewCameraRotation: Rotator, NewCameraFOV: number, $: boolean};
	AddNewCameraModifier(ModifierClass: UnrealEngineClass): CameraModifier;
	AddCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): EmitterCameraLensEffectBase;
	static C(Other: UObject | any): PlayerCameraManager;
}

declare class DrawFrustumComponent extends PrimitiveComponent { 
	FrustumColor: Color;
	FrustumAngle: number;
	FrustumAspectRatio: number;
	FrustumStartDist: number;
	FrustumEndDist: number;
	Texture: Texture;
	static Load(ResourceName: string): DrawFrustumComponent;
	static Find(Outer: UObject, ResourceName: string): DrawFrustumComponent;
	static GetDefaultObject(): DrawFrustumComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DrawFrustumComponent;
	static C(Other: UObject | any): DrawFrustumComponent;
}

declare class DebugCameraController extends PlayerController { 
	bShowSelectedInfo: boolean;
	bIsFrozenRendering: boolean;
	DrawFrustum: DrawFrustumComponent;
	SpeedScale: number;
	InitialMaxSpeed: number;
	InitialAccel: number;
	InitialDecel: number;
	static GetDefaultObject(): DebugCameraController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraController;
	ToggleDisplay(): void;
	ShowDebugSelectedInfo(): void;
	SetPawnMovementSpeedScale(NewSpeedScale: number): void;
	ReceiveOnDeactivate(RestoredPC: PlayerController): void;
	ReceiveOnActorSelected(NewSelectedActor: Actor,SelectHitLocation: Vector,SelectHitNormal: Vector,Hit: HitResult): void;
	ReceiveOnActivate(OriginalPC: PlayerController): void;
	GetSelectedActor(): Actor;
	static C(Other: UObject | any): DebugCameraController;
}

declare class CheatManager extends UObject { 
	DebugCameraControllerRef: DebugCameraController;
	DebugCameraControllerClass: UnrealEngineClass;
	static Load(ResourceName: string): CheatManager;
	static Find(Outer: UObject, ResourceName: string): CheatManager;
	static GetDefaultObject(): CheatManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheatManager;
	Walk(): void;
	ViewSelf(): void;
	ViewPlayer(S: string): void;
	ViewClass(DesiredClass: UnrealEngineClass): void;
	ViewActor(ActorName: string): void;
	ToggleDebugCamera(): void;
	ToggleAILogging(): void;
	TestCollisionDistance(): void;
	Teleport(): void;
	Summon(ClassName: string): void;
	StreamLevelOut(PackageName: string): void;
	StreamLevelIn(PackageName: string): void;
	Slomo(NewTimeDilation: number): void;
	SetWorldOrigin(): void;
	SetNavDrawDistance(DrawDistance: number): void;
	SetMouseSensitivityToDefault(): void;
	ServerToggleAILogging(): void;
	ReceiveInitCheatManager(): void;
	ReceiveEndPlay(): void;
	RebuildNavigation(): void;
	PlayersOnly(): void;
	OnlyLoadLevel(PackageName: string): void;
	LogLoc(): void;
	InvertMouse(): void;
	God(): void;
	Ghost(): void;
	FreezeFrame(Delay: number): void;
	Fly(): void;
	FlushLog(): void;
	EnableDebugCamera(): void;
	DumpVoiceMutingState(): void;
	DumpPartyState(): void;
	DumpOnlineSessionState(): void;
	DumpChatState(): void;
	DisableDebugCamera(): void;
	DestroyTarget(): void;
	DestroyPawns(aClass: UnrealEngineClass): void;
	DestroyAllPawnsExceptTarget(): void;
	DestroyAll(aClass: UnrealEngineClass): void;
	DebugCapsuleSweepSize(HalfHeight: number,Radius: number): void;
	DebugCapsuleSweepPawn(): void;
	DebugCapsuleSweepComplex(bTraceComplex: boolean): void;
	DebugCapsuleSweepClear(): void;
	DebugCapsuleSweepChannel(Channel: ECollisionChannel): void;
	DebugCapsuleSweepCapture(): void;
	DebugCapsuleSweep(): void;
	DamageTarget(DamageAmount: number): void;
	CheatScript(ScriptName: string): void;
	ChangeSize(F: number): void;
	BugItStringCreator(ViewLocation: Vector,ViewRotation: Rotator,GoString?: string,LocString?: string): {GoString: string, LocString: string};
	BugItGo(X: number,Y: number,Z: number,Pitch: number,Yaw: number,Roll: number): void;
	BugIt(ScreenShotDescription: string): void;
	static C(Other: UObject | any): CheatManager;
}

declare class KeyBind { 
	Key: Key;
	Command: string;
	Control: boolean;
	Shift: boolean;
	Alt: boolean;
	Cmd: boolean;
	bIgnoreCtrl: boolean;
	bIgnoreShift: boolean;
	bIgnoreAlt: boolean;
	bIgnoreCmd: boolean;
	bDisabled: boolean;
	clone() : KeyBind;
	static C(Other: UObject | any): KeyBind;
}

declare class PlayerInput extends UObject { 
	DebugExecBindings: KeyBind[];
	InvertedAxis: string[];
	static Load(ResourceName: string): PlayerInput;
	static Find(Outer: UObject, ResourceName: string): PlayerInput;
	static GetDefaultObject(): PlayerInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerInput;
	SetMouseSensitivity(Sensitivity: number): void;
	SetBind(BindName: string,Command: string): void;
	InvertAxisKey(AxisKey: Key): void;
	InvertAxis(AxisName: string): void;
	ClearSmoothing(): void;
	static C(Other: UObject | any): PlayerInput;
}

declare class RuntimeFloatCurve { 
	EditorCurveData: RichCurve;
	ExternalCurve: CurveFloat;
	clone() : RuntimeFloatCurve;
	static C(Other: UObject | any): RuntimeFloatCurve;
}

declare class ForceFeedbackChannelDetails { 
	bAffectsLeftLarge: boolean;
	bAffectsLeftSmall: boolean;
	bAffectsRightLarge: boolean;
	bAffectsRightSmall: boolean;
	Curve: RuntimeFloatCurve;
	clone() : ForceFeedbackChannelDetails;
	static C(Other: UObject | any): ForceFeedbackChannelDetails;
}

declare type EAttenuationDistanceModel = 'Linear' | 'Logarithmic' | 'Inverse' | 'LogReverse' | 'NaturalSound' | 'Custom';
declare var EAttenuationDistanceModel : { Linear:'Linear',Logarithmic:'Logarithmic',Inverse:'Inverse',LogReverse:'LogReverse',NaturalSound:'NaturalSound',Custom:'Custom', };
declare type EAttenuationShape = 'Sphere' | 'Capsule' | 'Box' | 'Cone';
declare var EAttenuationShape : { Sphere:'Sphere',Capsule:'Capsule',Box:'Box',Cone:'Cone', };
declare class BaseAttenuationSettings { 
	DistanceAlgorithm: DistanceAlgorithm;
	CustomAttenuationCurve: RuntimeFloatCurve;
	AttenuationShape: EAttenuationShape;
	dBAttenuationAtMax: number;
	AttenuationShapeExtents: Vector;
	ConeOffset: number;
	FalloffDistance: number;
	clone() : BaseAttenuationSettings;
	static C(Other: UObject | any): BaseAttenuationSettings;
}

declare class ForceFeedbackAttenuationSettings extends BaseAttenuationSettings { 
	clone() : ForceFeedbackAttenuationSettings;
	static C(Other: UObject | any): ForceFeedbackAttenuationSettings;
}

declare class ForceFeedbackAttenuation extends UObject { 
	Attenuation: ForceFeedbackAttenuationSettings;
	static Load(ResourceName: string): ForceFeedbackAttenuation;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackAttenuation;
	static GetDefaultObject(): ForceFeedbackAttenuation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackAttenuation;
	static C(Other: UObject | any): ForceFeedbackAttenuation;
}

declare class ForceFeedbackComponent extends SceneComponent { 
	ForceFeedbackEffect: ForceFeedbackEffect;
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bLooping: boolean;
	bIgnoreTimeDilation: boolean;
	bOverrideAttenuation: boolean;
	IntensityMultiplier: number;
	AttenuationSettings: ForceFeedbackAttenuation;
	AttenuationOverrides: ForceFeedbackAttenuationSettings;
	OnForceFeedbackFinished: UnrealEngineMulticastDelegate<(ForceFeedbackComponent: ForceFeedbackComponent) => void>;
	static Load(ResourceName: string): ForceFeedbackComponent;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackComponent;
	static GetDefaultObject(): ForceFeedbackComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackComponent;
	Stop(): void;
	SetIntensityMultiplier(NewIntensityMultiplier: number): void;
	SetForceFeedbackEffect(NewForceFeedbackEffect: ForceFeedbackEffect): void;
	Play(StartTime: number): void;
	BP_GetAttenuationSettingsToApply(OutAttenuationSettings?: ForceFeedbackAttenuationSettings): {OutAttenuationSettings: ForceFeedbackAttenuationSettings, $: boolean};
	AdjustAttenuation(InAttenuationSettings: ForceFeedbackAttenuationSettings): void;
	static C(Other: UObject | any): ForceFeedbackComponent;
}

declare class ForceFeedbackEffect extends UObject { 
	ChannelDetails: ForceFeedbackChannelDetails[];
	Duration: number;
	static Load(ResourceName: string): ForceFeedbackEffect;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackEffect;
	static GetDefaultObject(): ForceFeedbackEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackEffect;
	static C(Other: UObject | any): ForceFeedbackEffect;
	SpawnForceFeedbackAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnForceFeedbackAttached(ForceFeedbackEffect: ForceFeedbackEffect,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
}

declare class ActiveForceFeedbackEffect { 
	ForceFeedbackEffect: ForceFeedbackEffect;
	clone() : ActiveForceFeedbackEffect;
	static C(Other: UObject | any): ActiveForceFeedbackEffect;
}

declare class ChildConnection extends NetConnection { 
	Parent: NetConnection;
	static Load(ResourceName: string): ChildConnection;
	static Find(Outer: UObject, ResourceName: string): ChildConnection;
	static GetDefaultObject(): ChildConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildConnection;
	static C(Other: UObject | any): ChildConnection;
}

declare class Property extends Field { 
	static Load(ResourceName: string): Property;
	static Find(Outer: UObject, ResourceName: string): Property;
	static GetDefaultObject(): Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject | any): Property;
}

declare class NetDriver extends UObject { 
	NetConnectionClassName: string;
	MaxDownloadSize: number;
	bClampListenServerTickRate: boolean;
	NetServerMaxTickRate: number;
	MaxInternetClientRate: number;
	MaxClientRate: number;
	ServerTravelPause: number;
	SpawnPrioritySeconds: number;
	RelevantTimeout: number;
	KeepAliveTime: number;
	InitialConnectTimeout: number;
	ConnectionTimeout: number;
	TimeoutMultiplierForUnoptimizedBuilds: number;
	bNoTimeouts: boolean;
	ServerConnection: NetConnection;
	ClientConnections: NetConnection[];
	World: World;
	NetConnectionClass: UnrealEngineClass;
	RoleProperty: Property;
	RemoteRoleProperty: Property;
	NetDriverName: string;
	Time: number;
	static Load(ResourceName: string): NetDriver;
	static Find(Outer: UObject, ResourceName: string): NetDriver;
	static GetDefaultObject(): NetDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetDriver;
	static C(Other: UObject | any): NetDriver;
}

declare class PackageMap extends UObject { 
	static Load(ResourceName: string): PackageMap;
	static Find(Outer: UObject, ResourceName: string): PackageMap;
	static GetDefaultObject(): PackageMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMap;
	static C(Other: UObject | any): PackageMap;
}

declare class Channel extends UObject { 
	Connection: NetConnection;
	static Load(ResourceName: string): Channel;
	static Find(Outer: UObject, ResourceName: string): Channel;
	static GetDefaultObject(): Channel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Channel;
	static C(Other: UObject | any): Channel;
}

declare class NetConnection extends Player { 
	Children: ChildConnection[];
	Driver: NetDriver;
	PackageMapClass: UnrealEngineClass;
	PackageMap: PackageMap;
	OpenChannels: Channel[];
	SentTemporaries: Actor[];
	ViewTarget: Actor;
	OwningActor: Actor;
	MaxPacket: number;
	InternalAck: boolean;
	PlayerId: UniqueNetIdRepl;
	LastReceiveTime: any;
	ChannelsToTick: Channel[];
	static Load(ResourceName: string): NetConnection;
	static Find(Outer: UObject, ResourceName: string): NetConnection;
	static GetDefaultObject(): NetConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetConnection;
	static C(Other: UObject | any): NetConnection;
}

declare type EMouseCursor = 'None' | 'Default' | 'TextEditBeam' | 'ResizeLeftRight' | 'ResizeUpDown' | 'ResizeSouthEast' | 'ResizeSouthWest' | 'CardinalCross' | 'Crosshairs' | 'Hand' | 'GrabHand' | 'GrabHandClosed' | 'SlashedCircle' | 'EyeDropper';
declare var EMouseCursor : { None:'None',Default:'Default',TextEditBeam:'TextEditBeam',ResizeLeftRight:'ResizeLeftRight',ResizeUpDown:'ResizeUpDown',ResizeSouthEast:'ResizeSouthEast',ResizeSouthWest:'ResizeSouthWest',CardinalCross:'CardinalCross',Crosshairs:'Crosshairs',Hand:'Hand',GrabHand:'GrabHand',GrabHandClosed:'GrabHandClosed',SlashedCircle:'SlashedCircle',EyeDropper:'EyeDropper', };
declare type EControllerAnalogStick = 'CAS_LeftStick' | 'CAS_RightStick';
declare var EControllerAnalogStick : { CAS_LeftStick:'CAS_LeftStick',CAS_RightStick:'CAS_RightStick', };
declare class InputComponent extends ActorComponent { 
	static Load(ResourceName: string): InputComponent;
	static Find(Outer: UObject, ResourceName: string): InputComponent;
	static GetDefaultObject(): InputComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputComponent;
	WasControllerKeyJustReleased(Key: Key): boolean;
	WasControllerKeyJustPressed(Key: Key): boolean;
	IsControllerKeyDown(Key: Key): boolean;
	GetTouchState(FingerIndex: number,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	GetControllerVectorKeyState(Key: Key): Vector;
	GetControllerMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	GetControllerKeyTimeDown(Key: Key): number;
	GetControllerAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	GetControllerAnalogKeyState(Key: Key): number;
	static C(Other: UObject | any): InputComponent;
}

declare class TouchInputControl { 
	Image1: Texture2D;
	Image2: Texture2D;
	Center: Vector2D;
	VisualSize: Vector2D;
	ThumbSize: Vector2D;
	InteractionSize: Vector2D;
	InputScale: Vector2D;
	MainInputKey: Key;
	AltInputKey: Key;
	clone() : TouchInputControl;
	static C(Other: UObject | any): TouchInputControl;
}

declare class TouchInterface extends UObject { 
	Controls: TouchInputControl[];
	ActiveOpacity: number;
	InactiveOpacity: number;
	TimeUntilDeactive: number;
	TimeUntilReset: number;
	ActivationDelay: number;
	bPreventRecenter: boolean;
	StartupDelay: number;
	static Load(ResourceName: string): TouchInterface;
	static Find(Outer: UObject, ResourceName: string): TouchInterface;
	static GetDefaultObject(): TouchInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TouchInterface;
	static C(Other: UObject | any): TouchInterface;
}

declare class SphereComponent extends ShapeComponent { 
	SphereRadius: number;
	static Load(ResourceName: string): SphereComponent;
	static Find(Outer: UObject, ResourceName: string): SphereComponent;
	static GetDefaultObject(): SphereComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereComponent;
	SetSphereRadius(InSphereRadius: number,bUpdateOverlaps: boolean): void;
	GetUnscaledSphereRadius(): number;
	GetShapeScale(): number;
	GetScaledSphereRadius(): number;
	static C(Other: UObject | any): SphereComponent;
}

declare class PackedNormal { 
	X: number;
	Y: number;
	Z: number;
	W: number;
	clone() : PackedNormal;
	static C(Other: UObject | any): PackedNormal;
}

declare class PaintedVertex { 
	Position: Vector;
	Normal: PackedNormal;
	Color: Color;
	clone() : PaintedVertex;
	static C(Other: UObject | any): PaintedVertex;
}

declare class StaticMeshComponentLODInfo { 
	PaintedVertices: PaintedVertex[];
	clone() : StaticMeshComponentLODInfo;
	static C(Other: UObject | any): StaticMeshComponentLODInfo;
}

declare class StreamingTextureBuildInfo { 
	PackedRelativeBox: any;
	TextureLevelIndex: number;
	TexelFactor: number;
	clone() : StreamingTextureBuildInfo;
	static C(Other: UObject | any): StreamingTextureBuildInfo;
}

declare class LightmassPrimitiveSettings { 
	bUseTwoSidedLighting: boolean;
	bShadowIndirectOnly: boolean;
	bUseEmissiveForStaticLighting: boolean;
	bUseVertexNormalForHemisphereGather: boolean;
	EmissiveLightFalloffExponent: number;
	EmissiveLightExplicitInfluenceRadius: number;
	EmissiveBoost: number;
	DiffuseBoost: number;
	FullyOccludedSamplesFraction: number;
	clone() : LightmassPrimitiveSettings;
	static C(Other: UObject | any): LightmassPrimitiveSettings;
}

declare class ProcMeshVertex { 
	Position: Vector;
	Normal: Vector;
	Tangent: ProcMeshTangent;
	Color: Color;
	UV0: Vector2D;
	clone() : ProcMeshVertex;
	static C(Other: UObject | any): ProcMeshVertex;
}

declare class ProcMeshSection { 
	ProcVertexBuffer: ProcMeshVertex[];
	ProcIndexBuffer: number[];
	SectionLocalBox: Box;
	bEnableCollision: boolean;
	bSectionVisible: boolean;
	clone() : ProcMeshSection;
	static C(Other: UObject | any): ProcMeshSection;
}

declare type EProcMeshSliceCapOption = 'NoCap' | 'CreateNewSectionForCap' | 'UseLastSectionForCap';
declare var EProcMeshSliceCapOption : { NoCap:'NoCap',CreateNewSectionForCap:'CreateNewSectionForCap',UseLastSectionForCap:'UseLastSectionForCap', };
declare class ProceduralMeshComponent extends MeshComponent { 
	bUseComplexAsSimpleCollision: boolean;
	bUseAsyncCooking: boolean;
	ProcMeshBodySetup: BodySetup;
	ProcMeshSections: ProcMeshSection[];
	CollisionConvexElems: KConvexElem[];
	LocalBounds: BoxSphereBounds;
	AsyncBodySetupQueue: BodySetup[];
	static Load(ResourceName: string): ProceduralMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralMeshComponent;
	static GetDefaultObject(): ProceduralMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralMeshComponent;
	UpdateMeshSection_LinearColor(SectionIndex: number,Vertices: Vector[],Normals: Vector[],UV0: Vector2D[],VertexColors: LinearColor[],Tangents: ProcMeshTangent[]): void;
	UpdateMeshSection(SectionIndex: number,Vertices: Vector[],Normals: Vector[],UV0: Vector2D[],VertexColors: Color[],Tangents: ProcMeshTangent[]): void;
	SetMeshSectionVisible(SectionIndex: number,bNewVisibility: boolean): void;
	IsMeshSectionVisible(SectionIndex: number): boolean;
	GetNumSections(): number;
	CreateMeshSection_LinearColor(SectionIndex: number,Vertices: Vector[],Triangles: number[],Normals: Vector[],UV0: Vector2D[],VertexColors: LinearColor[],Tangents: ProcMeshTangent[],bCreateCollision: boolean): void;
	CreateMeshSection(SectionIndex: number,Vertices: Vector[],Triangles: number[],Normals: Vector[],UV0: Vector2D[],VertexColors: Color[],Tangents: ProcMeshTangent[],bCreateCollision: boolean): void;
	ClearMeshSection(SectionIndex: number): void;
	ClearCollisionConvexMeshes(): void;
	ClearAllMeshSections(): void;
	AddCollisionConvexMesh(ConvexVerts: Vector[]): void;
	static C(Other: UObject | any): ProceduralMeshComponent;
	SliceProceduralMesh(PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: CapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
	static SliceProceduralMesh(InProcMesh: ProceduralMeshComponent,PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: CapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
}

declare type EVertexPaintAxis = 'X' | 'Y' | 'Z';
declare var EVertexPaintAxis : { X:'X',Y:'Y',Z:'Z', };
declare class StaticMeshComponent extends MeshComponent { 
	ForcedLodModel: number;
	PreviousLODLevel: number;
	MinLOD: number;
	SubDivisionStepSize: number;
	StaticMesh: StaticMesh;
	WireframeColorOverride: Color;
	SelectedEditorSection: number;
	SelectedEditorMaterial: number;
	SectionIndexPreview: number;
	MaterialIndexPreview: number;
	StaticMeshImportVersion: number;
	bOverrideWireframeColor: boolean;
	bOverrideMinLOD: boolean;
	bOverrideNavigationExport: boolean;
	bForceNavigationObstacle: boolean;
	bDisallowMeshPaintPerInstance: boolean;
	bIgnoreInstanceForTextureStreaming: boolean;
	bOverrideLightMapRes: boolean;
	bCastDistanceFieldIndirectShadow: boolean;
	bOverrideDistanceFieldSelfShadowBias: boolean;
	bUseSubDivisions: boolean;
	bUseDefaultCollision: boolean;
	bCustomOverrideVertexColorPerLOD: boolean;
	bDisplayVertexColors: boolean;
	OverriddenLightMapRes: number;
	DistanceFieldIndirectShadowMinVisibility: number;
	DistanceFieldSelfShadowBias: number;
	StreamingDistanceMultiplier: number;
	IrrelevantLights: Guid[];
	LODData: StaticMeshComponentLODInfo[];
	StreamingTextureData: StreamingTextureBuildInfo[];
	StaticMeshDerivedDataKey: string;
	MaterialStreamingRelativeBoxes: any[];
	LightmassSettings: LightmassPrimitiveSettings;
	static Load(ResourceName: string): StaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): StaticMeshComponent;
	static GetDefaultObject(): StaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshComponent;
	SetStaticMesh(NewMesh: StaticMesh): boolean;
	SetForcedLodModel(NewForcedLodModel: number): void;
	SetDistanceFieldSelfShadowBias(NewValue: number): void;
	OnRep_StaticMesh(OldStaticMesh: StaticMesh): void;
	GetLocalBounds(Min?: Vector,Max?: Vector): {Min: Vector, Max: Vector};
	static C(Other: UObject | any): StaticMeshComponent;
	CopyProceduralMeshFromStaticMeshComponent(LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	PaintVerticesLerpAlongAxis(StartColor: LinearColor,EndColor: LinearColor,Axis: Axis,bConvertToSRGB: boolean): void;
	PaintVerticesSingleColor(FillColor: LinearColor,bConvertToSRGB: boolean): void;
	RemovePaintedVertices(): void;
	static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: StaticMeshComponent,LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent,StartColor: LinearColor,EndColor: LinearColor,Axis: Axis,bConvertToSRGB: boolean): void;
	static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent,FillColor: LinearColor,bConvertToSRGB: boolean): void;
	static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
}

declare class DefaultPawn extends Pawn { 
	BaseTurnRate: number;
	BaseLookUpRate: number;
	MovementComponent: PawnMovementComponent;
	CollisionComponent: SphereComponent;
	MeshComponent: StaticMeshComponent;
	bAddDefaultMovementBindings: boolean;
	static GetDefaultObject(): DefaultPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPawn;
	TurnAtRate(Rate: number): void;
	MoveUp_World(Val: number): void;
	MoveRight(Val: number): void;
	MoveForward(Val: number): void;
	LookUpAtRate(Rate: number): void;
	static C(Other: UObject | any): DefaultPawn;
}

declare class SpectatorPawn extends DefaultPawn { 
	static GetDefaultObject(): SpectatorPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorPawn;
	static C(Other: UObject | any): SpectatorPawn;
}

declare type EControllerHand = 'Left' | 'Right' | 'AnyHand' | 'Pad' | 'ExternalCamera' | 'Gun' | 'Special_1' | 'Special_2' | 'Special_3' | 'Special_4' | 'Special_5' | 'Special_6' | 'Special_7' | 'Special_8' | 'Special_9' | 'Special_10' | 'Special_11';
declare var EControllerHand : { Left:'Left',Right:'Right',AnyHand:'AnyHand',Pad:'Pad',ExternalCamera:'ExternalCamera',Gun:'Gun',Special_1:'Special_1',Special_2:'Special_2',Special_3:'Special_3',Special_4:'Special_4',Special_5:'Special_5',Special_6:'Special_6',Special_7:'Special_7',Special_8:'Special_8',Special_9:'Special_9',Special_10:'Special_10',Special_11:'Special_11', };
declare type EViewTargetBlendFunction = 'VTBlend_Linear' | 'VTBlend_Cubic' | 'VTBlend_EaseIn' | 'VTBlend_EaseOut' | 'VTBlend_EaseInOut';
declare var EViewTargetBlendFunction : { VTBlend_Linear:'VTBlend_Linear',VTBlend_Cubic:'VTBlend_Cubic',VTBlend_EaseIn:'VTBlend_EaseIn',VTBlend_EaseOut:'VTBlend_EaseOut',VTBlend_EaseInOut:'VTBlend_EaseInOut', };
declare class Visual extends UObject { 
	static Load(ResourceName: string): Visual;
	static Find(Outer: UObject, ResourceName: string): Visual;
	static GetDefaultObject(): Visual;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Visual;
	static C(Other: UObject | any): Visual;
}

declare class PanelWidget extends Widget { 
	Slots: PanelSlot[];
	static Load(ResourceName: string): PanelWidget;
	static Find(Outer: UObject, ResourceName: string): PanelWidget;
	static GetDefaultObject(): PanelWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelWidget;
	RemoveChildAt(Index: number): boolean;
	RemoveChild(Content: Widget): boolean;
	HasChild(Content: Widget): boolean;
	HasAnyChildren(): boolean;
	GetChildrenCount(): number;
	GetChildIndex(Content: Widget): number;
	GetChildAt(Index: number): Widget;
	ClearChildren(): void;
	AddChild(Content: Widget): PanelSlot;
	static C(Other: UObject | any): PanelWidget;
}

declare class PanelSlot extends Visual { 
	Parent: PanelWidget;
	Content: Widget;
	static Load(ResourceName: string): PanelSlot;
	static Find(Outer: UObject, ResourceName: string): PanelSlot;
	static GetDefaultObject(): PanelSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelSlot;
	static C(Other: UObject | any): PanelSlot;
}

declare type ESlateVisibility = 'Visible' | 'Collapsed' | 'Hidden' | 'HitTestInvisible' | 'SelfHitTestInvisible';
declare var ESlateVisibility : { Visible:'Visible',Collapsed:'Collapsed',Hidden:'Hidden',HitTestInvisible:'HitTestInvisible',SelfHitTestInvisible:'SelfHitTestInvisible', };
declare class WidgetTransform { 
	Translation: Vector2D;
	Scale: Vector2D;
	Shear: Vector2D;
	Angle: number;
	clone() : WidgetTransform;
	static C(Other: UObject | any): WidgetTransform;
}

declare type EWidgetClipping = 'Inherit' | 'ClipToBounds' | 'ClipToBoundsWithoutIntersecting' | 'ClipToBoundsAlways' | 'OnDemand';
declare var EWidgetClipping : { Inherit:'Inherit',ClipToBounds:'ClipToBounds',ClipToBoundsWithoutIntersecting:'ClipToBoundsWithoutIntersecting',ClipToBoundsAlways:'ClipToBoundsAlways',OnDemand:'OnDemand', };
declare type EUINavigationRule = 'Escape' | 'Explicit' | 'Wrap' | 'Stop' | 'Custom' | 'Invalid';
declare var EUINavigationRule : { Escape:'Escape',Explicit:'Explicit',Wrap:'Wrap',Stop:'Stop',Custom:'Custom',Invalid:'Invalid', };
declare class WidgetNavigationData { 
	Rule: Rule;
	WidgetToFocus: string;
	Widget: any;
	clone() : WidgetNavigationData;
	static C(Other: UObject | any): WidgetNavigationData;
}

declare class WidgetNavigation extends UObject { 
	Up: WidgetNavigationData;
	Down: WidgetNavigationData;
	Left: WidgetNavigationData;
	Right: WidgetNavigationData;
	Next: WidgetNavigationData;
	Previous: WidgetNavigationData;
	static Load(ResourceName: string): WidgetNavigation;
	static Find(Outer: UObject, ResourceName: string): WidgetNavigation;
	static GetDefaultObject(): WidgetNavigation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetNavigation;
	static C(Other: UObject | any): WidgetNavigation;
}

declare class PropertyPathSegment { 
	Name: string;
	ArrayIndex: number;
	Struct: Struct;
	Field: Field;
	clone() : PropertyPathSegment;
	static C(Other: UObject | any): PropertyPathSegment;
}

declare class DynamicPropertyPath { 
	Segments: PropertyPathSegment[];
	clone() : DynamicPropertyPath;
	static C(Other: UObject | any): DynamicPropertyPath;
}

declare class PropertyBinding extends UObject { 
	SourceObject: any;
	SourcePath: DynamicPropertyPath;
	DestinationProperty: string;
	static Load(ResourceName: string): PropertyBinding;
	static Find(Outer: UObject, ResourceName: string): PropertyBinding;
	static GetDefaultObject(): PropertyBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyBinding;
	static C(Other: UObject | any): PropertyBinding;
}

declare type EWidgetDesignFlags = 'None' | 'Designing' | 'ShowOutline' | 'ExecutePreConstruct' | 'EWidgetDesignFlags_MAX';
declare var EWidgetDesignFlags : { None:'None',Designing:'Designing',ShowOutline:'ShowOutline',ExecutePreConstruct:'ExecutePreConstruct',EWidgetDesignFlags_MAX:'EWidgetDesignFlags_MAX', };
declare type EUINavigation = 'Left' | 'Right' | 'Up' | 'Down' | 'Next' | 'Previous' | 'Num' | 'Invalid';
declare var EUINavigation : { Left:'Left',Right:'Right',Up:'Up',Down:'Down',Next:'Next',Previous:'Previous',Num:'Num',Invalid:'Invalid', };
declare class Geometry { 
	clone() : Geometry;
	static C(Other: UObject | any): Geometry;
	CenterOf(): Vector2D;
	FindClosestPointOnGeom(TestPoint: Vector2D): Vector2D;
	AbsoluteToLocal(AbsoluteCoordinate: Vector2D): Vector2D;
	GetAbsoluteSize(): Vector2D;
	GetLocalSize(): Vector2D;
	IsUnderLocation(AbsoluteCoordinate: Vector2D): boolean;
	LocalToAbsolute(LocalCoordinate: Vector2D): Vector2D;
	static CenterOf(Geom: Geometry): Vector2D;
	static FindClosestPointOnGeom(Geom: Geometry,TestPoint: Vector2D): Vector2D;
	static AbsoluteToLocal(Geometry: Geometry,AbsoluteCoordinate: Vector2D): Vector2D;
	static GetAbsoluteSize(Geometry: Geometry): Vector2D;
	static GetLocalSize(Geometry: Geometry): Vector2D;
	static IsUnderLocation(Geometry: Geometry,AbsoluteCoordinate: Vector2D): boolean;
	static LocalToAbsolute(Geometry: Geometry,LocalCoordinate: Vector2D): Vector2D;
}

declare class JavascriptSlateWidget { 
	clone() : JavascriptSlateWidget;
	static C(Other: UObject | any): JavascriptSlateWidget;
	EditorAddModalWindow(): void;
	AddWindow(bShowImmediately: boolean): void;
	AddWindowAsNativeChild(RootWindow: JavascriptSlateWidget): void;
	static EditorAddModalWindow(Widget: JavascriptSlateWidget): void;
	static AddWindow(NewWindow: JavascriptSlateWidget,bShowImmediately: boolean): void;
	static AddWindowAsNativeChild(NewWindow: JavascriptSlateWidget,RootWindow: JavascriptSlateWidget): void;
	static CreateLogListingWidget(InLogName: string): JavascriptSlateWidget;
	static GetRootWindow(): JavascriptSlateWidget;
}

declare type EHorizontalAlignment = 'HAlign_Fill' | 'HAlign_Left' | 'HAlign_Center' | 'HAlign_Right';
declare var EHorizontalAlignment : { HAlign_Fill:'HAlign_Fill',HAlign_Left:'HAlign_Left',HAlign_Center:'HAlign_Center',HAlign_Right:'HAlign_Right', };
declare type EVerticalAlignment = 'VAlign_Fill' | 'VAlign_Top' | 'VAlign_Center' | 'VAlign_Bottom';
declare var EVerticalAlignment : { VAlign_Fill:'VAlign_Fill',VAlign_Top:'VAlign_Top',VAlign_Center:'VAlign_Center',VAlign_Bottom:'VAlign_Bottom', };
declare class BorderSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): BorderSlot;
	static Find(Outer: UObject, ResourceName: string): BorderSlot;
	static GetDefaultObject(): BorderSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BorderSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): BorderSlot;
}

declare class Anchors { 
	Minimum: Vector2D;
	Maximum: Vector2D;
	clone() : Anchors;
	static C(Other: UObject | any): Anchors;
}

declare class AnchorData { 
	Offsets: Margin;
	Anchors: Anchors;
	Alignment: Vector2D;
	clone() : AnchorData;
	static C(Other: UObject | any): AnchorData;
}

declare class CanvasPanelSlot extends PanelSlot { 
	LayoutData: AnchorData;
	bAutoSize: boolean;
	ZOrder: number;
	static Load(ResourceName: string): CanvasPanelSlot;
	static Find(Outer: UObject, ResourceName: string): CanvasPanelSlot;
	static GetDefaultObject(): CanvasPanelSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanelSlot;
	SetZOrder(InZOrder: number): void;
	SetSize(InSize: Vector2D): void;
	SetPosition(InPosition: Vector2D): void;
	SetOffsets(InOffset: Margin): void;
	SetMinimum(InMinimumAnchors: Vector2D): void;
	SetMaximum(InMaximumAnchors: Vector2D): void;
	SetLayout(InLayoutData: AnchorData): void;
	SetAutoSize(InbAutoSize: boolean): void;
	SetAnchors(InAnchors: Anchors): void;
	SetAlignment(InAlignment: Vector2D): void;
	GetZOrder(): number;
	GetSize(): Vector2D;
	GetPosition(): Vector2D;
	GetOffsets(): Margin;
	GetLayout(): AnchorData;
	GetAutoSize(): boolean;
	GetAnchors(): Anchors;
	GetAlignment(): Vector2D;
	static C(Other: UObject | any): CanvasPanelSlot;
}

declare class GridSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Row: number;
	RowSpan: number;
	Column: number;
	ColumnSpan: number;
	Layer: number;
	Nudge: Vector2D;
	static Load(ResourceName: string): GridSlot;
	static Find(Outer: UObject, ResourceName: string): GridSlot;
	static GetDefaultObject(): GridSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetRowSpan(InRowSpan: number): void;
	SetRow(InRow: number): void;
	SetPadding(InPadding: Margin): void;
	SetLayer(InLayer: number): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetColumnSpan(InColumnSpan: number): void;
	SetColumn(InColumn: number): void;
	static C(Other: UObject | any): GridSlot;
}

declare type ESlateSizeRule = 'Automatic' | 'Fill';
declare var ESlateSizeRule : { Automatic:'Automatic',Fill:'Fill', };
declare class SlateChildSize { 
	Value: number;
	SizeRule: ESlateSizeRule;
	clone() : SlateChildSize;
	static C(Other: UObject | any): SlateChildSize;
}

declare class HorizontalBoxSlot extends PanelSlot { 
	Padding: Margin;
	Size: SlateChildSize;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): HorizontalBoxSlot;
	static Find(Outer: UObject, ResourceName: string): HorizontalBoxSlot;
	static GetDefaultObject(): HorizontalBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetSize(InSize: SlateChildSize): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): HorizontalBoxSlot;
}

declare class OverlaySlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): OverlaySlot;
	static Find(Outer: UObject, ResourceName: string): OverlaySlot;
	static GetDefaultObject(): OverlaySlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OverlaySlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): OverlaySlot;
}

declare class UniformGridSlot extends PanelSlot { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Row: number;
	Column: number;
	static Load(ResourceName: string): UniformGridSlot;
	static Find(Outer: UObject, ResourceName: string): UniformGridSlot;
	static GetDefaultObject(): UniformGridSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetRow(InRow: number): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetColumn(InColumn: number): void;
	static C(Other: UObject | any): UniformGridSlot;
}

declare class VerticalBoxSlot extends PanelSlot { 
	Padding: Margin;
	Size: SlateChildSize;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): VerticalBoxSlot;
	static Find(Outer: UObject, ResourceName: string): VerticalBoxSlot;
	static GetDefaultObject(): VerticalBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetSize(InSize: SlateChildSize): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): VerticalBoxSlot;
}

declare class Widget extends Visual { 
	Slot: PanelSlot;
	bIsEnabledDelegate: UnrealEngineDelegate<() => boolean>;
	ToolTipText: string;
	ToolTipTextDelegate: UnrealEngineDelegate<() => string>;
	ToolTipWidget: Widget;
	ToolTipWidgetDelegate: UnrealEngineDelegate<() => Widget>;
	VisibilityDelegate: UnrealEngineDelegate<() => ReturnValue>;
	RenderTransform: WidgetTransform;
	RenderTransformPivot: Vector2D;
	bIsVariable: boolean;
	bCreatedByConstructionScript: boolean;
	bIsEnabled: boolean;
	bOverride_Cursor: boolean;
	bIsVolatile: boolean;
	bHiddenInDesigner: boolean;
	bExpandedInDesigner: boolean;
	bLockedInDesigner: boolean;
	Cursor: EMouseCursor;
	Clipping: Clipping;
	Visibility: Visibility;
	Navigation: WidgetNavigation;
	NativeBindings: PropertyBinding[];
	DesignerFlags: EWidgetDesignFlags;
	DisplayLabel: string;
	static Load(ResourceName: string): Widget;
	static Find(Outer: UObject, ResourceName: string): Widget;
	static GetDefaultObject(): Widget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Widget;
	SetVisibility(InVisibility: InVisibility): void;
	SetUserFocus(PlayerController: PlayerController): void;
	SetToolTipText(InToolTipText: string): void;
	SetToolTip(Widget: Widget): void;
	SetRenderTranslation(Translation: Vector2D): void;
	SetRenderTransformPivot(Pivot: Vector2D): void;
	SetRenderTransform(InTransform: WidgetTransform): void;
	SetRenderShear(Shear: Vector2D): void;
	SetRenderScale(Scale: Vector2D): void;
	SetRenderAngle(Angle: number): void;
	SetNavigationRule(Direction: Direction,Rule: Rule,WidgetToFocus: string): void;
	SetKeyboardFocus(): void;
	SetIsEnabled(bInIsEnabled: boolean): void;
	SetCursor(InCursor: EMouseCursor): void;
	SetClipping(InClipping: InClipping): void;
	SetAllNavigationRules(Rule: Rule,WidgetToFocus: string): void;
	ResetCursor(): void;
	RemoveFromParent(): void;
	IsVisible(): boolean;
	IsHovered(): boolean;
	InvalidateLayoutAndVolatility(): void;
	HasUserFocusedDescendants(PlayerController: PlayerController): boolean;
	HasUserFocus(PlayerController: PlayerController): boolean;
	HasMouseCapture(): boolean;
	HasKeyboardFocus(): boolean;
	HasFocusedDescendants(): boolean;
	HasAnyUserFocus(): boolean;
	GetVisibility(): ReturnValue;
	GetParent(): PanelWidget;
	GetOwningPlayer(): PlayerController;
	GetIsEnabled(): boolean;
	GetDesiredSize(): Vector2D;
	GetClipping(): ReturnValue;
	GetCachedGeometry(): Geometry;
	ForceVolatile(bForce: boolean): void;
	ForceLayoutPrepass(): void;
	static C(Other: UObject | any): Widget;
	OpenPopupWindow(PopupDesiredSize: Vector2D,HeadingText: string): void;
	TakeWidget(): JavascriptSlateWidget;
	SlotAsBorderSlot(): BorderSlot;
	SlotAsCanvasSlot(): CanvasPanelSlot;
	SlotAsGridSlot(): GridSlot;
	SlotAsHorizontalBoxSlot(): HorizontalBoxSlot;
	SlotAsOverlaySlot(): OverlaySlot;
	SlotAsUniformGridSlot(): UniformGridSlot;
	SlotAsVerticalBoxSlot(): VerticalBoxSlot;
	static OpenPopupWindow(Widget: Widget,PopupDesiredSize: Vector2D,HeadingText: string): void;
	static TakeWidget(Widget: Widget): JavascriptSlateWidget;
	static SlotAsBorderSlot(Widget: Widget): BorderSlot;
	static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
	static SlotAsGridSlot(Widget: Widget): GridSlot;
	static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
	static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
	static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
	static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
}

declare class MovieSceneSignedObject extends UObject { 
	Signature: Guid;
	static Load(ResourceName: string): MovieSceneSignedObject;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSignedObject;
	static GetDefaultObject(): MovieSceneSignedObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSignedObject;
	static C(Other: UObject | any): MovieSceneSignedObject;
}

declare class FloatRangeBound { 
	Type: ERangeBoundTypes;
	Value: number;
	clone() : FloatRangeBound;
	static C(Other: UObject | any): FloatRangeBound;
}

declare class FloatRange { 
	LowerBound: FloatRangeBound;
	UpperBound: FloatRangeBound;
	clone() : FloatRange;
	static C(Other: UObject | any): FloatRange;
}

declare class MovieSceneEvaluationGroupLUTIndex { 
	LUTOffset: number;
	NumInitPtrs: number;
	NumEvalPtrs: number;
	clone() : MovieSceneEvaluationGroupLUTIndex;
	static C(Other: UObject | any): MovieSceneEvaluationGroupLUTIndex;
}

declare class MovieSceneSequenceID { 
	Value: any;
	clone() : MovieSceneSequenceID;
	static C(Other: UObject | any): MovieSceneSequenceID;
}

declare class MovieSceneTrackIdentifier { 
	Value: any;
	clone() : MovieSceneTrackIdentifier;
	static C(Other: UObject | any): MovieSceneTrackIdentifier;
}

declare class MovieSceneEvaluationFieldTrackPtr { 
	SequenceID: MovieSceneSequenceID;
	TrackIdentifier: MovieSceneTrackIdentifier;
	clone() : MovieSceneEvaluationFieldTrackPtr;
	static C(Other: UObject | any): MovieSceneEvaluationFieldTrackPtr;
}

declare class MovieSceneEvaluationFieldSegmentPtr extends MovieSceneEvaluationFieldTrackPtr { 
	SegmentIndex: number;
	clone() : MovieSceneEvaluationFieldSegmentPtr;
	static C(Other: UObject | any): MovieSceneEvaluationFieldSegmentPtr;
}

declare class MovieSceneEvaluationGroup { 
	LUTIndices: MovieSceneEvaluationGroupLUTIndex[];
	SegmentPtrLUT: MovieSceneEvaluationFieldSegmentPtr[];
	clone() : MovieSceneEvaluationGroup;
	static C(Other: UObject | any): MovieSceneEvaluationGroup;
}

declare class MovieSceneEvaluationKey { 
	SequenceID: MovieSceneSequenceID;
	TrackIdentifier: MovieSceneTrackIdentifier;
	SectionIdentifier: any;
	clone() : MovieSceneEvaluationKey;
	static C(Other: UObject | any): MovieSceneEvaluationKey;
}

declare class MovieSceneOrderedEvaluationKey { 
	Key: MovieSceneEvaluationKey;
	EvaluationIndex: any;
	clone() : MovieSceneOrderedEvaluationKey;
	static C(Other: UObject | any): MovieSceneOrderedEvaluationKey;
}

declare class MovieSceneEvaluationMetaData { 
	ActiveSequences: MovieSceneSequenceID[];
	ActiveEntities: MovieSceneOrderedEvaluationKey[];
	clone() : MovieSceneEvaluationMetaData;
	static C(Other: UObject | any): MovieSceneEvaluationMetaData;
}

declare class MovieSceneEvaluationField { 
	Ranges: FloatRange[];
	Groups: MovieSceneEvaluationGroup[];
	MetaData: MovieSceneEvaluationMetaData[];
	clone() : MovieSceneEvaluationField;
	static C(Other: UObject | any): MovieSceneEvaluationField;
}

declare class MovieSceneSequenceHierarchy { 
	SubSequences: any;
	Hierarchy: any;
	clone() : MovieSceneSequenceHierarchy;
	static C(Other: UObject | any): MovieSceneSequenceHierarchy;
}

declare class MovieSceneTemplateGenerationLedger { 
	LastTrackIdentifier: MovieSceneTrackIdentifier;
	TrackReferenceCounts: any;
	TrackSignatureToTrackIdentifier: any;
	clone() : MovieSceneTemplateGenerationLedger;
	static C(Other: UObject | any): MovieSceneTemplateGenerationLedger;
}

declare class MovieSceneEvaluationTemplate { 
	Tracks: any;
	EvaluationField: MovieSceneEvaluationField;
	Hierarchy: MovieSceneSequenceHierarchy;
	TemplateLedger: MovieSceneTemplateGenerationLedger;
	bHasLegacyTrackInstances: boolean;
	bKeepStaleTracks: boolean;
	clone() : MovieSceneEvaluationTemplate;
	static C(Other: UObject | any): MovieSceneEvaluationTemplate;
}

declare class MovieSceneTrackCompilationParams { 
	bForEditorPreview: boolean;
	bDuringBlueprintCompile: boolean;
	clone() : MovieSceneTrackCompilationParams;
	static C(Other: UObject | any): MovieSceneTrackCompilationParams;
}

declare class MovieSceneSequenceCachedSignature { 
	Sequence: any;
	CachedSignature: Guid;
	clone() : MovieSceneSequenceCachedSignature;
	static C(Other: UObject | any): MovieSceneSequenceCachedSignature;
}

declare class CachedMovieSceneEvaluationTemplate extends MovieSceneEvaluationTemplate { 
	CachedCompilationParams: MovieSceneTrackCompilationParams;
	CachedSignatures: MovieSceneSequenceCachedSignature[];
	clone() : CachedMovieSceneEvaluationTemplate;
	static C(Other: UObject | any): CachedMovieSceneEvaluationTemplate;
}

declare class MovieSceneSequence extends MovieSceneSignedObject { 
	EvaluationTemplate: CachedMovieSceneEvaluationTemplate;
	TemplateParameters: MovieSceneTrackCompilationParams;
	InstancedSubSequenceEvaluationTemplates: any;
	bParentContextsAreSignificant: boolean;
	static Load(ResourceName: string): MovieSceneSequence;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequence;
	static GetDefaultObject(): MovieSceneSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequence;
	static C(Other: UObject | any): MovieSceneSequence;
}

declare type ESpawnOwnership = 'InnerSequence' | 'MasterSequence' | 'External';
declare var ESpawnOwnership : { InnerSequence:'InnerSequence',MasterSequence:'MasterSequence',External:'External', };
declare class MovieSceneSpawnable { 
	Guid: Guid;
	Name: string;
	ObjectTemplate: UObject;
	ChildPossessables: Guid[];
	Ownership: Ownership;
	GeneratedClass: UnrealEngineClass;
	clone() : MovieSceneSpawnable;
	static C(Other: UObject | any): MovieSceneSpawnable;
}

declare class MovieScenePossessable { 
	Guid: Guid;
	Name: string;
	PossessedObjectClass: UnrealEngineClass;
	ParentGuid: Guid;
	clone() : MovieScenePossessable;
	static C(Other: UObject | any): MovieScenePossessable;
}

declare class MovieSceneTrackEvalOptions { 
	bCanEvaluateNearestSection: boolean;
	bEvalNearestSection: boolean;
	bEvaluateInPreroll: boolean;
	bEvaluateInPostroll: boolean;
	bEvaluateNearestSection: boolean;
	clone() : MovieSceneTrackEvalOptions;
	static C(Other: UObject | any): MovieSceneTrackEvalOptions;
}

declare class MovieSceneTrack extends MovieSceneSignedObject { 
	EvalOptions: MovieSceneTrackEvalOptions;
	TrackTint: Color;
	static Load(ResourceName: string): MovieSceneTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrack;
	static GetDefaultObject(): MovieSceneTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrack;
	static C(Other: UObject | any): MovieSceneTrack;
}

declare class MovieSceneBinding { 
	ObjectGuid: Guid;
	BindingName: string;
	Tracks: MovieSceneTrack[];
	clone() : MovieSceneBinding;
	static C(Other: UObject | any): MovieSceneBinding;
}

declare class MovieSceneEditorData { 
	ExpansionStates: any;
	WorkingRange: FloatRange;
	ViewRange: FloatRange;
	clone() : MovieSceneEditorData;
	static C(Other: UObject | any): MovieSceneEditorData;
}

declare class MovieSceneFolder extends UObject { 
	FolderName: string;
	ChildFolders: MovieSceneFolder[];
	ChildMasterTracks: MovieSceneTrack[];
	ChildObjectBindingStrings: string[];
	FolderColor: Color;
	static Load(ResourceName: string): MovieSceneFolder;
	static Find(Outer: UObject, ResourceName: string): MovieSceneFolder;
	static GetDefaultObject(): MovieSceneFolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneFolder;
	static C(Other: UObject | any): MovieSceneFolder;
}

declare class MovieScene extends MovieSceneSignedObject { 
	Spawnables: MovieSceneSpawnable[];
	Possessables: MovieScenePossessable[];
	ObjectBindings: MovieSceneBinding[];
	MasterTracks: MovieSceneTrack[];
	CameraCutTrack: MovieSceneTrack;
	SelectionRange: FloatRange;
	PlaybackRange: FloatRange;
	bPlaybackRangeLocked: boolean;
	bForceFixedFrameIntervalPlayback: boolean;
	FixedFrameInterval: number;
	ObjectsToDisplayNames: any;
	ObjectsToLabels: any;
	EditorData: MovieSceneEditorData;
	RootFolders: MovieSceneFolder[];
	InTime: number;
	OutTime: number;
	StartTime: number;
	EndTime: number;
	static Load(ResourceName: string): MovieScene;
	static Find(Outer: UObject, ResourceName: string): MovieScene;
	static GetDefaultObject(): MovieScene;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene;
	static C(Other: UObject | any): MovieScene;
}

declare class WidgetAnimationBinding { 
	WidgetName: string;
	SlotWidgetName: string;
	AnimationGuid: Guid;
	bIsRootWidget: boolean;
	clone() : WidgetAnimationBinding;
	static C(Other: UObject | any): WidgetAnimationBinding;
}

declare class WidgetAnimation extends MovieSceneSequence { 
	OnAnimationStarted: UnrealEngineMulticastDelegate<() => void>;
	OnAnimationFinished: UnrealEngineMulticastDelegate<() => void>;
	MovieScene: MovieScene;
	AnimationBindings: WidgetAnimationBinding[];
	static Load(ResourceName: string): WidgetAnimation;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimation;
	static GetDefaultObject(): WidgetAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimation;
	GetStartTime(): number;
	GetEndTime(): number;
	static C(Other: UObject | any): WidgetAnimation;
}

declare class UMGSequencePlayer extends UObject { 
	Animation: WidgetAnimation;
	static Load(ResourceName: string): UMGSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): UMGSequencePlayer;
	static GetDefaultObject(): UMGSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGSequencePlayer;
	static C(Other: UObject | any): UMGSequencePlayer;
}

declare class NamedSlotBinding { 
	Name: string;
	Content: Widget;
	clone() : NamedSlotBinding;
	static C(Other: UObject | any): NamedSlotBinding;
}

declare class WidgetTree extends UObject { 
	RootWidget: Widget;
	AllWidgets: Widget[];
	static Load(ResourceName: string): WidgetTree;
	static Find(Outer: UObject, ResourceName: string): WidgetTree;
	static GetDefaultObject(): WidgetTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetTree;
	static C(Other: UObject | any): WidgetTree;
}

declare type EDesignPreviewSizeMode = 'FillScreen' | 'Custom' | 'CustomOnScreen' | 'Desired' | 'DesiredOnScreen';
declare var EDesignPreviewSizeMode : { FillScreen:'FillScreen',Custom:'Custom',CustomOnScreen:'CustomOnScreen',Desired:'Desired',DesiredOnScreen:'DesiredOnScreen', };
declare type EInputEvent = 'IE_Pressed' | 'IE_Released' | 'IE_Repeat' | 'IE_DoubleClick' | 'IE_Axis';
declare var EInputEvent : { IE_Pressed:'IE_Pressed',IE_Released:'IE_Released',IE_Repeat:'IE_Repeat',IE_DoubleClick:'IE_DoubleClick',IE_Axis:'IE_Axis', };
declare class ScriptViewportClient extends UObject { 
	static Load(ResourceName: string): ScriptViewportClient;
	static Find(Outer: UObject, ResourceName: string): ScriptViewportClient;
	static GetDefaultObject(): ScriptViewportClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScriptViewportClient;
	static C(Other: UObject | any): ScriptViewportClient;
}

declare class Console extends UObject { 
	ConsoleTargetPlayer: LocalPlayer;
	DefaultTexture_Black: Texture2D;
	DefaultTexture_White: Texture2D;
	HistoryBuffer: string[];
	static Load(ResourceName: string): Console;
	static Find(Outer: UObject, ResourceName: string): Console;
	static GetDefaultObject(): Console;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Console;
	static C(Other: UObject | any): Console;
}

declare class DebugDisplayProperty { 
	Obj: UObject;
	WithinClass: UnrealEngineClass;
	clone() : DebugDisplayProperty;
	static C(Other: UObject | any): DebugDisplayProperty;
}

declare class OnlineSession extends UObject { 
	static Load(ResourceName: string): OnlineSession;
	static Find(Outer: UObject, ResourceName: string): OnlineSession;
	static GetDefaultObject(): OnlineSession;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineSession;
	static C(Other: UObject | any): OnlineSession;
}

declare type ETravelFailure = 'NoLevel' | 'LoadMapFailure' | 'InvalidURL' | 'PackageMissing' | 'PackageVersion' | 'NoDownload' | 'TravelFailure' | 'CheatCommands' | 'PendingNetGameCreateFailure' | 'CloudSaveFailure' | 'ServerTravelFailure' | 'ClientTravelFailure';
declare var ETravelFailure : { NoLevel:'NoLevel',LoadMapFailure:'LoadMapFailure',InvalidURL:'InvalidURL',PackageMissing:'PackageMissing',PackageVersion:'PackageVersion',NoDownload:'NoDownload',TravelFailure:'TravelFailure',CheatCommands:'CheatCommands',PendingNetGameCreateFailure:'PendingNetGameCreateFailure',CloudSaveFailure:'CloudSaveFailure',ServerTravelFailure:'ServerTravelFailure',ClientTravelFailure:'ClientTravelFailure', };
declare type ENetworkFailure = 'NetDriverAlreadyExists' | 'NetDriverCreateFailure' | 'NetDriverListenFailure' | 'ConnectionLost' | 'ConnectionTimeout' | 'FailureReceived' | 'OutdatedClient' | 'OutdatedServer' | 'PendingConnectionFailure' | 'NetGuidMismatch' | 'NetChecksumMismatch';
declare var ENetworkFailure : { NetDriverAlreadyExists:'NetDriverAlreadyExists',NetDriverCreateFailure:'NetDriverCreateFailure',NetDriverListenFailure:'NetDriverListenFailure',ConnectionLost:'ConnectionLost',ConnectionTimeout:'ConnectionTimeout',FailureReceived:'FailureReceived',OutdatedClient:'OutdatedClient',OutdatedServer:'OutdatedServer',PendingConnectionFailure:'PendingConnectionFailure',NetGuidMismatch:'NetGuidMismatch',NetChecksumMismatch:'NetChecksumMismatch', };
declare class GameInstance extends UObject { 
	LocalPlayers: LocalPlayer[];
	OnlineSession: OnlineSession;
	static Load(ResourceName: string): GameInstance;
	static Find(Outer: UObject, ResourceName: string): GameInstance;
	static GetDefaultObject(): GameInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstance;
	ReceiveShutdown(): void;
	ReceiveInit(): void;
	HandleTravelError(FailureType: ETravelFailure): void;
	HandleNetworkError(FailureType: ENetworkFailure,bIsServer: boolean): void;
	DebugRemovePlayer(ControllerId: number): void;
	DebugCreatePlayer(ControllerId: number): void;
	static C(Other: UObject | any): GameInstance;
}

declare class GameViewportClient extends ScriptViewportClient { 
	ViewportConsole: Console;
	DebugProperties: DebugDisplayProperty[];
	World: World;
	GameInstance: GameInstance;
	static Load(ResourceName: string): GameViewportClient;
	static Find(Outer: UObject, ResourceName: string): GameViewportClient;
	static GetDefaultObject(): GameViewportClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameViewportClient;
	SSSwapControllers(): void;
	ShowTitleSafeArea(): void;
	SetConsoleTarget(PlayerIndex: number): void;
	static C(Other: UObject | any): GameViewportClient;
}

declare type EAspectRatioAxisConstraint = 'AspectRatio_MaintainYFOV' | 'AspectRatio_MaintainXFOV' | 'AspectRatio_MajorAxisFOV';
declare var EAspectRatioAxisConstraint : { AspectRatio_MaintainYFOV:'AspectRatio_MaintainYFOV',AspectRatio_MaintainXFOV:'AspectRatio_MaintainXFOV',AspectRatio_MajorAxisFOV:'AspectRatio_MajorAxisFOV', };
declare class LocalPlayer extends Player { 
	ViewportClient: GameViewportClient;
	AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
	PendingLevelPlayerControllerClass: UnrealEngineClass;
	bSentSplitJoin: boolean;
	ControllerId: number;
	static Load(ResourceName: string): LocalPlayer;
	static Find(Outer: UObject, ResourceName: string): LocalPlayer;
	static GetDefaultObject(): LocalPlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalPlayer;
	static C(Other: UObject | any): LocalPlayer;
}

declare type EAudioOutputTarget = 'Speaker' | 'Controller' | 'ControllerFallbackToSpeaker';
declare var EAudioOutputTarget : { Speaker:'Speaker',Controller:'Controller',ControllerFallbackToSpeaker:'ControllerFallbackToSpeaker', };
declare class SoundClassProperties { 
	Volume: number;
	Pitch: number;
	StereoBleed: number;
	LFEBleed: number;
	VoiceCenterChannelVolume: number;
	RadioFilterVolume: number;
	RadioFilterVolumeThreshold: number;
	bApplyEffects: boolean;
	bAlwaysPlay: boolean;
	bIsUISound: boolean;
	bIsMusic: boolean;
	bReverb: boolean;
	Default2DReverbSendAmount: number;
	bCenterChannelOnly: boolean;
	bApplyAmbientVolumes: boolean;
	OutputTarget: EAudioOutputTarget;
	clone() : SoundClassProperties;
	static C(Other: UObject | any): SoundClassProperties;
}

declare class AudioEQEffect { 
	FrequencyCenter0: number;
	Gain0: number;
	Bandwidth0: number;
	FrequencyCenter1: number;
	Gain1: number;
	Bandwidth1: number;
	FrequencyCenter2: number;
	Gain2: number;
	Bandwidth2: number;
	FrequencyCenter3: number;
	Gain3: number;
	Bandwidth3: number;
	clone() : AudioEQEffect;
	static C(Other: UObject | any): AudioEQEffect;
}

declare class SoundClassAdjuster { 
	SoundClassObject: SoundClass;
	VolumeAdjuster: number;
	PitchAdjuster: number;
	bApplyToChildren: boolean;
	VoiceCenterChannelVolumeAdjuster: number;
	clone() : SoundClassAdjuster;
	static C(Other: UObject | any): SoundClassAdjuster;
}

declare class SoundMix extends UObject { 
	bApplyEQ: boolean;
	EQPriority: number;
	EQSettings: AudioEQEffect;
	SoundClassEffects: SoundClassAdjuster[];
	InitialDelay: number;
	FadeInTime: number;
	Duration: number;
	FadeOutTime: number;
	bChanged: boolean;
	static Load(ResourceName: string): SoundMix;
	static Find(Outer: UObject, ResourceName: string): SoundMix;
	static GetDefaultObject(): SoundMix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMix;
	static C(Other: UObject | any): SoundMix;
}

declare class PassiveSoundMixModifier { 
	SoundMix: SoundMix;
	MinVolumeThreshold: number;
	MaxVolumeThreshold: number;
	clone() : PassiveSoundMixModifier;
	static C(Other: UObject | any): PassiveSoundMixModifier;
}

declare class SoundClass extends UObject { 
	Properties: SoundClassProperties;
	ChildClasses: SoundClass[];
	PassiveSoundMixModifiers: PassiveSoundMixModifier[];
	ParentClass: SoundClass;
	static Load(ResourceName: string): SoundClass;
	static Find(Outer: UObject, ResourceName: string): SoundClass;
	static GetDefaultObject(): SoundClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClass;
	static C(Other: UObject | any): SoundClass;
}

declare type EMaxConcurrentResolutionRule = 'PreventNew' | 'StopOldest' | 'StopFarthestThenPreventNew' | 'StopFarthestThenOldest' | 'StopLowestPriority' | 'StopQuietest' | 'StopLowestPriorityThenPreventNew';
declare var EMaxConcurrentResolutionRule : { PreventNew:'PreventNew',StopOldest:'StopOldest',StopFarthestThenPreventNew:'StopFarthestThenPreventNew',StopFarthestThenOldest:'StopFarthestThenOldest',StopLowestPriority:'StopLowestPriority',StopQuietest:'StopQuietest',StopLowestPriorityThenPreventNew:'StopLowestPriorityThenPreventNew', };
declare class SoundConcurrencySettings { 
	MaxCount: number;
	bLimitToOwner: boolean;
	ResolutionRule: EMaxConcurrentResolutionRule;
	VolumeScale: number;
	clone() : SoundConcurrencySettings;
	static C(Other: UObject | any): SoundConcurrencySettings;
}

declare class SoundConcurrency extends UObject { 
	Concurrency: SoundConcurrencySettings;
	static Load(ResourceName: string): SoundConcurrency;
	static Find(Outer: UObject, ResourceName: string): SoundConcurrency;
	static GetDefaultObject(): SoundConcurrency;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundConcurrency;
	static C(Other: UObject | any): SoundConcurrency;
}

declare type ESoundDistanceCalc = 'SOUNDDISTANCE_Normal' | 'SOUNDDISTANCE_InfiniteXYPlane' | 'SOUNDDISTANCE_InfiniteXZPlane' | 'SOUNDDISTANCE_InfiniteYZPlane';
declare var ESoundDistanceCalc : { SOUNDDISTANCE_Normal:'SOUNDDISTANCE_Normal',SOUNDDISTANCE_InfiniteXYPlane:'SOUNDDISTANCE_InfiniteXYPlane',SOUNDDISTANCE_InfiniteXZPlane:'SOUNDDISTANCE_InfiniteXZPlane',SOUNDDISTANCE_InfiniteYZPlane:'SOUNDDISTANCE_InfiniteYZPlane', };
declare type ESoundSpatializationAlgorithm = 'SPATIALIZATION_Default' | 'SPATIALIZATION_HRTF';
declare var ESoundSpatializationAlgorithm : { SPATIALIZATION_Default:'SPATIALIZATION_Default',SPATIALIZATION_HRTF:'SPATIALIZATION_HRTF', };
declare class SpatializationPluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): SpatializationPluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SpatializationPluginSourceSettingsBase;
	static GetDefaultObject(): SpatializationPluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpatializationPluginSourceSettingsBase;
	static C(Other: UObject | any): SpatializationPluginSourceSettingsBase;
}

declare type EAirAbsorptionMethod = 'Linear' | 'CustomCurve';
declare var EAirAbsorptionMethod : { Linear:'Linear',CustomCurve:'CustomCurve', };
declare class OcclusionPluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): OcclusionPluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): OcclusionPluginSourceSettingsBase;
	static GetDefaultObject(): OcclusionPluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OcclusionPluginSourceSettingsBase;
	static C(Other: UObject | any): OcclusionPluginSourceSettingsBase;
}

declare type EReverbSendMethod = 'Linear' | 'CustomCurve' | 'Manual';
declare var EReverbSendMethod : { Linear:'Linear',CustomCurve:'CustomCurve',Manual:'Manual', };
declare class ReverbPluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): ReverbPluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): ReverbPluginSourceSettingsBase;
	static GetDefaultObject(): ReverbPluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbPluginSourceSettingsBase;
	static C(Other: UObject | any): ReverbPluginSourceSettingsBase;
}

declare class SoundAttenuationSettings extends BaseAttenuationSettings { 
	bAttenuate: boolean;
	bSpatialize: boolean;
	bAttenuateWithLPF: boolean;
	bEnableListenerFocus: boolean;
	bEnableFocusInterpolation: boolean;
	bEnableOcclusion: boolean;
	bUseComplexCollisionForOcclusion: boolean;
	bEnableReverbSend: boolean;
	bApplyNormalizationToStereoSounds: boolean;
	bEnableLogFrequencyScaling: boolean;
	DistanceType: ESoundDistanceCalc;
	OmniRadius: number;
	StereoSpread: number;
	SpatializationAlgorithm: ESoundSpatializationAlgorithm;
	SpatializationPluginSettings: SpatializationPluginSourceSettingsBase;
	RadiusMin: number;
	RadiusMax: number;
	LPFRadiusMin: number;
	LPFRadiusMax: number;
	AbsorptionMethod: AbsorptionMethod;
	CustomLowpassAirAbsorptionCurve: RuntimeFloatCurve;
	CustomHighpassAirAbsorptionCurve: RuntimeFloatCurve;
	LPFFrequencyAtMin: number;
	LPFFrequencyAtMax: number;
	HPFFrequencyAtMin: number;
	HPFFrequencyAtMax: number;
	FocusAzimuth: number;
	NonFocusAzimuth: number;
	FocusDistanceScale: number;
	NonFocusDistanceScale: number;
	FocusPriorityScale: number;
	NonFocusPriorityScale: number;
	FocusVolumeAttenuation: number;
	NonFocusVolumeAttenuation: number;
	FocusAttackInterpSpeed: number;
	FocusReleaseInterpSpeed: number;
	OcclusionTraceChannel: ECollisionChannel;
	OcclusionLowPassFilterFrequency: number;
	OcclusionVolumeAttenuation: number;
	OcclusionInterpolationTime: number;
	OcclusionPluginSettings: OcclusionPluginSourceSettingsBase;
	ReverbSendMethod: ReverbSendMethod;
	ReverbPluginSettings: ReverbPluginSourceSettingsBase;
	ReverbWetLevelMin: number;
	ReverbWetLevelMax: number;
	ReverbDistanceMin: number;
	ReverbDistanceMax: number;
	CustomReverbSendCurve: RuntimeFloatCurve;
	ManualReverbSendLevel: number;
	clone() : SoundAttenuationSettings;
	static C(Other: UObject | any): SoundAttenuationSettings;
}

declare class SoundAttenuation extends UObject { 
	Attenuation: SoundAttenuationSettings;
	static Load(ResourceName: string): SoundAttenuation;
	static Find(Outer: UObject, ResourceName: string): SoundAttenuation;
	static GetDefaultObject(): SoundAttenuation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuation;
	static C(Other: UObject | any): SoundAttenuation;
}

declare class SoundEffectPreset extends UObject { 
	static Load(ResourceName: string): SoundEffectPreset;
	static Find(Outer: UObject, ResourceName: string): SoundEffectPreset;
	static GetDefaultObject(): SoundEffectPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectPreset;
	static C(Other: UObject | any): SoundEffectPreset;
}

declare class SoundEffectSubmixPreset extends SoundEffectPreset { 
	static Load(ResourceName: string): SoundEffectSubmixPreset;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSubmixPreset;
	static GetDefaultObject(): SoundEffectSubmixPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSubmixPreset;
	static C(Other: UObject | any): SoundEffectSubmixPreset;
}

declare class SoundSubmix extends UObject { 
	ChildSubmixes: SoundSubmix[];
	ParentSubmix: SoundSubmix;
	SubmixEffectChain: SoundEffectSubmixPreset[];
	static Load(ResourceName: string): SoundSubmix;
	static Find(Outer: UObject, ResourceName: string): SoundSubmix;
	static GetDefaultObject(): SoundSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmix;
	static C(Other: UObject | any): SoundSubmix;
}

declare class SoundSubmixSendInfo { 
	SendLevel: number;
	SoundSubmix: SoundSubmix;
	clone() : SoundSubmixSendInfo;
	static C(Other: UObject | any): SoundSubmixSendInfo;
}

declare class SoundEffectSourcePreset extends SoundEffectPreset { 
	static Load(ResourceName: string): SoundEffectSourcePreset;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSourcePreset;
	static GetDefaultObject(): SoundEffectSourcePreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSourcePreset;
	static C(Other: UObject | any): SoundEffectSourcePreset;
}

declare class SourceEffectChainEntry { 
	Preset: SoundEffectSourcePreset;
	bBypass: boolean;
	clone() : SourceEffectChainEntry;
	static C(Other: UObject | any): SourceEffectChainEntry;
}

declare class SoundEffectSourcePresetChain extends UObject { 
	Chain: SourceEffectChainEntry[];
	bPlayEffectChainTails: boolean;
	static Load(ResourceName: string): SoundEffectSourcePresetChain;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSourcePresetChain;
	static GetDefaultObject(): SoundEffectSourcePresetChain;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSourcePresetChain;
	static C(Other: UObject | any): SoundEffectSourcePresetChain;
}

declare type ESoundGroup = 'SOUNDGROUP_Default' | 'SOUNDGROUP_Effects' | 'SOUNDGROUP_UI' | 'SOUNDGROUP_Music' | 'SOUNDGROUP_Voice' | 'SOUNDGROUP_GameSoundGroup1' | 'SOUNDGROUP_GameSoundGroup2' | 'SOUNDGROUP_GameSoundGroup3' | 'SOUNDGROUP_GameSoundGroup4' | 'SOUNDGROUP_GameSoundGroup5' | 'SOUNDGROUP_GameSoundGroup6' | 'SOUNDGROUP_GameSoundGroup7' | 'SOUNDGROUP_GameSoundGroup8' | 'SOUNDGROUP_GameSoundGroup9' | 'SOUNDGROUP_GameSoundGroup10' | 'SOUNDGROUP_GameSoundGroup11' | 'SOUNDGROUP_GameSoundGroup12' | 'SOUNDGROUP_GameSoundGroup13' | 'SOUNDGROUP_GameSoundGroup14' | 'SOUNDGROUP_GameSoundGroup15' | 'SOUNDGROUP_GameSoundGroup16' | 'SOUNDGROUP_GameSoundGroup17' | 'SOUNDGROUP_GameSoundGroup18' | 'SOUNDGROUP_GameSoundGroup19' | 'SOUNDGROUP_GameSoundGroup20';
declare var ESoundGroup : { SOUNDGROUP_Default:'SOUNDGROUP_Default',SOUNDGROUP_Effects:'SOUNDGROUP_Effects',SOUNDGROUP_UI:'SOUNDGROUP_UI',SOUNDGROUP_Music:'SOUNDGROUP_Music',SOUNDGROUP_Voice:'SOUNDGROUP_Voice',SOUNDGROUP_GameSoundGroup1:'SOUNDGROUP_GameSoundGroup1',SOUNDGROUP_GameSoundGroup2:'SOUNDGROUP_GameSoundGroup2',SOUNDGROUP_GameSoundGroup3:'SOUNDGROUP_GameSoundGroup3',SOUNDGROUP_GameSoundGroup4:'SOUNDGROUP_GameSoundGroup4',SOUNDGROUP_GameSoundGroup5:'SOUNDGROUP_GameSoundGroup5',SOUNDGROUP_GameSoundGroup6:'SOUNDGROUP_GameSoundGroup6',SOUNDGROUP_GameSoundGroup7:'SOUNDGROUP_GameSoundGroup7',SOUNDGROUP_GameSoundGroup8:'SOUNDGROUP_GameSoundGroup8',SOUNDGROUP_GameSoundGroup9:'SOUNDGROUP_GameSoundGroup9',SOUNDGROUP_GameSoundGroup10:'SOUNDGROUP_GameSoundGroup10',SOUNDGROUP_GameSoundGroup11:'SOUNDGROUP_GameSoundGroup11',SOUNDGROUP_GameSoundGroup12:'SOUNDGROUP_GameSoundGroup12',SOUNDGROUP_GameSoundGroup13:'SOUNDGROUP_GameSoundGroup13',SOUNDGROUP_GameSoundGroup14:'SOUNDGROUP_GameSoundGroup14',SOUNDGROUP_GameSoundGroup15:'SOUNDGROUP_GameSoundGroup15',SOUNDGROUP_GameSoundGroup16:'SOUNDGROUP_GameSoundGroup16',SOUNDGROUP_GameSoundGroup17:'SOUNDGROUP_GameSoundGroup17',SOUNDGROUP_GameSoundGroup18:'SOUNDGROUP_GameSoundGroup18',SOUNDGROUP_GameSoundGroup19:'SOUNDGROUP_GameSoundGroup19',SOUNDGROUP_GameSoundGroup20:'SOUNDGROUP_GameSoundGroup20', };
declare class SubtitleCue { 
	Text: string;
	Time: number;
	clone() : SubtitleCue;
	static C(Other: UObject | any): SubtitleCue;
}

declare class LocalizedSubtitle { 
	LanguageExt: string;
	Subtitles: SubtitleCue[];
	bMature: boolean;
	bManualWordWrap: boolean;
	bSingleLine: boolean;
	clone() : LocalizedSubtitle;
	static C(Other: UObject | any): LocalizedSubtitle;
}

declare type EEvaluateCurveTableResult = 'RowFound' | 'RowNotFound';
declare var EEvaluateCurveTableResult : { RowFound:'RowFound',RowNotFound:'RowNotFound', };
declare class CurveTable extends UObject { 
	AssetImportData: AssetImportData;
	ImportPath: string;
	static Load(ResourceName: string): CurveTable;
	static Find(Outer: UObject, ResourceName: string): CurveTable;
	static GetDefaultObject(): CurveTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveTable;
	static C(Other: UObject | any): CurveTable;
	EvaluateCurveTableRow(RowName: string,InXY: number,OutResult?: EEvaluateCurveTableResult,OutXY?: number,ContextString?: string): {OutResult: EEvaluateCurveTableResult, OutXY: number};
	static EvaluateCurveTableRow(CurveTable: CurveTable,RowName: string,InXY: number,OutResult?: EEvaluateCurveTableResult,OutXY?: number,ContextString?: string): {OutResult: EEvaluateCurveTableResult, OutXY: number};
}

declare class SoundWave extends SoundBase { 
	CompressionQuality: number;
	bLooping: boolean;
	bStreaming: boolean;
	StreamingPriority: number;
	bMature: boolean;
	bManualWordWrap: boolean;
	bSingleLine: boolean;
	bVirtualizeWhenSilent: boolean;
	SoundGroup: ESoundGroup;
	SpokenText: string;
	SubtitlePriority: number;
	Volume: number;
	Pitch: number;
	NumChannels: number;
	SampleRate: number;
	ChannelOffsets: number[];
	ChannelSizes: number[];
	RawPCMDataSize: number;
	Subtitles: SubtitleCue[];
	Comment: string;
	LocalizedSubtitles: LocalizedSubtitle[];
	SourceFilePath: string;
	SourceFileTimestamp: string;
	AssetImportData: AssetImportData;
	Curves: CurveTable;
	InternalCurves: CurveTable;
	static Load(ResourceName: string): SoundWave;
	static Find(Outer: UObject, ResourceName: string): SoundWave;
	static GetDefaultObject(): SoundWave;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWave;
	static C(Other: UObject | any): SoundWave;
}

declare type ESourceBusChannels = 'Mono' | 'Stereo';
declare var ESourceBusChannels : { Mono:'Mono',Stereo:'Stereo', };
declare class SoundSourceBus extends SoundWave { 
	SourceBusChannels: SourceBusChannels;
	SourceBusDuration: number;
	bAutoDeactivateWhenSilent: boolean;
	static Load(ResourceName: string): SoundSourceBus;
	static Find(Outer: UObject, ResourceName: string): SoundSourceBus;
	static GetDefaultObject(): SoundSourceBus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceBus;
	static C(Other: UObject | any): SoundSourceBus;
}

declare class SoundSourceBusSendInfo { 
	SendLevel: number;
	SoundSourceBus: SoundSourceBus;
	clone() : SoundSourceBusSendInfo;
	static C(Other: UObject | any): SoundSourceBusSendInfo;
}

declare class AudioComponentParam { 
	ParamName: string;
	FloatParam: number;
	BoolParam: boolean;
	IntParam: number;
	SoundWaveParam: SoundWave;
	clone() : AudioComponentParam;
	static C(Other: UObject | any): AudioComponentParam;
}

declare class AudioComponent extends SceneComponent { 
	Sound: SoundBase;
	InstanceParameters: AudioComponentParam[];
	SoundClassOverride: SoundClass;
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bShouldRemainActiveIfDropped: boolean;
	bAllowSpatialization: boolean;
	bOverrideAttenuation: boolean;
	bOverrideSubtitlePriority: boolean;
	bIsUISound: boolean;
	bEnableLowPassFilter: boolean;
	bOverridePriority: boolean;
	bSuppressSubtitles: boolean;
	AudioComponentUserID: string;
	PitchModulationMin: number;
	PitchModulationMax: number;
	VolumeModulationMin: number;
	VolumeModulationMax: number;
	VolumeMultiplier: number;
	Priority: number;
	SubtitlePriority: number;
	VolumeWeightedPriorityScale: number;
	PitchMultiplier: number;
	HighFrequencyGainMultiplier: number;
	LowPassFilterFrequency: number;
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	ConcurrencySettings: SoundConcurrency;
	OnAudioFinished: UnrealEngineMulticastDelegate<() => void>;
	OnAudioPlaybackPercent: UnrealEngineMulticastDelegate<(PlayingSoundWave: SoundWave, PlaybackPercent: number) => void>;
	OnQueueSubtitles: UnrealEngineDelegate<(Subtitles: SubtitleCue[], CueDuration: number) => void>;
	static Load(ResourceName: string): AudioComponent;
	static Find(Outer: UObject, ResourceName: string): AudioComponent;
	static GetDefaultObject(): AudioComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioComponent;
	Stop(): void;
	SetWaveParameter(InName: string,InWave: SoundWave): void;
	SetVolumeMultiplier(NewVolumeMultiplier: number): void;
	SetUISound(bInUISound: boolean): void;
	SetSubmixSend(Submix: SoundSubmix,SendLevel: number): void;
	SetSound(NewSound: SoundBase): void;
	SetPitchMultiplier(NewPitchMultiplier: number): void;
	SetPaused(bPause: boolean): void;
	SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;
	SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;
	SetIntParameter(InName: string,InInt: number): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetBoolParameter(InName: string,InBool: boolean): void;
	Play(StartTime: number): void;
	IsPlaying(): boolean;
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number): void;
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number,StartTime: number): void;
	BP_GetAttenuationSettingsToApply(OutAttenuationSettings?: SoundAttenuationSettings): {OutAttenuationSettings: SoundAttenuationSettings, $: boolean};
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number): void;
	AdjustAttenuation(InAttenuationSettings: SoundAttenuationSettings): void;
	static C(Other: UObject | any): AudioComponent;
}

declare class SoundBase extends UObject { 
	SoundClassObject: SoundClass;
	bDebug: boolean;
	bOverrideConcurrency: boolean;
	bOutputToBusOnly: boolean;
	bIgnoreFocus: boolean;
	SoundConcurrencySettings: SoundConcurrency;
	ConcurrencyOverrides: SoundConcurrencySettings;
	MaxConcurrentResolutionRule: EMaxConcurrentResolutionRule;
	MaxConcurrentPlayCount: number;
	Duration: number;
	AttenuationSettings: SoundAttenuation;
	Priority: number;
	SoundSubmixObject: SoundSubmix;
	SoundSubmixSends: SoundSubmixSendInfo[];
	SourceEffectChain: SoundEffectSourcePresetChain;
	BusSends: SoundSourceBusSendInfo[];
	static Load(ResourceName: string): SoundBase;
	static Find(Outer: UObject, ResourceName: string): SoundBase;
	static GetDefaultObject(): SoundBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundBase;
	static C(Other: UObject | any): SoundBase;
	SpawnSoundAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static SpawnSoundAttached(Sound: SoundBase,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
}

declare type EUMGSequencePlayMode = 'Forward' | 'Reverse' | 'PingPong';
declare var EUMGSequencePlayMode : { Forward:'Forward',Reverse:'Reverse',PingPong:'PingPong', };
declare class InputEvent { 
	clone() : InputEvent;
	static C(Other: UObject | any): InputEvent;
	InputEvent_IsAltDown(): boolean;
	InputEvent_IsCommandDown(): boolean;
	InputEvent_IsControlDown(): boolean;
	InputEvent_IsLeftAltDown(): boolean;
	InputEvent_IsLeftCommandDown(): boolean;
	InputEvent_IsLeftControlDown(): boolean;
	InputEvent_IsLeftShiftDown(): boolean;
	InputEvent_IsRepeat(): boolean;
	InputEvent_IsRightAltDown(): boolean;
	InputEvent_IsRightCommandDown(): boolean;
	InputEvent_IsRightControlDown(): boolean;
	InputEvent_IsRightShiftDown(): boolean;
	InputEvent_IsShiftDown(): boolean;
	static InputEvent_IsAltDown(Input: InputEvent): boolean;
	static InputEvent_IsCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsControlDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftAltDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftControlDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsRepeat(Input: InputEvent): boolean;
	static InputEvent_IsRightAltDown(Input: InputEvent): boolean;
	static InputEvent_IsRightCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsRightControlDown(Input: InputEvent): boolean;
	static InputEvent_IsRightShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsShiftDown(Input: InputEvent): boolean;
}

declare type ESlateGesture = 'None' | 'Scroll' | 'Magnify' | 'Swipe' | 'Rotate' | 'LongPress';
declare var ESlateGesture : { None:'None',Scroll:'Scroll',Magnify:'Magnify',Swipe:'Swipe',Rotate:'Rotate',LongPress:'LongPress', };
declare class EventReply { 
	clone() : EventReply;
	static C(Other: UObject | any): EventReply;
	CaptureJoystick(CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	CaptureMouse(CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	ClearUserFocus(bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	DetectDrag(WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	EndDragDrop(): {Reply: EventReply, $: EventReply};
	LockMouse(CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	ReleaseJoystickCapture(bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	ReleaseMouseCapture(): {Reply: EventReply, $: EventReply};
	SetMousePosition(NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	SetUserFocus(FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	UnlockMouse(): {Reply: EventReply, $: EventReply};
	static CaptureJoystick(Reply?: EventReply,CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static CaptureMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static ClearUserFocus(Reply?: EventReply,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static DetectDrag(Reply?: EventReply,WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	static EndDragDrop(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static LockMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static ReleaseJoystickCapture(Reply?: EventReply,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static ReleaseMouseCapture(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static SetMousePosition(Reply?: EventReply,NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	static SetUserFocus(Reply?: EventReply,FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static UnlockMouse(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static Handled(): EventReply;
	static Unhandled(): EventReply;
}

declare class UPointerEvent extends InputEvent { 
	clone() : UPointerEvent;
	static C(Other: UObject | any): UPointerEvent;
	PointerEvent_GetCursorDelta(): Vector2D;
	PointerEvent_GetEffectingButton(): Key;
	PointerEvent_GetGestureDelta(): Vector2D;
	PointerEvent_GetGestureType(): ReturnValue;
	PointerEvent_GetLastScreenSpacePosition(): Vector2D;
	PointerEvent_GetPointerIndex(): number;
	PointerEvent_GetScreenSpacePosition(): Vector2D;
	PointerEvent_GetTouchpadIndex(): number;
	PointerEvent_GetUserIndex(): number;
	PointerEvent_GetWheelDelta(): number;
	PointerEvent_IsMouseButtonDown(MouseButton: Key): boolean;
	PointerEvent_IsTouchEvent(): boolean;
	DetectDragIfPressed(WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	GetInputEventFromPointerEvent(): InputEvent;
	static PointerEvent_GetCursorDelta(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetEffectingButton(Input: UPointerEvent): Key;
	static PointerEvent_GetGestureDelta(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetGestureType(Input: UPointerEvent): ReturnValue;
	static PointerEvent_GetLastScreenSpacePosition(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetPointerIndex(Input: UPointerEvent): number;
	static PointerEvent_GetScreenSpacePosition(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetTouchpadIndex(Input: UPointerEvent): number;
	static PointerEvent_GetUserIndex(Input: UPointerEvent): number;
	static PointerEvent_GetWheelDelta(Input: UPointerEvent): number;
	static PointerEvent_IsMouseButtonDown(Input: UPointerEvent,MouseButton: Key): boolean;
	static PointerEvent_IsTouchEvent(Input: UPointerEvent): boolean;
	static DetectDragIfPressed(UPointerEvent: UPointerEvent,WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	static GetInputEventFromPointerEvent(Event: UPointerEvent): InputEvent;
}

declare class UFocusEvent { 
	clone() : UFocusEvent;
	static C(Other: UObject | any): UFocusEvent;
}

declare class KeyEvent extends InputEvent { 
	clone() : KeyEvent;
	static C(Other: UObject | any): KeyEvent;
	GetKey(): Key;
	GetUserIndex(): number;
	GetInputEventFromKeyEvent(): InputEvent;
	static GetKey(Input: KeyEvent): Key;
	static GetUserIndex(Input: KeyEvent): number;
	static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;
}

declare class SlateBrushAsset extends UObject { 
	Brush: SlateBrush;
	static Load(ResourceName: string): SlateBrushAsset;
	static Find(Outer: UObject, ResourceName: string): SlateBrushAsset;
	static GetDefaultObject(): SlateBrushAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBrushAsset;
	static C(Other: UObject | any): SlateBrushAsset;
	MakeBrushFromAsset(): SlateBrush;
	static MakeBrushFromAsset(BrushAsset: SlateBrushAsset): SlateBrush;
}

declare class PaintContext { 
	clone() : PaintContext;
	static C(Other: UObject | any): PaintContext;
	DrawSpaceSpline(InStart?: Vector2D,InStartDir?: Vector2D,InEnd?: Vector2D,InEndDir?: Vector2D,InThickness?: number,InTint?: LinearColor): {Context: PaintContext};
	DrawBox(Position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	DrawLine(PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean): {Context: PaintContext};
	DrawLines(Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean): {Context: PaintContext};
	DrawText(InString?: string,Position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	DrawTextFormatted(Text?: string,Position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
	static DrawSpaceSpline(Context?: PaintContext,InStart?: Vector2D,InStartDir?: Vector2D,InEnd?: Vector2D,InEndDir?: Vector2D,InThickness?: number,InTint?: LinearColor): {Context: PaintContext};
	static DrawBox(Context?: PaintContext,Position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	static DrawLine(Context?: PaintContext,PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean): {Context: PaintContext};
	static DrawLines(Context?: PaintContext,Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean): {Context: PaintContext};
	static DrawText(Context?: PaintContext,InString?: string,Position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	static DrawTextFormatted(Context?: PaintContext,Text?: string,Position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
}

declare class MotionEvent extends InputEvent { 
	clone() : MotionEvent;
	static C(Other: UObject | any): MotionEvent;
}

declare class CharacterEvent extends InputEvent { 
	clone() : CharacterEvent;
	static C(Other: UObject | any): CharacterEvent;
	GetInputEventFromCharacterEvent(): InputEvent;
	static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;
}

declare type EDragPivot = 'MouseDown' | 'TopLeft' | 'TopCenter' | 'TopRight' | 'CenterLeft' | 'CenterCenter' | 'CenterRight' | 'BottomLeft' | 'BottomCenter' | 'BottomRight';
declare var EDragPivot : { MouseDown:'MouseDown',TopLeft:'TopLeft',TopCenter:'TopCenter',TopRight:'TopRight',CenterLeft:'CenterLeft',CenterCenter:'CenterCenter',CenterRight:'CenterRight',BottomLeft:'BottomLeft',BottomCenter:'BottomCenter',BottomRight:'BottomRight', };
declare class DragDropOperation extends UObject { 
	Tag: string;
	Payload: UObject;
	DefaultDragVisual: Widget;
	Pivot: Pivot;
	Offset: Vector2D;
	OnDrop: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	OnDragCancelled: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	OnDragged: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	static Load(ResourceName: string): DragDropOperation;
	static Find(Outer: UObject, ResourceName: string): DragDropOperation;
	static GetDefaultObject(): DragDropOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DragDropOperation;
	Drop(UPointerEvent: UPointerEvent): void;
	Dragged(UPointerEvent: UPointerEvent): void;
	DragCancelled(UPointerEvent: UPointerEvent): void;
	static C(Other: UObject | any): DragDropOperation;
}

declare class AnalogInputEvent extends KeyEvent { 
	clone() : AnalogInputEvent;
	static C(Other: UObject | any): AnalogInputEvent;
	GetAnalogValue(): number;
	GetKeyEventFromAnalogInputEvent(): KeyEvent;
	static GetAnalogValue(Input: AnalogInputEvent): number;
	static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;
}

declare class UserWidget extends Widget { 
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	ForegroundColor: SlateColor;
	ForegroundColorDelegate: UnrealEngineDelegate<() => SlateColor>;
	Padding: Margin;
	ActiveSequencePlayers: UMGSequencePlayer[];
	StoppedSequencePlayers: UMGSequencePlayer[];
	NamedSlotBindings: NamedSlotBinding[];
	WidgetTree: WidgetTree;
	DesignTimeSize: Vector2D;
	DesignSizeMode: DesignSizeMode;
	PaletteCategory: string;
	PreviewBackground: Texture2D;
	Priority: number;
	bSupportsKeyboardFocus: boolean;
	bIsFocusable: boolean;
	bStopAction: boolean;
	bCanEverTick: boolean;
	bCanEverPaint: boolean;
	bCookedWidgetTree: boolean;
	InputComponent: InputComponent;
	static Load(ResourceName: string): UserWidget;
	static Find(Outer: UObject, ResourceName: string): UserWidget;
	static GetDefaultObject(): UserWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidget;
	UnregisterInputComponent(): void;
	Tick(MyGeometry: Geometry,InDeltaTime: number): void;
	StopListeningForInputAction(ActionName: string,EventType: EInputEvent): void;
	StopListeningForAllInputActions(): void;
	StopAnimation(InAnimation: WidgetAnimation): void;
	SetPositionInViewport(Position: Vector2D,bRemoveDPIScale: boolean): void;
	SetPlaybackSpeed(InAnimation: WidgetAnimation,PlaybackSpeed: number): void;
	SetPadding(InPadding: Margin): void;
	SetOwningPlayer(LocalPlayerController: PlayerController): void;
	SetOwningLocalPlayer(LocalPlayer: LocalPlayer): void;
	SetNumLoopsToPlay(InAnimation: WidgetAnimation,NumLoopsToPlay: number): void;
	SetInputActionPriority(NewPriority: number): void;
	SetInputActionBlocking(bShouldBlock: boolean): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	SetDesiredSizeInViewport(Size: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetAnchorsInViewport(Anchors: Anchors): void;
	SetAlignmentInViewport(Alignment: Vector2D): void;
	ReverseAnimation(InAnimation: WidgetAnimation): void;
	RemoveFromViewport(): void;
	RegisterInputComponent(): void;
	PreConstruct(IsDesignTime: boolean): void;
	PlaySound(SoundToPlay: SoundBase): void;
	PlayAnimationTo(InAnimation: WidgetAnimation,StartAtTime: number,EndAtTime: number,NumLoopsToPlay: number,PlayMode: EUMGSequencePlayMode,PlaybackSpeed: number): void;
	PlayAnimation(InAnimation: WidgetAnimation,StartAtTime: number,NumLoopsToPlay: number,PlayMode: EUMGSequencePlayMode,PlaybackSpeed: number): void;
	PauseAnimation(InAnimation: WidgetAnimation): number;
	OnTouchStarted(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchMoved(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchGesture(MyGeometry: Geometry,GestureEvent: UPointerEvent): EventReply;
	OnTouchEnded(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnRemovedFromFocusPath(InFocusEvent: UFocusEvent): void;
	OnPreviewMouseButtonDown(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnPreviewKeyDown(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnPaint(Context?: PaintContext): {Context: PaintContext};
	OnMouseWheel(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseMove(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseLeave(MouseEvent: UPointerEvent): void;
	OnMouseEnter(MyGeometry: Geometry,MouseEvent: UPointerEvent): void;
	OnMouseCaptureLost(): void;
	OnMouseButtonUp(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseButtonDown(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseButtonDoubleClick(InMyGeometry: Geometry,InMouseEvent: UPointerEvent): EventReply;
	OnMotionDetected(MyGeometry: Geometry,InMotionEvent: MotionEvent): EventReply;
	OnKeyUp(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnKeyDown(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnKeyChar(MyGeometry: Geometry,InCharacterEvent: CharacterEvent): EventReply;
	OnFocusReceived(MyGeometry: Geometry,InFocusEvent: UFocusEvent): EventReply;
	OnFocusLost(InFocusEvent: UFocusEvent): void;
	OnDrop(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): boolean;
	OnDragOver(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): boolean;
	OnDragLeave(UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnDragEnter(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnDragDetected(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation?: DragDropOperation): {Operation: DragDropOperation};
	OnDragCancelled(UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnAnimationStarted(Animation: WidgetAnimation): void;
	OnAnimationFinished(Animation: WidgetAnimation): void;
	OnAnalogValueChanged(MyGeometry: Geometry,InAnalogInputEvent: AnalogInputEvent): EventReply;
	OnAddedToFocusPath(InFocusEvent: UFocusEvent): void;
	IsPlayingAnimation(): boolean;
	IsListeningForInputAction(ActionName: string): boolean;
	IsInViewport(): boolean;
	IsInteractable(): boolean;
	IsAnyAnimationPlaying(): boolean;
	IsAnimationPlayingForward(InAnimation: WidgetAnimation): boolean;
	IsAnimationPlaying(InAnimation: WidgetAnimation): boolean;
	GetOwningPlayerPawn(): Pawn;
	GetOwningPlayer(): PlayerController;
	GetOwningLocalPlayer(): LocalPlayer;
	GetIsVisible(): boolean;
	GetAnimationCurrentTime(InAnimation: WidgetAnimation): number;
	GetAnchorsInViewport(): Anchors;
	GetAlignmentInViewport(): Vector2D;
	Destruct(): void;
	Construct(): void;
	AddToViewport(ZOrder: number): void;
	AddToPlayerScreen(ZOrder: number): boolean;
	static C(Other: UObject | any): UserWidget;
}

declare class ViewTargetTransitionParams { 
	BlendTime: number;
	BlendFunction: EViewTargetBlendFunction;
	BlendExp: number;
	bLockOutgoing: boolean;
	clone() : ViewTargetTransitionParams;
	static C(Other: UObject | any): ViewTargetTransitionParams;
}

declare class HapticFeedbackEffect_Base extends UObject { 
	static Load(ResourceName: string): HapticFeedbackEffect_Base;
	static Find(Outer: UObject, ResourceName: string): HapticFeedbackEffect_Base;
	static GetDefaultObject(): HapticFeedbackEffect_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect_Base;
	static C(Other: UObject | any): HapticFeedbackEffect_Base;
}

declare type EDynamicForceFeedbackAction = 'Start' | 'Update' | 'Stop';
declare var EDynamicForceFeedbackAction : { Start:'Start',Update:'Update',Stop:'Stop', };
declare class LatentActionInfo { 
	Linkage: number;
	UUID: number;
	ExecutionFunction: string;
	CallbackTarget: UObject;
	clone() : LatentActionInfo;
	static C(Other: UObject | any): LatentActionInfo;
}

declare type EObjectTypeQuery = 'ObjectTypeQuery1' | 'ObjectTypeQuery2' | 'ObjectTypeQuery3' | 'ObjectTypeQuery4' | 'ObjectTypeQuery5' | 'ObjectTypeQuery6' | 'ObjectTypeQuery7' | 'ObjectTypeQuery8' | 'ObjectTypeQuery9' | 'ObjectTypeQuery10' | 'ObjectTypeQuery11' | 'ObjectTypeQuery12' | 'ObjectTypeQuery13' | 'ObjectTypeQuery14' | 'ObjectTypeQuery15' | 'ObjectTypeQuery16' | 'ObjectTypeQuery17' | 'ObjectTypeQuery18' | 'ObjectTypeQuery19' | 'ObjectTypeQuery20' | 'ObjectTypeQuery21' | 'ObjectTypeQuery22' | 'ObjectTypeQuery23' | 'ObjectTypeQuery24' | 'ObjectTypeQuery25' | 'ObjectTypeQuery26' | 'ObjectTypeQuery27' | 'ObjectTypeQuery28' | 'ObjectTypeQuery29' | 'ObjectTypeQuery30' | 'ObjectTypeQuery31' | 'ObjectTypeQuery32' | 'ObjectTypeQuery_MAX';
declare var EObjectTypeQuery : { ObjectTypeQuery1:'ObjectTypeQuery1',ObjectTypeQuery2:'ObjectTypeQuery2',ObjectTypeQuery3:'ObjectTypeQuery3',ObjectTypeQuery4:'ObjectTypeQuery4',ObjectTypeQuery5:'ObjectTypeQuery5',ObjectTypeQuery6:'ObjectTypeQuery6',ObjectTypeQuery7:'ObjectTypeQuery7',ObjectTypeQuery8:'ObjectTypeQuery8',ObjectTypeQuery9:'ObjectTypeQuery9',ObjectTypeQuery10:'ObjectTypeQuery10',ObjectTypeQuery11:'ObjectTypeQuery11',ObjectTypeQuery12:'ObjectTypeQuery12',ObjectTypeQuery13:'ObjectTypeQuery13',ObjectTypeQuery14:'ObjectTypeQuery14',ObjectTypeQuery15:'ObjectTypeQuery15',ObjectTypeQuery16:'ObjectTypeQuery16',ObjectTypeQuery17:'ObjectTypeQuery17',ObjectTypeQuery18:'ObjectTypeQuery18',ObjectTypeQuery19:'ObjectTypeQuery19',ObjectTypeQuery20:'ObjectTypeQuery20',ObjectTypeQuery21:'ObjectTypeQuery21',ObjectTypeQuery22:'ObjectTypeQuery22',ObjectTypeQuery23:'ObjectTypeQuery23',ObjectTypeQuery24:'ObjectTypeQuery24',ObjectTypeQuery25:'ObjectTypeQuery25',ObjectTypeQuery26:'ObjectTypeQuery26',ObjectTypeQuery27:'ObjectTypeQuery27',ObjectTypeQuery28:'ObjectTypeQuery28',ObjectTypeQuery29:'ObjectTypeQuery29',ObjectTypeQuery30:'ObjectTypeQuery30',ObjectTypeQuery31:'ObjectTypeQuery31',ObjectTypeQuery32:'ObjectTypeQuery32',ObjectTypeQuery_MAX:'ObjectTypeQuery_MAX', };
declare type ETraceTypeQuery = 'TraceTypeQuery1' | 'TraceTypeQuery2' | 'TraceTypeQuery3' | 'TraceTypeQuery4' | 'TraceTypeQuery5' | 'TraceTypeQuery6' | 'TraceTypeQuery7' | 'TraceTypeQuery8' | 'TraceTypeQuery9' | 'TraceTypeQuery10' | 'TraceTypeQuery11' | 'TraceTypeQuery12' | 'TraceTypeQuery13' | 'TraceTypeQuery14' | 'TraceTypeQuery15' | 'TraceTypeQuery16' | 'TraceTypeQuery17' | 'TraceTypeQuery18' | 'TraceTypeQuery19' | 'TraceTypeQuery20' | 'TraceTypeQuery21' | 'TraceTypeQuery22' | 'TraceTypeQuery23' | 'TraceTypeQuery24' | 'TraceTypeQuery25' | 'TraceTypeQuery26' | 'TraceTypeQuery27' | 'TraceTypeQuery28' | 'TraceTypeQuery29' | 'TraceTypeQuery30' | 'TraceTypeQuery31' | 'TraceTypeQuery32' | 'TraceTypeQuery_MAX';
declare var ETraceTypeQuery : { TraceTypeQuery1:'TraceTypeQuery1',TraceTypeQuery2:'TraceTypeQuery2',TraceTypeQuery3:'TraceTypeQuery3',TraceTypeQuery4:'TraceTypeQuery4',TraceTypeQuery5:'TraceTypeQuery5',TraceTypeQuery6:'TraceTypeQuery6',TraceTypeQuery7:'TraceTypeQuery7',TraceTypeQuery8:'TraceTypeQuery8',TraceTypeQuery9:'TraceTypeQuery9',TraceTypeQuery10:'TraceTypeQuery10',TraceTypeQuery11:'TraceTypeQuery11',TraceTypeQuery12:'TraceTypeQuery12',TraceTypeQuery13:'TraceTypeQuery13',TraceTypeQuery14:'TraceTypeQuery14',TraceTypeQuery15:'TraceTypeQuery15',TraceTypeQuery16:'TraceTypeQuery16',TraceTypeQuery17:'TraceTypeQuery17',TraceTypeQuery18:'TraceTypeQuery18',TraceTypeQuery19:'TraceTypeQuery19',TraceTypeQuery20:'TraceTypeQuery20',TraceTypeQuery21:'TraceTypeQuery21',TraceTypeQuery22:'TraceTypeQuery22',TraceTypeQuery23:'TraceTypeQuery23',TraceTypeQuery24:'TraceTypeQuery24',TraceTypeQuery25:'TraceTypeQuery25',TraceTypeQuery26:'TraceTypeQuery26',TraceTypeQuery27:'TraceTypeQuery27',TraceTypeQuery28:'TraceTypeQuery28',TraceTypeQuery29:'TraceTypeQuery29',TraceTypeQuery30:'TraceTypeQuery30',TraceTypeQuery31:'TraceTypeQuery31',TraceTypeQuery32:'TraceTypeQuery32',TraceTypeQuery_MAX:'TraceTypeQuery_MAX', };
declare type ETravelType = 'TRAVEL_Absolute' | 'TRAVEL_Partial' | 'TRAVEL_Relative';
declare var ETravelType : { TRAVEL_Absolute:'TRAVEL_Absolute',TRAVEL_Partial:'TRAVEL_Partial',TRAVEL_Relative:'TRAVEL_Relative', };
declare type EMouseLockMode = 'DoNotLock' | 'LockOnCapture' | 'LockAlways';
declare var EMouseLockMode : { DoNotLock:'DoNotLock',LockOnCapture:'LockOnCapture',LockAlways:'LockAlways', };
declare class PlayerController extends Controller { 
	Player: Player;
	AcknowledgedPawn: Pawn;
	ControllingDirTrackInst: InterpTrackInstDirector;
	MyHUD: HUD;
	PlayerCameraManager: PlayerCameraManager;
	PlayerCameraManagerClass: UnrealEngineClass;
	bAutoManageActiveCameraTarget: boolean;
	TargetViewRotation: Rotator;
	SmoothTargetViewRotationSpeed: number;
	HiddenActors: Actor[];
	HiddenPrimitiveComponents: any[];
	LastSpectatorStateSynchTime: number;
	LastSpectatorSyncLocation: Vector;
	LastSpectatorSyncRotation: Rotator;
	ClientCap: number;
	CheatManager: CheatManager;
	CheatClass: UnrealEngineClass;
	PlayerInput: PlayerInput;
	ActiveForceFeedbackEffects: ActiveForceFeedbackEffect[];
	bPlayerIsWaiting: boolean;
	NetPlayerIndex: number;
	PendingSwapConnection: NetConnection;
	NetConnection: NetConnection;
	InputYawScale: number;
	InputPitchScale: number;
	InputRollScale: number;
	bShowMouseCursor: boolean;
	bEnableClickEvents: boolean;
	bEnableTouchEvents: boolean;
	bEnableMouseOverEvents: boolean;
	bEnableTouchOverEvents: boolean;
	bForceFeedbackEnabled: boolean;
	ForceFeedbackScale: number;
	ClickEventKeys: Key[];
	DefaultMouseCursor: EMouseCursor;
	CurrentMouseCursor: EMouseCursor;
	DefaultClickTraceChannel: ECollisionChannel;
	CurrentClickTraceChannel: ECollisionChannel;
	HitResultTraceDistance: number;
	InactiveStateInputComponent: InputComponent;
	bShouldPerformFullTickWhenPaused: boolean;
	CurrentTouchInterface: TouchInterface;
	SpectatorPawn: SpectatorPawn;
	SpawnLocation: Vector;
	bIsLocalPlayerController: boolean;
	SeamlessTravelCount: any;
	LastCompletedSeamlessTravelCount: any;
	static GetDefaultObject(): PlayerController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerController;
	WasInputKeyJustReleased(Key: Key): boolean;
	WasInputKeyJustPressed(Key: Key): boolean;
	ToggleSpeaking(bInSpeaking: boolean): void;
	SwitchLevel(URL: string): void;
	StopHapticEffect(Hand: Hand): void;
	StartFire(FireModeNum: number): void;
	SetVirtualJoystickVisibility(bVisible: boolean): void;
	SetViewTargetWithBlend(NewViewTarget: Actor,BlendTime: number,BlendFunc: EViewTargetBlendFunction,BlendExp: number,bLockOutgoing: boolean): void;
	SetName(S: string): void;
	SetMouseLocation(X: number,Y: number): void;
	SetMouseCursorWidget(Cursor: EMouseCursor,CursorWidget: UserWidget): void;
	SetHapticsByValue(Frequency: number,Amplitude: number,Hand: Hand): void;
	SetControllerLightColor(Color: Color): void;
	SetCinematicMode(bInCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	SetAudioListenerOverride(AttachToComponent: SceneComponent,Location: Vector,Rotation: Rotator): void;
	ServerViewSelf(TransitionParams: ViewTargetTransitionParams): void;
	ServerViewPrevPlayer(): void;
	ServerViewNextPlayer(): void;
	ServerVerifyViewTarget(): void;
	ServerUpdateLevelVisibility(PackageName: string,bIsVisible: boolean): void;
	ServerUpdateCamera(CamLoc: Vector_NetQuantize,CamPitchAndYaw: number): void;
	ServerUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	ServerToggleAILogging(): void;
	ServerShortTimeout(): void;
	ServerSetSpectatorWaiting(bWaiting: boolean): void;
	ServerSetSpectatorLocation(NewLoc: Vector,NewRot: Rotator): void;
	ServerRestartPlayer(): void;
	ServerPause(): void;
	ServerNotifyLoadedWorld(WorldPackageName: string): void;
	ServerMutePlayer(PlayerId: UniqueNetIdRepl): void;
	ServerCheckClientPossessionReliable(): void;
	ServerCheckClientPossession(): void;
	ServerChangeName(S: string): void;
	ServerCamera(NewMode: string): void;
	ServerAcknowledgePossession(P: Pawn): void;
	SendToConsole(Command: string): void;
	RestartLevel(): void;
	ProjectWorldLocationToScreen(WorldLocation: Vector,ScreenLocation?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenLocation: Vector2D, $: boolean};
	PlayHapticEffect(HapticEffect: HapticFeedbackEffect_Base,Hand: Hand,Scale: number,bLoop: boolean): void;
	PlayDynamicForceFeedback(Intensity: number,Duration: number,bAffectsLeftLarge: boolean,bAffectsLeftSmall: boolean,bAffectsRightLarge: boolean,bAffectsRightSmall: boolean,Action: EDynamicForceFeedbackAction,LatentInfo: LatentActionInfo): void;
	Pause(): void;
	OnServerStartedVisualLogger(bIsLogging: boolean): void;
	LocalTravel(URL: string): void;
	IsInputKeyDown(Key: Key): boolean;
	GetViewportSize(SizeX?: number,SizeY?: number): {SizeX: number, SizeY: number};
	GetSpectatorPawn(): SpectatorPawn;
	GetMousePosition(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	GetInputVectorKeyState(Key: Key): Vector;
	GetInputTouchState(FingerIndex: ETouchIndex,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	GetInputMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	GetInputMotionState(Tilt?: Vector,RotationRate?: Vector,Gravity?: Vector,Acceleration?: Vector): {Tilt: Vector, RotationRate: Vector, Gravity: Vector, Acceleration: Vector};
	GetInputKeyTimeDown(Key: Key): number;
	GetInputAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	GetInputAnalogKeyState(Key: Key): number;
	GetHUD(): HUD;
	GetHitResultUnderFingerForObjects(FingerIndex: ETouchIndex,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderFingerByChannel(FingerIndex: ETouchIndex,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderFinger(FingerIndex: ETouchIndex,TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursorForObjects(ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursorByChannel(TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursor(TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetFocalLocation(): Vector;
	FOV(NewFOV: number): void;
	EnableCheats(): void;
	DeprojectScreenPositionToWorld(ScreenX: number,ScreenY: number,WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	DeprojectMousePositionToWorld(WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	ConsoleKey(Key: Key): void;
	ClientWasKicked(KickReason: string): void;
	ClientVoiceHandshakeComplete(): void;
	ClientUpdateLevelStreamingStatus(PackageName: string,bNewShouldBeLoaded: boolean,bNewShouldBeVisible: boolean,bNewShouldBlockOnLoad: boolean,LODIndex: number): void;
	ClientUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	ClientTravelInternal(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	ClientTravel(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	ClientTeamMessage(SenderPlayerState: PlayerState,S: string,Type: string,MsgLifeTime: number): void;
	ClientStopForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,Tag: string): void;
	ClientStopCameraShake(Shake: UnrealEngineClass,bImmediately: boolean): void;
	ClientStopCameraAnim(AnimToStop: CameraAnim): void;
	ClientStartOnlineSession(): void;
	ClientSpawnCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): void;
	ClientSetViewTarget(A: Actor,TransitionParams: ViewTargetTransitionParams): void;
	ClientSetSpectatorWaiting(bWaiting: boolean): void;
	ClientSetHUD(NewHUDClass: UnrealEngineClass): void;
	ClientSetForceMipLevelsToBeResident(Material: MaterialInterface,ForceDuration: number,CinematicTextureGroups: number): void;
	ClientSetCinematicMode(bInCinematicMode: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean,bAffectsHUD: boolean): void;
	ClientSetCameraMode(NewCamMode: string): void;
	ClientSetCameraFade(bEnableFading: boolean,FadeColor: Color,FadeAlpha: Vector2D,FadeTime: number,bFadeAudio: boolean): void;
	ClientSetBlockOnAsyncLoading(): void;
	ClientReturnToMainMenu(ReturnReason: string): void;
	ClientRetryClientRestart(NewPawn: Pawn): void;
	ClientRestart(NewPawn: Pawn): void;
	ClientReset(): void;
	ClientRepObjRef(UObject: UObject): void;
	ClientReceiveLocalizedMessage(Message: UnrealEngineClass,Switch: number,RelatedPlayerState_1: PlayerState,RelatedPlayerState_2: PlayerState,OptionalObject: UObject): void;
	ClientPrestreamTextures(ForcedActor: Actor,ForceDuration: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	ClientPrepareMapChange(LevelName: string,bFirst: boolean,bLast: boolean): void;
	ClientPlaySoundAtLocation(Sound: SoundBase,Location: Vector,VolumeMultiplier: number,PitchMultiplier: number): void;
	ClientPlaySound(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number): void;
	ClientPlayForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,bLooping: boolean,bIgnoreTimeDilation: boolean,Tag: string): void;
	ClientPlayCameraShake(Shake: UnrealEngineClass,Scale: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): void;
	ClientPlayCameraAnim(AnimToPlay: CameraAnim,Scale: number,Rate: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Space: ECameraAnimPlaySpace,CustomPlaySpace: Rotator): void;
	ClientMutePlayer(PlayerId: UniqueNetIdRepl): void;
	ClientMessage(S: string,Type: string,MsgLifeTime: number): void;
	ClientIgnoreMoveInput(bIgnore: boolean): void;
	ClientIgnoreLookInput(bIgnore: boolean): void;
	ClientGotoState(NewState: string): void;
	ClientGameEnded(EndGameFocus: Actor,bIsWinner: boolean): void;
	ClientForceGarbageCollection(): void;
	ClientFlushLevelStreaming(): void;
	ClientEndOnlineSession(): void;
	ClientEnableNetworkVoice(bEnable: boolean): void;
	ClientCommitMapChange(): void;
	ClientClearCameraLensEffects(): void;
	ClientCapBandwidth(Cap: number): void;
	ClientCancelPendingMapChange(): void;
	ClientAddTextureStreamingLoc(InLoc: Vector,Duration: number,bOverrideLocation: boolean): void;
	ClearAudioListenerOverride(): void;
	Camera(NewMode: string): void;
	AddYawInput(Val: number): void;
	AddRollInput(Val: number): void;
	AddPitchInput(Val: number): void;
	ActivateTouchInterface(NewTouchInterface: TouchInterface): void;
	static C(Other: UObject | any): PlayerController;
	WriteLeaderboardInteger(StatName: string,StatValue: number): boolean;
	IsLoggedIn(): boolean;
	ShowPlatformSpecificAchievementsScreen(): void;
	DeprojectScreenToWorld(ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	GetPlayerControllerID(): number;
	ProjectWorldToScreen(WorldPosition: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	RemovePlayer(bDestroyPawn: boolean): void;
	SetPlayerControllerID(ControllerId: number): void;
	GetMousePositionScaledByDPI(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	GetPlayerScreenWidgetGeometry(): Geometry;
	ProjectWorldLocationToWidgetPosition(WorldLocation: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	SetInputMode_GameAndUI(InWidgetToFocus: Widget,bLockMouseToViewport: boolean,bHideCursorDuringCapture: boolean): void;
	SetInputMode_GameAndUIEx(InWidgetToFocus: Widget,InMouseLockMode: InMouseLockMode,bHideCursorDuringCapture: boolean): void;
	SetInputMode_GameOnly(): void;
	SetInputMode_UIOnly(InWidgetToFocus: Widget,bLockMouseToViewport: boolean): void;
	SetInputMode_UIOnlyEx(InWidgetToFocus: Widget,InMouseLockMode: InMouseLockMode): void;
	static WriteLeaderboardInteger(PlayerController: PlayerController,StatName: string,StatValue: number): boolean;
	static IsLoggedIn(SpecificPlayer: PlayerController): boolean;
	static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): void;
	static DeprojectScreenToWorld(Player: PlayerController,ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	static GetPlayerControllerID(Player: PlayerController): number;
	static ProjectWorldToScreen(Player: PlayerController,WorldPosition: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	static RemovePlayer(Player: PlayerController,bDestroyPawn: boolean): void;
	static SetPlayerControllerID(Player: PlayerController,ControllerId: number): void;
	static GetMousePositionScaledByDPI(Player: PlayerController,LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	static GetPlayerScreenWidgetGeometry(PlayerController: PlayerController): Geometry;
	static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController,WorldLocation: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	static SetInputMode_GameAndUI(Target: PlayerController,InWidgetToFocus: Widget,bLockMouseToViewport: boolean,bHideCursorDuringCapture: boolean): void;
	static SetInputMode_GameAndUIEx(Target: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: InMouseLockMode,bHideCursorDuringCapture: boolean): void;
	static SetInputMode_GameOnly(Target: PlayerController): void;
	static SetInputMode_UIOnly(Target: PlayerController,InWidgetToFocus: Widget,bLockMouseToViewport: boolean): void;
	static SetInputMode_UIOnlyEx(Target: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: InMouseLockMode): void;
}

declare type ENavPathEvent = 'Cleared' | 'NewPath' | 'UpdatedDueToGoalMoved' | 'UpdatedDueToNavigationChanged' | 'Invalidated' | 'RePathFailed' | 'MetaPathUpdate' | 'Custom';
declare var ENavPathEvent : { Cleared:'Cleared',NewPath:'NewPath',UpdatedDueToGoalMoved:'UpdatedDueToGoalMoved',UpdatedDueToNavigationChanged:'UpdatedDueToNavigationChanged',Invalidated:'Invalidated',RePathFailed:'RePathFailed',MetaPathUpdate:'MetaPathUpdate',Custom:'Custom', };
declare type ENavigationOptionFlag = 'Default' | 'Enable' | 'Disable';
declare var ENavigationOptionFlag : { Default:'Default',Enable:'Enable',Disable:'Disable', };
declare class NavigationPath extends UObject { 
	PathUpdatedNotifier: UnrealEngineMulticastDelegate<(AffectedPath: NavigationPath, PathEvent: ENavPathEvent) => void>;
	PathPoints: Vector[];
	RecalculateOnInvalidation: ENavigationOptionFlag;
	static Load(ResourceName: string): NavigationPath;
	static Find(Outer: UObject, ResourceName: string): NavigationPath;
	static GetDefaultObject(): NavigationPath;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationPath;
	IsValid(): boolean;
	IsStringPulled(): boolean;
	IsPartial(): boolean;
	GetPathLength(): number;
	GetPathCost(): number;
	GetDebugString(): string;
	EnableRecalculationOnInvalidation(DoRecalculation: ENavigationOptionFlag): void;
	EnableDebugDrawing(bShouldDrawDebugData: boolean,PathColor: LinearColor): void;
	static C(Other: UObject | any): NavigationPath;
}

declare class Controller extends Actor { 
	Pawn: Pawn;
	Character: Character;
	PlayerState: PlayerState;
	TransformComponent: SceneComponent;
	ControlRotation: Rotator;
	bAttachToPawn: boolean;
	bIsPlayerController: boolean;
	StateName: string;
	OnInstigatedAnyDamage: UnrealEngineMulticastDelegate<(Damage: number, DamageType: DamageType, DamagedActor: Actor, DamageCauser: Actor) => void>;
	static GetDefaultObject(): Controller;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Controller;
	UnPossess(): void;
	StopMovement(): void;
	SetInitialLocationAndRotation(NewLocation: Vector,NewRotation: Rotator): void;
	SetIgnoreMoveInput(bNewMoveInput: boolean): void;
	SetIgnoreLookInput(bNewLookInput: boolean): void;
	SetControlRotation(NewRotation: Rotator): void;
	ResetIgnoreMoveInput(): void;
	ResetIgnoreLookInput(): void;
	ResetIgnoreInputFlags(): void;
	ReceiveInstigatedAnyDamage(Damage: number,DamageType: DamageType,DamagedActor: Actor,DamageCauser: Actor): void;
	Possess(InPawn: Pawn): void;
	OnRep_PlayerState(): void;
	OnRep_Pawn(): void;
	LineOfSightTo(Other: Actor,ViewPoint: Vector,bAlternateChecks: boolean): boolean;
	K2_GetPawn(): Pawn;
	IsPlayerController(): boolean;
	IsMoveInputIgnored(): boolean;
	IsLookInputIgnored(): boolean;
	IsLocalPlayerController(): boolean;
	IsLocalController(): boolean;
	GetViewTarget(): Actor;
	GetDesiredRotation(): Rotator;
	GetControlRotation(): Rotator;
	ClientSetRotation(NewRotation: Rotator,bResetCamera: boolean): void;
	ClientSetLocation(NewLocation: Vector,NewRotation: Rotator): void;
	CastToPlayerController(): PlayerController;
	static C(Other: UObject | any): Controller;
	SimpleMoveToActor(Goal: Actor): void;
	SimpleMoveToLocation(Goal: Vector): void;
	GetCurrentPath(): NavigationPath;
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
	static GetCurrentPath(Controller: Controller): NavigationPath;
}

declare class Pawn extends Actor { 
	bUseControllerRotationPitch: boolean;
	bUseControllerRotationYaw: boolean;
	bUseControllerRotationRoll: boolean;
	bCanAffectNavigationGeneration: boolean;
	BaseEyeHeight: number;
	AutoPossessPlayer: EAutoReceiveInput;
	AutoPossessAI: AutoPossessAI;
	AIControllerClass: UnrealEngineClass;
	PlayerState: PlayerState;
	RemoteViewPitch: number;
	LastHitBy: Controller;
	Controller: Controller;
	ControlInputVector: Vector;
	LastControlInputVector: Vector;
	static GetDefaultObject(): Pawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Pawn;
	SpawnDefaultController(): void;
	SetCanAffectNavigationGeneration(bNewValue: boolean,bForceUpdate: boolean): void;
	ReceiveUnpossessed(OldController: Controller): void;
	ReceivePossessed(NewController: Controller): void;
	PawnMakeNoise(Loudness: number,NoiseLocation: Vector,bUseNoiseMakerLocation: boolean,NoiseMaker: Actor): void;
	OnRep_PlayerState(): void;
	OnRep_Controller(): void;
	LaunchPawn(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	K2_GetMovementInputVector(): Vector;
	IsPlayerControlled(): boolean;
	IsMoveInputIgnored(): boolean;
	IsLocallyControlled(): boolean;
	IsControlled(): boolean;
	GetPendingMovementInputVector(): Vector;
	GetNavAgentLocation(): Vector;
	GetMovementComponent(): PawnMovementComponent;
	static GetMovementBaseActor(Pawn: Pawn): Actor;
	GetLastMovementInputVector(): Vector;
	GetControlRotation(): Rotator;
	GetController(): Controller;
	GetBaseAimRotation(): Rotator;
	DetachFromControllerPendingDestroy(): void;
	ConsumeMovementInputVector(): Vector;
	AddMovementInput(WorldDirection: Vector,ScaleValue: number,bForce: boolean): void;
	AddControllerYawInput(Val: number): void;
	AddControllerRollInput(Val: number): void;
	AddControllerPitchInput(Val: number): void;
	static C(Other: UObject | any): Pawn;
	SendAIMessage(Message: string,MessageSource: UObject,bSuccess: boolean): void;
	static SendAIMessage(Target: Pawn,Message: string,MessageSource: UObject,bSuccess: boolean): void;
}

declare type ERadialImpulseFalloff = 'RIF_Constant' | 'RIF_Linear';
declare var ERadialImpulseFalloff : { RIF_Constant:'RIF_Constant',RIF_Linear:'RIF_Linear', };
declare class PrimitiveComponent extends SceneComponent { 
	MinDrawDistance: number;
	LDMaxDrawDistance: number;
	CachedMaxDrawDistance: number;
	bEnableAutoLODGeneration: boolean;
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	bAlwaysCreatePhysicsState: boolean;
	bGenerateOverlapEvents: boolean;
	bMultiBodyOverlap: boolean;
	bCheckAsyncSceneOnMove: boolean;
	bTraceComplexOnMove: boolean;
	bReturnMaterialOnMove: boolean;
	bUseViewOwnerDepthPriorityGroup: boolean;
	bAllowCullDistanceVolume: boolean;
	bHasMotionBlurVelocityMeshes: boolean;
	bVisibleInReflectionCaptures: boolean;
	bRenderInMainPass: boolean;
	bRenderInMono: boolean;
	bReceivesDecals: boolean;
	bOwnerNoSee: boolean;
	bOnlyOwnerSee: boolean;
	bTreatAsBackgroundForOcclusion: boolean;
	bUseAsOccluder: boolean;
	bSelectable: boolean;
	bForceMipStreaming: boolean;
	bHasPerInstanceHitProxies: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastVolumetricTranslucentShadow: boolean;
	bSelfShadowOnly: boolean;
	bCastFarShadow: boolean;
	bCastInsetShadow: boolean;
	bCastCinematicShadow: boolean;
	bCastHiddenShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bLightAsIfStatic: boolean;
	bLightAttachmentsAsGroup: boolean;
	bReceiveCombinedCSMAndStaticShadowsFromStationaryLights: boolean;
	bSingleSampleShadowFromStationaryLights: boolean;
	bIgnoreRadialImpulse: boolean;
	bIgnoreRadialForce: boolean;
	bApplyImpulseOnDamage: boolean;
	AlwaysLoadOnClient: boolean;
	AlwaysLoadOnServer: boolean;
	bUseEditorCompositing: boolean;
	bRenderCustomDepth: boolean;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	CanBeCharacterBase: ECanBeCharacterBase;
	CanCharacterStepUpOn: ECanBeCharacterBase;
	LightingChannels: LightingChannels;
	CustomDepthStencilWriteMask: CustomDepthStencilWriteMask;
	CustomDepthStencilValue: number;
	TranslucencySortPriority: number;
	VisibilityId: number;
	LpvBiasMultiplier: number;
	BoundsScale: number;
	LastSubmitTime: number;
	LastRenderTime: number;
	LastRenderTimeOnScreen: number;
	MoveIgnoreActors: Actor[];
	MoveIgnoreComponents: PrimitiveComponent[];
	BodyInstance: BodyInstance;
	OnComponentHit: UnrealEngineMulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	OnComponentWake: UnrealEngineMulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentSleep: UnrealEngineMulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	LODParentPrimitive: PrimitiveComponent;
	PostPhysicsComponentTick: PrimitiveComponentPostPhysicsTickFunction;
	static Load(ResourceName: string): PrimitiveComponent;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponent;
	static GetDefaultObject(): PrimitiveComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	WakeRigidBody(BoneName: string): void;
	WakeAllRigidBodies(): void;
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;
	SetSimulatePhysics(bSimulate: boolean): void;
	SetRenderInMono(bValue: boolean): void;
	SetRenderInMainPass(bValue: boolean): void;
	SetRenderCustomDepth(bValue: boolean): void;
	SetReceivesDecals(bNewReceivesDecals: boolean): void;
	SetPhysMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsMaxAngularVelocity(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocity(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	SetMaterialByName(MaterialSlotName: string,Material: MaterialInterface): void;
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	SetMassScale(BoneName: string,InMassScale: number): void;
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	SetLockedAxis(LockedAxis: EDOFMode): void;
	SetLinearDamping(InDamping: number): void;
	SetEnableGravity(bGravityEnabled: boolean): void;
	SetCustomDepthStencilWriteMask(WriteMaskBit: WriteMaskBit): void;
	SetCustomDepthStencilValue(Value: number): void;
	SetCullDistance(NewCullDistance: number): void;
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	SetCollisionProfileName(InCollisionProfileName: string): void;
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	SetCastShadow(NewCastShadow: boolean): void;
	SetBoundsScale(NewBoundsScale: number): void;
	SetAngularDamping(InDamping: number): void;
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocity(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllMassScale(InMassScale: number): void;
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	PutRigidBodyToSleep(BoneName: string): void;
	K2_LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_IsQueryCollisionEnabled(): boolean;
	K2_IsPhysicsCollisionEnabled(): boolean;
	K2_IsCollisionEnabled(): boolean;
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsGravityEnabled(): boolean;
	IsAnyRigidBodyAwake(): boolean;
	IgnoreComponentWhenMoving(Component: PrimitiveComponent,bShouldIgnore: boolean): void;
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	GetPhysicsAngularVelocityInRadians(BoneName: string): Vector;
	GetPhysicsAngularVelocityInDegrees(BoneName: string): Vector;
	GetPhysicsAngularVelocity(BoneName: string): Vector;
	GetOverlappingComponents(InOverlappingComponents?: PrimitiveComponent[]): {InOverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetNumMaterials(): number;
	GetMaterialFromCollisionFaceIndex(FaceIndex: number,SectionIndex?: number): {SectionIndex: number, $: MaterialInterface};
	GetMaterial(ElementIndex: number): MaterialInterface;
	GetMassScale(BoneName: string): number;
	GetMass(): number;
	GetLinearDamping(): number;
	GetInertiaTensor(BoneName: string): Vector;
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	GetCollisionProfileName(): string;
	GetCollisionObjectType(): ECollisionChannel;
	GetCollisionEnabled(): ECollisionEnabled;
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	GetCenterOfMass(BoneName: string): Vector;
	GetAngularDamping(): number;
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;
	CopyArrayOfMoveIgnoreComponents(): PrimitiveComponent[];
	CopyArrayOfMoveIgnoreActors(): Actor[];
	ClearMoveIgnoreComponents(): void;
	ClearMoveIgnoreActors(): void;
	CanCharacterStepUp(Pawn: Pawn): boolean;
	AddTorqueInRadians(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddTorqueInDegrees(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddTorque(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddForceAtLocationLocal(Force: Vector,Location: Vector,BoneName: string): void;
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	AddAngularImpulseInRadians(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddAngularImpulseInDegrees(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddAngularImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	static C(Other: UObject | any): PrimitiveComponent;
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
}

declare class BrushComponent extends PrimitiveComponent { 
	Brush: Model;
	BrushBodySetup: BodySetup;
	PrePivot: Vector;
	static Load(ResourceName: string): BrushComponent;
	static Find(Outer: UObject, ResourceName: string): BrushComponent;
	static GetDefaultObject(): BrushComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushComponent;
	static C(Other: UObject | any): BrushComponent;
}

declare class BuilderPoly { 
	VertexIndices: number[];
	Direction: number;
	ItemName: string;
	PolyFlags: number;
	clone() : BuilderPoly;
	static C(Other: UObject | any): BuilderPoly;
}

declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	ToolTip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static GetDefaultObject(): BrushBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject | any): BrushBuilder;
	Build(InWorld: World,InBrush: Brush): boolean;
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	Type: number;
	Index: number;
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject | any): GeomSelection;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	static GetDefaultObject(): Brush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject | any): Brush;
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
}

declare class Volume extends Brush { 
	static GetDefaultObject(): Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject | any): Volume;
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	static GetDefaultObject(): PhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject | any): PhysicsVolume;
}

declare type EDetachmentRule = 'KeepRelative' | 'KeepWorld';
declare var EDetachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld', };
declare type ERelativeTransformSpace = 'RTS_World' | 'RTS_Actor' | 'RTS_Component' | 'RTS_ParentBoneSpace';
declare var ERelativeTransformSpace : { RTS_World:'RTS_World',RTS_Actor:'RTS_Actor',RTS_Component:'RTS_Component',RTS_ParentBoneSpace:'RTS_ParentBoneSpace', };
declare type EMoveComponentAction = 'Move' | 'Stop' | 'Return';
declare var EMoveComponentAction : { Move:'Move',Stop:'Stop',Return:'Return', };
declare class SceneComponent extends ActorComponent { 
	PhysicsVolume: any;
	AttachParent: SceneComponent;
	AttachSocketName: string;
	AttachChildren: SceneComponent[];
	ClientAttachedChildren: SceneComponent[];
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	ComponentVelocity: Vector;
	bComponentToWorldUpdated: boolean;
	bAbsoluteLocation: boolean;
	bAbsoluteRotation: boolean;
	bAbsoluteScale: boolean;
	bVisible: boolean;
	bHiddenInGame: boolean;
	bShouldUpdatePhysicsVolume: boolean;
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	bUseAttachParentBound: boolean;
	bAbsoluteTranslation: boolean;
	bVisualizeComponent: boolean;
	Mobility: EComponentMobility;
	DetailMode: EDetailMode;
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	RelativeTranslation: Vector;
	static Load(ResourceName: string): SceneComponent;
	static Find(Outer: UObject, ResourceName: string): SceneComponent;
	static GetDefaultObject(): SceneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	ToggleVisibility(bPropagateToChildren: boolean): void;
	SnapTo(InParent: SceneComponent,InSocketName: string): boolean;
	SetWorldScale3D(NewScale: Vector): void;
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	SetRelativeScale3D(NewScale3D: Vector): void;
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	ResetRelativeTransform(): void;
	OnRep_Visibility(OldValue: boolean): void;
	OnRep_Transform(): void;
	OnRep_AttachSocketName(): void;
	OnRep_AttachParent(): void;
	OnRep_AttachChildren(): void;
	K2_SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_GetComponentToWorld(): Transform;
	K2_GetComponentScale(): Vector;
	K2_GetComponentRotation(): Rotator;
	K2_GetComponentLocation(): Vector;
	K2_DetachFromComponent(LocationRule: LocationRule,RotationRule: RotationRule,ScaleRule: ScaleRule,bCallModify: boolean): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: LocationRule,RotationRule: RotationRule,ScaleRule: ScaleRule,bWeldSimulatedBodies: boolean): boolean;
	K2_AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): boolean;
	K2_AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsVisible(): boolean;
	IsSimulatingPhysics(BoneName: string): boolean;
	IsAnySimulatingPhysics(): boolean;
	GetUpVector(): Vector;
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	GetSocketRotation(InSocketName: string): Rotator;
	GetSocketQuaternion(InSocketName: string): Quat;
	GetSocketLocation(InSocketName: string): Vector;
	GetRightVector(): Vector;
	GetRelativeTransform(): Transform;
	GetPhysicsVolume(): PhysicsVolume;
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	GetNumChildrenComponents(): number;
	GetForwardVector(): Vector;
	GetComponentVelocity(): Vector;
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	GetChildComponent(ChildIndex: number): SceneComponent;
	GetAttachSocketName(): string;
	GetAttachParent(): SceneComponent;
	GetAllSocketNames(): string[];
	DoesSocketExist(InSocketName: string): boolean;
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
	static C(Other: UObject | any): SceneComponent;
	SetMobile(): void;
	SetMobility(Type: EComponentMobility): void;
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static SetMobile(SceneComponent: SceneComponent): void;
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
}

declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject | any): RepAttachment;
}

declare type ENetDormancy = 'DORM_Never' | 'DORM_Awake' | 'DORM_DormantAll' | 'DORM_DormantPartial' | 'DORM_Initial' | 'DORN_MAX';
declare var ENetDormancy : { DORM_Never:'DORM_Never',DORM_Awake:'DORM_Awake',DORM_DormantAll:'DORM_DormantAll',DORM_DormantPartial:'DORM_DormantPartial',DORM_Initial:'DORM_Initial',DORN_MAX:'DORN_MAX', };
declare type EInputConsumeOptions = 'ICO_ConsumeAll' | 'ICO_ConsumeBoundKeys' | 'ICO_ConsumeNone';
declare var EInputConsumeOptions : { ICO_ConsumeAll:'ICO_ConsumeAll',ICO_ConsumeBoundKeys:'ICO_ConsumeBoundKeys',ICO_ConsumeNone:'ICO_ConsumeNone', };
declare type ESpawnActorCollisionHandlingMethod = 'Undefined' | 'AlwaysSpawn' | 'AdjustIfPossibleButAlwaysSpawn' | 'AdjustIfPossibleButDontSpawnIfColliding' | 'DontSpawnIfColliding';
declare var ESpawnActorCollisionHandlingMethod : { Undefined:'Undefined',AlwaysSpawn:'AlwaysSpawn',AdjustIfPossibleButAlwaysSpawn:'AdjustIfPossibleButAlwaysSpawn',AdjustIfPossibleButDontSpawnIfColliding:'AdjustIfPossibleButDontSpawnIfColliding',DontSpawnIfColliding:'DontSpawnIfColliding', };
declare class InterpFilter extends UObject { 
	Caption: string;
	static Load(ResourceName: string): InterpFilter;
	static Find(Outer: UObject, ResourceName: string): InterpFilter;
	static GetDefaultObject(): InterpFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter;
	static C(Other: UObject | any): InterpFilter;
}

declare class InterpGroupDirector extends InterpGroup { 
	static Load(ResourceName: string): InterpGroupDirector;
	static Find(Outer: UObject, ResourceName: string): InterpGroupDirector;
	static GetDefaultObject(): InterpGroupDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupDirector;
	static C(Other: UObject | any): InterpGroupDirector;
}

declare class InterpData extends UObject { 
	InterpLength: number;
	PathBuildTime: number;
	InterpGroups: InterpGroup[];
	CurveEdSetup: InterpCurveEdSetup;
	InterpFilters: InterpFilter[];
	SelectedFilter: InterpFilter;
	DefaultFilters: InterpFilter[];
	EdSectionStart: number;
	EdSectionEnd: number;
	bShouldBakeAndPrune: boolean;
	CachedDirectorGroup: InterpGroupDirector;
	AllEventNames: string[];
	static Load(ResourceName: string): InterpData;
	static Find(Outer: UObject, ResourceName: string): InterpData;
	static GetDefaultObject(): InterpData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpData;
	static C(Other: UObject | any): InterpData;
}

declare class InterpGroupActorInfo { 
	ObjectName: string;
	Actors: Actor[];
	clone() : InterpGroupActorInfo;
	static C(Other: UObject | any): InterpGroupActorInfo;
}

declare class CameraCutInfo { 
	Location: Vector;
	TimeStamp: number;
	clone() : CameraCutInfo;
	static C(Other: UObject | any): CameraCutInfo;
}

declare class MatineeActor extends Actor { 
	MatineeData: InterpData;
	MatineeControllerName: string;
	PlayRate: number;
	bPlayOnLevelLoad: boolean;
	bForceStartPos: boolean;
	ForceStartPosition: number;
	bLooping: boolean;
	bRewindOnPlay: boolean;
	bNoResetOnRewind: boolean;
	bRewindIfAlreadyPlaying: boolean;
	bDisableRadioFilter: boolean;
	bClientSideOnly: boolean;
	bSkipUpdateIfNotVisible: boolean;
	bIsSkippable: boolean;
	PreferredSplitScreenNum: number;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	GroupActorInfos: InterpGroupActorInfo[];
	bShouldShowGore: boolean;
	GroupInst: InterpGroupInst[];
	CameraCuts: CameraCutInfo[];
	SpriteComponent: BillboardComponent;
	bIsBeingEdited: boolean;
	bIsScrubbing: boolean;
	bIsPlaying: boolean;
	bReversePlayback: boolean;
	bPaused: boolean;
	bPendingStop: boolean;
	InterpPosition: number;
	ReplicationForceIsPlaying: number;
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	static GetDefaultObject(): MatineeActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActor;
	Stop(): void;
	SetPosition(NewPosition: number,bJump: boolean): void;
	SetLoopingState(bNewLooping: boolean): void;
	Reverse(): void;
	Play(): void;
	Pause(): void;
	EnableGroupByName(GroupName: string,bEnable: boolean): void;
	ChangePlaybackDirection(): void;
	static C(Other: UObject | any): MatineeActor;
}

declare class ChildActorComponent extends SceneComponent { 
	ChildActorClass: UnrealEngineClass;
	ChildActor: Actor;
	ChildActorTemplate: Actor;
	static Load(ResourceName: string): ChildActorComponent;
	static Find(Outer: UObject, ResourceName: string): ChildActorComponent;
	static GetDefaultObject(): ChildActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildActorComponent;
	SetChildActorClass(InClass: UnrealEngineClass): void;
	static C(Other: UObject | any): ChildActorComponent;
}

declare class ModelComponent extends PrimitiveComponent { 
	ModelBodySetup: BodySetup;
	static Load(ResourceName: string): ModelComponent;
	static Find(Outer: UObject, ResourceName: string): ModelComponent;
	static GetDefaultObject(): ModelComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModelComponent;
	static C(Other: UObject | any): ModelComponent;
}

declare class LevelActorContainer extends UObject { 
	Actors: Actor[];
	static Load(ResourceName: string): LevelActorContainer;
	static Find(Outer: UObject, ResourceName: string): LevelActorContainer;
	static GetDefaultObject(): LevelActorContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelActorContainer;
	static C(Other: UObject | any): LevelActorContainer;
}

declare class LevelScriptBlueprint extends Blueprint { 
	FriendlyName: string;
	static Load(ResourceName: string): LevelScriptBlueprint;
	static Find(Outer: UObject, ResourceName: string): LevelScriptBlueprint;
	static GetDefaultObject(): LevelScriptBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptBlueprint;
	static C(Other: UObject | any): LevelScriptBlueprint;
}

declare class LevelScriptActor extends Actor { 
	bInputEnabled: boolean;
	static GetDefaultObject(): LevelScriptActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptActor;
	WorldOriginLocationChanged(OldOriginLocation: IntVector,NewOriginLocation: IntVector): void;
	SetCinematicMode(bCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	RemoteEvent(EventName: string): boolean;
	LevelReset(): void;
	static C(Other: UObject | any): LevelScriptActor;
}

declare class NavigationObjectBase extends Actor { 
	CapsuleComponent: CapsuleComponent;
	GoodSprite: BillboardComponent;
	BadSprite: BillboardComponent;
	bIsPIEPlayerStart: boolean;
	static GetDefaultObject(): NavigationObjectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationObjectBase;
	static C(Other: UObject | any): NavigationObjectBase;
}

declare class NavigationDataChunk extends UObject { 
	NavigationDataName: string;
	static Load(ResourceName: string): NavigationDataChunk;
	static Find(Outer: UObject, ResourceName: string): NavigationDataChunk;
	static GetDefaultObject(): NavigationDataChunk;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataChunk;
	static C(Other: UObject | any): NavigationDataChunk;
}

declare type ELightingBuildQuality = 'Quality_Preview' | 'Quality_Medium' | 'Quality_High' | 'Quality_Production';
declare var ELightingBuildQuality : { Quality_Preview:'Quality_Preview',Quality_Medium:'Quality_Medium',Quality_High:'Quality_High',Quality_Production:'Quality_Production', };
declare class MapBuildDataRegistry extends UObject { 
	LevelLightingQuality: ELightingBuildQuality;
	static Load(ResourceName: string): MapBuildDataRegistry;
	static Find(Outer: UObject, ResourceName: string): MapBuildDataRegistry;
	static GetDefaultObject(): MapBuildDataRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapBuildDataRegistry;
	static C(Other: UObject | any): MapBuildDataRegistry;
}

declare type ETextureSizingType = 'TextureSizingType_UseSingleTextureSize' | 'TextureSizingType_UseAutomaticBiasedSizes' | 'TextureSizingType_UseManualOverrideTextureSize' | 'TextureSizingType_UseSimplygonAutomaticSizing';
declare var ETextureSizingType : { TextureSizingType_UseSingleTextureSize:'TextureSizingType_UseSingleTextureSize',TextureSizingType_UseAutomaticBiasedSizes:'TextureSizingType_UseAutomaticBiasedSizes',TextureSizingType_UseManualOverrideTextureSize:'TextureSizingType_UseManualOverrideTextureSize',TextureSizingType_UseSimplygonAutomaticSizing:'TextureSizingType_UseSimplygonAutomaticSizing', };
declare type EMaterialMergeType = 'MaterialMergeType_Default' | 'MaterialMergeType_Simplygon';
declare var EMaterialMergeType : { MaterialMergeType_Default:'MaterialMergeType_Default',MaterialMergeType_Simplygon:'MaterialMergeType_Simplygon', };
declare class MaterialProxySettings { 
	TextureSize: IntPoint;
	TextureSizingType: ETextureSizingType;
	GutterSpace: number;
	bNormalMap: boolean;
	bMetallicMap: boolean;
	MetallicConstant: number;
	bRoughnessMap: boolean;
	RoughnessConstant: number;
	bSpecularMap: boolean;
	SpecularConstant: number;
	bEmissiveMap: boolean;
	bOpacityMap: boolean;
	OpacityConstant: number;
	bOpacityMaskMap: boolean;
	OpacityMaskConstant: number;
	bAmbientOcclusionMap: boolean;
	AmbientOcclusionConstant: number;
	DiffuseTextureSize: IntPoint;
	NormalTextureSize: IntPoint;
	MetallicTextureSize: IntPoint;
	RoughnessTextureSize: IntPoint;
	SpecularTextureSize: IntPoint;
	EmissiveTextureSize: IntPoint;
	OpacityTextureSize: IntPoint;
	OpacityMaskTextureSize: IntPoint;
	AmbientOcclusionTextureSize: IntPoint;
	MaterialMergeType: EMaterialMergeType;
	BlendMode: EBlendMode;
	clone() : MaterialProxySettings;
	static C(Other: UObject | any): MaterialProxySettings;
}

declare class LevelSimplificationDetails { 
	bCreatePackagePerAsset: boolean;
	DetailsPercentage: number;
	StaticMeshMaterialSettings: MaterialProxySettings;
	bOverrideLandscapeExportLOD: boolean;
	LandscapeExportLOD: number;
	LandscapeMaterialSettings: MaterialProxySettings;
	bBakeFoliageToLandscape: boolean;
	bBakeGrassToLandscape: boolean;
	bGenerateMeshNormalMap: boolean;
	bGenerateMeshMetallicMap: boolean;
	bGenerateMeshRoughnessMap: boolean;
	bGenerateMeshSpecularMap: boolean;
	bGenerateLandscapeNormalMap: boolean;
	bGenerateLandscapeMetallicMap: boolean;
	bGenerateLandscapeRoughnessMap: boolean;
	bGenerateLandscapeSpecularMap: boolean;
	clone() : LevelSimplificationDetails;
	static C(Other: UObject | any): LevelSimplificationDetails;
}

declare class DefaultPhysicsVolume extends PhysicsVolume { 
	static GetDefaultObject(): DefaultPhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPhysicsVolume;
	static C(Other: UObject | any): DefaultPhysicsVolume;
}

declare class PhysicsCollisionHandler extends UObject { 
	ImpactThreshold: number;
	ImpactReFireDelay: number;
	DefaultImpactSound: SoundBase;
	LastImpactSoundTime: number;
	static Load(ResourceName: string): PhysicsCollisionHandler;
	static Find(Outer: UObject, ResourceName: string): PhysicsCollisionHandler;
	static GetDefaultObject(): PhysicsCollisionHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsCollisionHandler;
	static C(Other: UObject | any): PhysicsCollisionHandler;
}

declare class GameSession extends Info { 
	MaxSpectators: number;
	MaxPlayers: number;
	MaxPartySize: number;
	MaxSplitscreensPerConnection: number;
	bRequiresPushToTalk: boolean;
	SessionName: string;
	static GetDefaultObject(): GameSession;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSession;
	static C(Other: UObject | any): GameSession;
}

declare class GameStateBase extends Info { 
	GameModeClass: UnrealEngineClass;
	AuthorityGameMode: GameModeBase;
	SpectatorClass: UnrealEngineClass;
	PlayerArray: PlayerState[];
	bReplicatedHasBegunPlay: boolean;
	ReplicatedWorldTimeSeconds: number;
	ServerWorldTimeSecondsDelta: number;
	ServerWorldTimeSecondsUpdateFrequency: number;
	static GetDefaultObject(): GameStateBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameStateBase;
	OnRep_SpectatorClass(): void;
	OnRep_ReplicatedWorldTimeSeconds(): void;
	OnRep_ReplicatedHasBegunPlay(): void;
	OnRep_GameModeClass(): void;
	HasMatchStarted(): boolean;
	HasBegunPlay(): boolean;
	GetServerWorldTimeSeconds(): number;
	GetPlayerStartTime(Controller: Controller): number;
	GetPlayerRespawnDelay(Controller: Controller): number;
	static C(Other: UObject | any): GameStateBase;
}

declare class GameModeBase extends Info { 
	OptionsString: string;
	GameSessionClass: UnrealEngineClass;
	GameStateClass: UnrealEngineClass;
	PlayerControllerClass: UnrealEngineClass;
	PlayerStateClass: UnrealEngineClass;
	HUDClass: UnrealEngineClass;
	DefaultPawnClass: UnrealEngineClass;
	SpectatorClass: UnrealEngineClass;
	ReplaySpectatorPlayerControllerClass: UnrealEngineClass;
	GameSession: GameSession;
	GameState: GameStateBase;
	DefaultPlayerName: string;
	bUseSeamlessTravel: boolean;
	bStartPlayersAsSpectators: boolean;
	bPauseable: boolean;
	static GetDefaultObject(): GameModeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameModeBase;
	StartPlay(): void;
	SpawnDefaultPawnFor(NewPlayer: Controller,StartSpot: Actor): Pawn;
	SpawnDefaultPawnAtTransform(NewPlayer: Controller,SpawnTransform: Transform): Pawn;
	ShouldReset(ActorToReset: Actor): boolean;
	ReturnToMainMenuHost(): void;
	RestartPlayerAtTransform(NewPlayer: Controller,SpawnTransform: Transform): void;
	RestartPlayerAtPlayerStart(NewPlayer: Controller,StartSpot: Actor): void;
	RestartPlayer(NewPlayer: Controller): void;
	ResetLevel(): void;
	PlayerCanRestart(Player: PlayerController): boolean;
	MustSpectate(NewPlayerController: PlayerController): boolean;
	K2_PostLogin(NewPlayer: PlayerController): void;
	K2_OnSwapPlayerControllers(OldPC: PlayerController,NewPC: PlayerController): void;
	K2_OnRestartPlayer(NewPlayer: Controller): void;
	K2_OnLogout(ExitingController: Controller): void;
	K2_OnChangeName(Other: Controller,NewName: string,bNameChange: boolean): void;
	K2_FindPlayerStart(Player: Controller,IncomingName: string): Actor;
	InitStartSpot(StartSpot: Actor,NewPlayer: Controller): void;
	InitializeHUDForPlayer(NewPlayer: PlayerController): void;
	HasMatchStarted(): boolean;
	HandleStartingNewPlayer(NewPlayer: PlayerController): void;
	GetNumSpectators(): number;
	GetNumPlayers(): number;
	GetDefaultPawnClassForController(InController: Controller): UnrealEngineClass;
	FindPlayerStart(Player: Controller,IncomingName: string): Actor;
	ChoosePlayerStart(Player: Controller): Actor;
	ChangeName(Controller: Controller,NewName: string,bNameChange: boolean): void;
	CanSpectate(Viewer: PlayerController,ViewTarget: PlayerState): boolean;
	static C(Other: UObject | any): GameModeBase;
	HandleSeamlessTravelPlayer(C?: Controller): {C: Controller};
	static HandleSeamlessTravelPlayer(GameMode: GameModeBase,C?: Controller): {C: Controller};
}

declare class GameNetworkManager extends Info { 
	AdjustedNetSpeed: number;
	LastNetSpeedUpdateTime: number;
	TotalNetBandwidth: number;
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	bIsStandbyCheckingEnabled: boolean;
	bHasStandbyCheatTriggered: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	BadPingThreshold: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	MoveRepSize: number;
	MAXPOSITIONERRORSQUARED: number;
	MAXNEARZEROVELOCITYSQUARED: number;
	CLIENTADJUSTUPDATECOST: number;
	MAXCLIENTUPDATEINTERVAL: number;
	MaxMoveDeltaTime: number;
	ClientNetSendMoveDeltaTime: number;
	ClientNetSendMoveDeltaTimeThrottled: number;
	ClientNetSendMoveThrottleAtNetSpeed: number;
	ClientNetSendMoveThrottleOverPlayerCount: number;
	ClientAuthorativePosition: boolean;
	ClientErrorUpdateRateLimit: number;
	bMovementTimeDiscrepancyDetection: boolean;
	bMovementTimeDiscrepancyResolution: boolean;
	MovementTimeDiscrepancyMaxTimeMargin: number;
	MovementTimeDiscrepancyMinTimeMargin: number;
	MovementTimeDiscrepancyResolutionRate: number;
	MovementTimeDiscrepancyDriftAllowance: number;
	bMovementTimeDiscrepancyForceCorrectionsDuringResolution: boolean;
	bUseDistanceBasedRelevancy: boolean;
	static GetDefaultObject(): GameNetworkManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManager;
	static C(Other: UObject | any): GameNetworkManager;
}

declare type EVisibilityAggressiveness = 'VIS_LeastAggressive' | 'VIS_ModeratelyAggressive' | 'VIS_MostAggressive' | 'VIS_Max';
declare var EVisibilityAggressiveness : { VIS_LeastAggressive:'VIS_LeastAggressive',VIS_ModeratelyAggressive:'VIS_ModeratelyAggressive',VIS_MostAggressive:'VIS_MostAggressive',VIS_Max:'VIS_Max', };
declare type EVolumeLightingMethod = 'VLM_VolumetricLightmap' | 'VLM_SparseVolumeLightingSamples';
declare var EVolumeLightingMethod : { VLM_VolumetricLightmap:'VLM_VolumetricLightmap',VLM_SparseVolumeLightingSamples:'VLM_SparseVolumeLightingSamples', };
declare class LightmassWorldInfoSettings { 
	StaticLightingLevelScale: number;
	NumIndirectLightingBounces: number;
	NumSkyLightingBounces: number;
	IndirectLightingQuality: number;
	IndirectLightingSmoothness: number;
	EnvironmentColor: Color;
	EnvironmentIntensity: number;
	EmissiveBoost: number;
	DiffuseBoost: number;
	VolumeLightingMethod: EVolumeLightingMethod;
	VolumetricLightmapDetailCellSize: number;
	VolumetricLightmapMaximumBrickMemoryMb: number;
	VolumeLightSamplePlacementScale: number;
	bUseAmbientOcclusion: boolean;
	bGenerateAmbientOcclusionMaterialMask: boolean;
	DirectIlluminationOcclusionFraction: number;
	IndirectIlluminationOcclusionFraction: number;
	OcclusionExponent: number;
	FullyOccludedSamplesFraction: number;
	MaxOcclusionDistance: number;
	bVisualizeMaterialDiffuse: boolean;
	bVisualizeAmbientOcclusion: boolean;
	bCompressLightmaps: boolean;
	clone() : LightmassWorldInfoSettings;
	static C(Other: UObject | any): LightmassWorldInfoSettings;
}

declare type ReverbPreset = 'REVERB_Default' | 'REVERB_Bathroom' | 'REVERB_StoneRoom' | 'REVERB_Auditorium' | 'REVERB_ConcertHall' | 'REVERB_Cave' | 'REVERB_Hallway' | 'REVERB_StoneCorridor' | 'REVERB_Alley' | 'REVERB_Forest' | 'REVERB_City' | 'REVERB_Mountains' | 'REVERB_Quarry' | 'REVERB_Plain' | 'REVERB_ParkingLot' | 'REVERB_SewerPipe' | 'REVERB_Underwater' | 'REVERB_SmallRoom' | 'REVERB_MediumRoom' | 'REVERB_LargeRoom' | 'REVERB_MediumHall' | 'REVERB_LargeHall' | 'REVERB_Plate';
declare var ReverbPreset : { REVERB_Default:'REVERB_Default',REVERB_Bathroom:'REVERB_Bathroom',REVERB_StoneRoom:'REVERB_StoneRoom',REVERB_Auditorium:'REVERB_Auditorium',REVERB_ConcertHall:'REVERB_ConcertHall',REVERB_Cave:'REVERB_Cave',REVERB_Hallway:'REVERB_Hallway',REVERB_StoneCorridor:'REVERB_StoneCorridor',REVERB_Alley:'REVERB_Alley',REVERB_Forest:'REVERB_Forest',REVERB_City:'REVERB_City',REVERB_Mountains:'REVERB_Mountains',REVERB_Quarry:'REVERB_Quarry',REVERB_Plain:'REVERB_Plain',REVERB_ParkingLot:'REVERB_ParkingLot',REVERB_SewerPipe:'REVERB_SewerPipe',REVERB_Underwater:'REVERB_Underwater',REVERB_SmallRoom:'REVERB_SmallRoom',REVERB_MediumRoom:'REVERB_MediumRoom',REVERB_LargeRoom:'REVERB_LargeRoom',REVERB_MediumHall:'REVERB_MediumHall',REVERB_LargeHall:'REVERB_LargeHall',REVERB_Plate:'REVERB_Plate', };
declare class ReverbEffect extends UObject { 
	Density: number;
	Diffusion: number;
	Gain: number;
	GainHF: number;
	DecayTime: number;
	DecayHFRatio: number;
	ReflectionsGain: number;
	ReflectionsDelay: number;
	LateGain: number;
	LateDelay: number;
	AirAbsorptionGainHF: number;
	RoomRolloffFactor: number;
	bChanged: boolean;
	static Load(ResourceName: string): ReverbEffect;
	static Find(Outer: UObject, ResourceName: string): ReverbEffect;
	static GetDefaultObject(): ReverbEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffect;
	static C(Other: UObject | any): ReverbEffect;
}

declare class ReverbSettings { 
	bApplyReverb: boolean;
	ReverbType: ReverbPreset;
	ReverbEffect: ReverbEffect;
	Volume: number;
	FadeTime: number;
	clone() : ReverbSettings;
	static C(Other: UObject | any): ReverbSettings;
}

declare class InteriorSettings { 
	bIsWorldSettings: boolean;
	ExteriorVolume: number;
	ExteriorTime: number;
	ExteriorLPF: number;
	ExteriorLPFTime: number;
	InteriorVolume: number;
	InteriorTime: number;
	InteriorLPF: number;
	InteriorLPFTime: number;
	clone() : InteriorSettings;
	static C(Other: UObject | any): InteriorSettings;
}

declare type ELandscapeCullingPrecision = 'High' | 'Medium' | 'Low';
declare var ELandscapeCullingPrecision : { High:'High',Medium:'Medium',Low:'Low', };
declare class MeshProxySettings { 
	ScreenSize: number;
	MaterialSettings: MaterialProxySettings;
	TextureWidth: number;
	TextureHeight: number;
	bExportNormalMap: boolean;
	bExportMetallicMap: boolean;
	bExportRoughnessMap: boolean;
	bExportSpecularMap: boolean;
	bCalculateCorrectLODModel: boolean;
	MergeDistance: number;
	HardAngleThreshold: number;
	LightMapResolution: number;
	bComputeLightMapResolution: boolean;
	bRecalculateNormals: boolean;
	bBakeVertexData: boolean;
	bUseLandscapeCulling: boolean;
	LandscapeCullingPrecision: ELandscapeCullingPrecision;
	clone() : MeshProxySettings;
	static C(Other: UObject | any): MeshProxySettings;
}

declare type EMeshLODSelectionType = 'AllLODs' | 'SpecificLOD' | 'CalculateLOD';
declare var EMeshLODSelectionType : { AllLODs:'AllLODs',SpecificLOD:'SpecificLOD',CalculateLOD:'CalculateLOD', };
declare class MeshMergingSettings { 
	bGenerateLightMapUV: boolean;
	TargetLightMapResolution: number;
	bComputedLightMapResolution: boolean;
	bImportVertexColors: boolean;
	bPivotPointAtZero: boolean;
	bMergePhysicsData: boolean;
	bMergeMaterials: boolean;
	MaterialSettings: MaterialProxySettings;
	bBakeVertexDataToMesh: boolean;
	bUseVertexDataForBakingMaterial: boolean;
	bUseTextureBinning: boolean;
	bCalculateCorrectLODModel: boolean;
	LODSelectionType: LODSelectionType;
	ExportSpecificLOD: number;
	SpecificLOD: number;
	bUseLandscapeCulling: boolean;
	bExportNormalMap: boolean;
	bExportMetallicMap: boolean;
	bExportRoughnessMap: boolean;
	bExportSpecularMap: boolean;
	MergedMaterialAtlasResolution: number;
	clone() : MeshMergingSettings;
	static C(Other: UObject | any): MeshMergingSettings;
}

declare class HierarchicalSimplification { 
	TransitionScreenSize: number;
	bSimplifyMesh: boolean;
	ProxySetting: MeshProxySettings;
	MergeSetting: MeshMergingSettings;
	DesiredBoundRadius: number;
	DesiredFillingPercentage: number;
	MinNumberOfActorsToBuild: number;
	clone() : HierarchicalSimplification;
	static C(Other: UObject | any): HierarchicalSimplification;
}

declare class BookMark extends UObject { 
	Location: Vector;
	Rotation: Rotator;
	HiddenLevels: string[];
	static Load(ResourceName: string): BookMark;
	static Find(Outer: UObject, ResourceName: string): BookMark;
	static GetDefaultObject(): BookMark;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BookMark;
	static C(Other: UObject | any): BookMark;
}

declare class NetViewer { 
	Connection: NetConnection;
	InViewer: Actor;
	ViewTarget: Actor;
	ViewLocation: Vector;
	ViewDir: Vector;
	clone() : NetViewer;
	static C(Other: UObject | any): NetViewer;
}

declare class WorldSettings extends Info { 
	bEnableWorldBoundsChecks: boolean;
	bEnableNavigationSystem: boolean;
	bEnableAISystem: boolean;
	bEnableWorldComposition: boolean;
	bUseClientSideLevelStreamingVolumes: boolean;
	bEnableWorldOriginRebasing: boolean;
	bWorldGravitySet: boolean;
	bGlobalGravitySet: boolean;
	KillZ: number;
	KillZDamageType: UnrealEngineClass;
	WorldGravityZ: number;
	GlobalGravityZ: number;
	DefaultPhysicsVolumeClass: UnrealEngineClass;
	PhysicsCollisionHandlerClass: UnrealEngineClass;
	DefaultGameMode: UnrealEngineClass;
	GameNetworkManagerClass: UnrealEngineClass;
	PackedLightAndShadowMapTextureSize: number;
	bMinimizeBSPSections: boolean;
	DefaultColorScale: Vector;
	DefaultMaxDistanceFieldOcclusionDistance: number;
	GlobalDistanceFieldViewDistance: number;
	DynamicIndirectShadowsSelfShadowingIntensity: number;
	bPrecomputeVisibility: boolean;
	bPlaceCellsOnlyAlongCameraTracks: boolean;
	VisibilityCellSize: number;
	VisibilityAggressiveness: EVisibilityAggressiveness;
	bForceNoPrecomputedLighting: boolean;
	LightmassSettings: LightmassWorldInfoSettings;
	DefaultReverbSettings: ReverbSettings;
	DefaultAmbientZoneSettings: InteriorSettings;
	DefaultBaseSoundMix: SoundMix;
	bEnableHierarchicalLODSystem: boolean;
	HierarchicalLODSetup: HierarchicalSimplification[];
	NumHLODLevels: number;
	WorldToMeters: number;
	MonoCullingDistance: number;
	BookMarks: BookMark;
	TimeDilation: number;
	MatineeTimeDilation: number;
	DemoPlayTimeDilation: number;
	MinGlobalTimeDilation: number;
	MaxGlobalTimeDilation: number;
	MinUndilatedFrameTime: number;
	MaxUndilatedFrameTime: number;
	Pauser: PlayerState;
	bHighPriorityLoading: boolean;
	bHighPriorityLoadingLocal: boolean;
	ReplicationViewers: NetViewer[];
	AssetUserData: AssetUserData[];
	static GetDefaultObject(): WorldSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSettings;
	OnRep_WorldGravityZ(): void;
	static C(Other: UObject | any): WorldSettings;
}

declare class Level extends UObject { 
	OwningWorld: World;
	Model: Model;
	ModelComponents: ModelComponent[];
	ActorCluster: LevelActorContainer;
	LevelScriptBlueprint: LevelScriptBlueprint;
	TextureStreamingResourceGuids: Guid[];
	NumTextureStreamingUnbuiltComponents: number;
	NumTextureStreamingDirtyResources: number;
	LevelScriptActor: LevelScriptActor;
	NavListStart: NavigationObjectBase;
	NavListEnd: NavigationObjectBase;
	NavDataChunks: NavigationDataChunk[];
	LightmapTotalSize: number;
	ShadowmapTotalSize: number;
	StaticNavigableGeometry: Vector[];
	StreamingTextureGuids: Guid[];
	bIsLightingScenario: boolean;
	LevelBuildDataId: Guid;
	MapBuildData: MapBuildDataRegistry;
	LightBuildLevelOffset: IntVector;
	bTextureStreamingRotationChanged: boolean;
	bIsVisible: boolean;
	bLocked: boolean;
	LevelSimplification: LevelSimplificationDetails;
	LevelColor: LinearColor;
	WorldSettings: WorldSettings;
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): Level;
	static Find(Outer: UObject, ResourceName: string): Level;
	static GetDefaultObject(): Level;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Level;
	static C(Other: UObject | any): Level;
	UpdateModelComponents(): void;
	static UpdateModelComponents(Level: Level): void;
}

declare type EPathFollowingAction = 'Error' | 'NoMove' | 'DirectMove' | 'PartialPath' | 'PathToGoal';
declare var EPathFollowingAction : { Error:'Error',NoMove:'NoMove',DirectMove:'DirectMove',PartialPath:'PartialPath',PathToGoal:'PathToGoal', };
declare class PathFollowingComponent extends ActorComponent { 
	MovementComp: NavMovementComponent;
	MyNavData: NavigationData;
	static Load(ResourceName: string): PathFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): PathFollowingComponent;
	static GetDefaultObject(): PathFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingComponent;
	OnNavDataRegistered(NavData: NavigationData): void;
	OnActorBump(SelfActor: Actor,OtherActor: Actor,NormalImpulse: Vector,Hit: HitResult): void;
	GetPathDestination(): Vector;
	GetPathActionType(): EPathFollowingAction;
	static C(Other: UObject | any): PathFollowingComponent;
}

declare class BlackboardKeyType extends UObject { 
	static Load(ResourceName: string): BlackboardKeyType;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType;
	static GetDefaultObject(): BlackboardKeyType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType;
	static C(Other: UObject | any): BlackboardKeyType;
}

declare class BlackboardEntry { 
	EntryName: string;
	EntryDescription: string;
	KeyType: BlackboardKeyType;
	bInstanceSynced: boolean;
	clone() : BlackboardEntry;
	static C(Other: UObject | any): BlackboardEntry;
}

declare class BlackboardData extends DataAsset { 
	Parent: BlackboardData;
	ParentKeys: BlackboardEntry[];
	Keys: BlackboardEntry[];
	bHasSynchronizedKeys: boolean;
	static Load(ResourceName: string): BlackboardData;
	static Find(Outer: UObject, ResourceName: string): BlackboardData;
	static GetDefaultObject(): BlackboardData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardData;
	static C(Other: UObject | any): BlackboardData;
}

declare class BlackboardComponent extends ActorComponent { 
	BrainComp: BrainComponent;
	BlackboardAsset: BlackboardData;
	KeyInstances: BlackboardKeyType[];
	static Load(ResourceName: string): BlackboardComponent;
	static Find(Outer: UObject, ResourceName: string): BlackboardComponent;
	static GetDefaultObject(): BlackboardComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardComponent;
	SetValueAsVector(KeyName: string,VectorValue: Vector): void;
	SetValueAsString(KeyName: string,StringValue: string): void;
	SetValueAsRotator(KeyName: string,VectorValue: Rotator): void;
	SetValueAsObject(KeyName: string,ObjectValue: UObject): void;
	SetValueAsName(KeyName: string,NameValue: string): void;
	SetValueAsInt(KeyName: string,IntValue: number): void;
	SetValueAsFloat(KeyName: string,FloatValue: number): void;
	SetValueAsEnum(KeyName: string,EnumValue: number): void;
	SetValueAsClass(KeyName: string,ClassValue: UnrealEngineClass): void;
	SetValueAsBool(KeyName: string,BoolValue: boolean): void;
	IsVectorValueSet(KeyName: string): boolean;
	GetValueAsVector(KeyName: string): Vector;
	GetValueAsString(KeyName: string): string;
	GetValueAsRotator(KeyName: string): Rotator;
	GetValueAsObject(KeyName: string): UObject;
	GetValueAsName(KeyName: string): string;
	GetValueAsInt(KeyName: string): number;
	GetValueAsFloat(KeyName: string): number;
	GetValueAsEnum(KeyName: string): number;
	GetValueAsClass(KeyName: string): UnrealEngineClass;
	GetValueAsBool(KeyName: string): boolean;
	GetRotationFromEntry(KeyName: string,ResultRotation?: Rotator): {ResultRotation: Rotator, $: boolean};
	GetLocationFromEntry(KeyName: string,ResultLocation?: Vector): {ResultLocation: Vector, $: boolean};
	ClearValue(KeyName: string): void;
	static C(Other: UObject | any): BlackboardComponent;
}

declare class BrainComponent extends ActorComponent { 
	BlackboardComp: BlackboardComponent;
	AIOwner: AIController;
	static Load(ResourceName: string): BrainComponent;
	static Find(Outer: UObject, ResourceName: string): BrainComponent;
	static GetDefaultObject(): BrainComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrainComponent;
	StopLogic(Reason: string): void;
	RestartLogic(): void;
	IsRunning(): boolean;
	IsPaused(): boolean;
	static C(Other: UObject | any): BrainComponent;
}

declare class AISenseConfig extends UObject { 
	DebugColor: Color;
	MaxAge: number;
	bStartsEnabled: boolean;
	static Load(ResourceName: string): AISenseConfig;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig;
	static GetDefaultObject(): AISenseConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig;
	static C(Other: UObject | any): AISenseConfig;
}

declare type EAISenseNotifyType = 'OnEveryPerception' | 'OnPerceptionChange';
declare var EAISenseNotifyType : { OnEveryPerception:'OnEveryPerception',OnPerceptionChange:'OnPerceptionChange', };
declare class AISenseEvent extends UObject { 
	static Load(ResourceName: string): AISenseEvent;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent;
	static GetDefaultObject(): AISenseEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent;
	static C(Other: UObject | any): AISenseEvent;
}

declare class AIStimulus { 
	Age: number;
	ExpirationAge: number;
	Strength: number;
	StimulusLocation: Vector;
	ReceiverLocation: Vector;
	Tag: string;
	bSuccessfullySensed: boolean;
	clone() : AIStimulus;
	static C(Other: UObject | any): AIStimulus;
}

declare class AIPerceptionSystem extends UObject { 
	Senses: AISense[];
	PerceptionAgingRate: number;
	static Load(ResourceName: string): AIPerceptionSystem;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionSystem;
	static GetDefaultObject(): AIPerceptionSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionSystem;
	static ReportPerceptionEvent(WorldContextObject: UObject,PerceptionEvent: AISenseEvent): void;
	ReportEvent(PerceptionEvent: AISenseEvent): void;
	static RegisterPerceptionStimuliSource(WorldContextObject: UObject,Sense: UnrealEngineClass,Target: Actor): boolean;
	OnPerceptionStimuliSourceEndPlay(Actor: Actor,EndPlayReason: EEndPlayReason): void;
	static GetSenseClassForStimulus(WorldContextObject: UObject,Stimulus: AIStimulus): UnrealEngineClass;
	static C(Other: UObject | any): AIPerceptionSystem;
}

declare class AISense extends UObject { 
	DefaultExpirationAge: number;
	NotifyType: NotifyType;
	bWantsNewPawnNotification: boolean;
	bAutoRegisterAllPawnsAsSources: boolean;
	PerceptionSystemInstance: AIPerceptionSystem;
	static Load(ResourceName: string): AISense;
	static Find(Outer: UObject, ResourceName: string): AISense;
	static GetDefaultObject(): AISense;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense;
	static C(Other: UObject | any): AISense;
}

declare class ActorPerceptionBlueprintInfo { 
	Target: Actor;
	LastSensedStimuli: AIStimulus[];
	bIsHostile: boolean;
	clone() : ActorPerceptionBlueprintInfo;
	static C(Other: UObject | any): ActorPerceptionBlueprintInfo;
}

declare class AIPerceptionComponent extends ActorComponent { 
	SensesConfig: AISenseConfig[];
	DominantSense: UnrealEngineClass;
	AIOwner: AIController;
	OnPerceptionUpdated: UnrealEngineMulticastDelegate<(UpdatedActors: Actor[]) => void>;
	OnTargetPerceptionUpdated: UnrealEngineMulticastDelegate<(Actor: Actor, Stimulus: AIStimulus) => void>;
	static Load(ResourceName: string): AIPerceptionComponent;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionComponent;
	static GetDefaultObject(): AIPerceptionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionComponent;
	SetSenseEnabled(SenseClass: UnrealEngineClass,bEnable: boolean): void;
	RequestStimuliListenerUpdate(): void;
	OnOwnerEndPlay(Actor: Actor,EndPlayReason: EEndPlayReason): void;
	GetPerceivedHostileActors(OutActors?: Actor[]): {OutActors: Actor[]};
	GetPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetKnownPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetCurrentlyPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetActorsPerception(Actor: Actor,Info?: ActorPerceptionBlueprintInfo): {Info: ActorPerceptionBlueprintInfo, $: boolean};
	static C(Other: UObject | any): AIPerceptionComponent;
}

declare type EAIRequestPriority = 'SoftScript' | 'Logic' | 'HardScript' | 'Reaction' | 'Ultimate';
declare var EAIRequestPriority : { SoftScript:'SoftScript',Logic:'Logic',HardScript:'HardScript',Reaction:'Reaction',Ultimate:'Ultimate', };
declare type EPawnActionResult = 'NotStarted' | 'InProgress' | 'Success' | 'Failed' | 'Aborted';
declare var EPawnActionResult : { NotStarted:'NotStarted',InProgress:'InProgress',Success:'Success',Failed:'Failed',Aborted:'Aborted', };
declare class PawnAction extends UObject { 
	ChildAction: PawnAction;
	ParentAction: PawnAction;
	OwnerComponent: PawnActionsComponent;
	Instigator: UObject;
	BrainComp: BrainComponent;
	bAllowNewSameClassInstance: boolean;
	bReplaceActiveSameClassInstance: boolean;
	bShouldPauseMovement: boolean;
	bAlwaysNotifyOnFinished: boolean;
	static Load(ResourceName: string): PawnAction;
	static Find(Outer: UObject, ResourceName: string): PawnAction;
	static GetDefaultObject(): PawnAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction;
	GetActionPriority(): EAIRequestPriority;
	Finish(WithResult: EPawnActionResult): void;
	static CreateActionInstance(WorldContextObject: UObject,ActionClass: UnrealEngineClass): PawnAction;
	static C(Other: UObject | any): PawnAction;
}

declare class PawnActionStack { 
	TopAction: PawnAction;
	clone() : PawnActionStack;
	static C(Other: UObject | any): PawnActionStack;
}

declare class PawnActionEvent { 
	Action: PawnAction;
	clone() : PawnActionEvent;
	static C(Other: UObject | any): PawnActionEvent;
}

declare type EPawnActionAbortState = 'NeverStarted' | 'NotBeingAborted' | 'MarkPendingAbort' | 'LatentAbortInProgress' | 'AbortDone';
declare var EPawnActionAbortState : { NeverStarted:'NeverStarted',NotBeingAborted:'NotBeingAborted',MarkPendingAbort:'MarkPendingAbort',LatentAbortInProgress:'LatentAbortInProgress',AbortDone:'AbortDone', };
declare class PawnActionsComponent extends ActorComponent { 
	ControlledPawn: Pawn;
	ActionStacks: PawnActionStack[];
	ActionEvents: PawnActionEvent[];
	CurrentAction: PawnAction;
	static Load(ResourceName: string): PawnActionsComponent;
	static Find(Outer: UObject, ResourceName: string): PawnActionsComponent;
	static GetDefaultObject(): PawnActionsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnActionsComponent;
	K2_PushAction(NewAction: PawnAction,Priority: EAIRequestPriority,Instigator: UObject): boolean;
	static K2_PerformAction(Pawn: Pawn,Action: PawnAction,Priority: EAIRequestPriority): boolean;
	K2_ForceAbortAction(ActionToAbort: PawnAction): EPawnActionAbortState;
	K2_AbortAction(ActionToAbort: PawnAction): EPawnActionAbortState;
	static C(Other: UObject | any): PawnActionsComponent;
}

declare type ETaskResourceOverlapPolicy = 'StartOnTop' | 'StartAtEnd';
declare var ETaskResourceOverlapPolicy : { StartOnTop:'StartOnTop',StartAtEnd:'StartAtEnd', };
declare class GameplayTask extends UObject { 
	InstanceName: string;
	ResourceOverlapPolicy: ResourceOverlapPolicy;
	ChildTask: GameplayTask;
	static Load(ResourceName: string): GameplayTask;
	static Find(Outer: UObject, ResourceName: string): GameplayTask;
	static GetDefaultObject(): GameplayTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask;
	ReadyForActivation(): void;
	EndTask(): void;
	static C(Other: UObject | any): GameplayTask;
}

declare class GameplayResourceSet { 
	clone() : GameplayResourceSet;
	static C(Other: UObject | any): GameplayResourceSet;
}

declare class GameplayTasksComponent extends ActorComponent { 
	SimulatedTasks: GameplayTask[];
	TaskPriorityQueue: GameplayTask[];
	TickingTasks: GameplayTask[];
	KnownTasks: GameplayTask[];
	OnClaimedResourcesChange: UnrealEngineMulticastDelegate<(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet) => void>;
	static Load(ResourceName: string): GameplayTasksComponent;
	static Find(Outer: UObject, ResourceName: string): GameplayTasksComponent;
	static GetDefaultObject(): GameplayTasksComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTasksComponent;
	OnRep_SimulatedTasks(): void;
	static C(Other: UObject | any): GameplayTasksComponent;
}

declare class NavigationFilterArea { 
	AreaClass: UnrealEngineClass;
	TravelCostOverride: number;
	EnteringCostOverride: number;
	bIsExcluded: boolean;
	bOverrideTravelCost: boolean;
	bOverrideEnteringCost: boolean;
	clone() : NavigationFilterArea;
	static C(Other: UObject | any): NavigationFilterArea;
}

declare class NavigationFilterFlags { 
	bNavFlag0: boolean;
	bNavFlag1: boolean;
	bNavFlag2: boolean;
	bNavFlag3: boolean;
	bNavFlag4: boolean;
	bNavFlag5: boolean;
	bNavFlag6: boolean;
	bNavFlag7: boolean;
	bNavFlag8: boolean;
	bNavFlag9: boolean;
	bNavFlag10: boolean;
	bNavFlag11: boolean;
	bNavFlag12: boolean;
	bNavFlag13: boolean;
	bNavFlag14: boolean;
	bNavFlag15: boolean;
	clone() : NavigationFilterFlags;
	static C(Other: UObject | any): NavigationFilterFlags;
}

declare class NavigationQueryFilter extends UObject { 
	Areas: NavigationFilterArea[];
	IncludeFlags: NavigationFilterFlags;
	ExcludeFlags: NavigationFilterFlags;
	static Load(ResourceName: string): NavigationQueryFilter;
	static Find(Outer: UObject, ResourceName: string): NavigationQueryFilter;
	static GetDefaultObject(): NavigationQueryFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationQueryFilter;
	static C(Other: UObject | any): NavigationQueryFilter;
}

declare class AIRequestID { 
	RequestID: any;
	clone() : AIRequestID;
	static C(Other: UObject | any): AIRequestID;
}

declare type EPathFollowingResult = 'Success' | 'Blocked' | 'OffPath' | 'Aborted' | 'Skipped_DEPRECATED' | 'Invalid';
declare var EPathFollowingResult : { Success:'Success',Blocked:'Blocked',OffPath:'OffPath',Aborted:'Aborted',Skipped_DEPRECATED:'Skipped_DEPRECATED',Invalid:'Invalid', };
declare class GameplayTaskResource extends UObject { 
	ManualResourceID: number;
	AutoResourceID: any;
	bManuallySetID: boolean;
	static Load(ResourceName: string): GameplayTaskResource;
	static Find(Outer: UObject, ResourceName: string): GameplayTaskResource;
	static GetDefaultObject(): GameplayTaskResource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskResource;
	static C(Other: UObject | any): GameplayTaskResource;
}

declare class BlackboardKeySelector { 
	AllowedTypes: BlackboardKeyType[];
	SelectedKeyName: string;
	SelectedKeyType: UnrealEngineClass;
	SelectedKeyID: number;
	bNoneIsAllowedValue: boolean;
	clone() : BlackboardKeySelector;
	static C(Other: UObject | any): BlackboardKeySelector;
}

declare class GameplayTagQuery { 
	TokenStreamVersion: number;
	TagDictionary: GameplayTag[];
	QueryTokenStream: number[];
	UserDescription: string;
	AutoDescription: string;
	clone() : GameplayTagQuery;
	static C(Other: UObject | any): GameplayTagQuery;
	MakeGameplayTagQuery(): GameplayTagQuery;
	static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
}

declare class GameplayTagContainer { 
	GameplayTags: GameplayTag[];
	ParentTags: GameplayTag[];
	clone() : GameplayTagContainer;
	static C(Other: UObject | any): GameplayTagContainer;
	AddGameplayTag(Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	AppendGameplayTagContainers(InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	BreakGameplayTagContainer(GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	DoesContainerMatchTagQuery(TagQuery: GameplayTagQuery): boolean;
	EqualEqual_GameplayTagContainer(B: GameplayTagContainer): boolean;
	GetDebugStringFromGameplayTagContainer(): string;
	GetNumGameplayTagsInContainer(): number;
	HasAllTags(OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	HasAnyTags(OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	HasTag(Tag: GameplayTag,bExactMatch: boolean): boolean;
	MakeLiteralGameplayTagContainer(): GameplayTagContainer;
	NotEqual_GameplayTagContainer(B: GameplayTagContainer): boolean;
	NotEqual_TagContainerTagContainer(B: string): boolean;
	RemoveGameplayTag(Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static AddGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	static AppendGameplayTagContainers(InOutTagContainer?: GameplayTagContainer,InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer,GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer,TagQuery: GameplayTagQuery): boolean;
	static EqualEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;
	static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
	static HasAllTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasAnyTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasTag(TagContainer: GameplayTagContainer,Tag: GameplayTag,bExactMatch: boolean): boolean;
	static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;
	static NotEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static NotEqual_TagContainerTagContainer(A: GameplayTagContainer,B: string): boolean;
	static RemoveGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static MakeGameplayTagContainerFromArray(GameplayTags: GameplayTag[]): GameplayTagContainer;
}

declare class GameplayTag { 
	TagName: string;
	clone() : GameplayTag;
	static C(Other: UObject | any): GameplayTag;
	EqualEqual_GameplayTag(B: GameplayTag): boolean;
	GetDebugStringFromGameplayTag(): string;
	GetTagName(): string;
	IsGameplayTagValid(): boolean;
	MakeGameplayTagContainerFromTag(): GameplayTagContainer;
	MakeLiteralGameplayTag(): GameplayTag;
	MatchesAnyTags(OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	MatchesTag(TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	NotEqual_GameplayTag(B: GameplayTag): boolean;
	NotEqual_TagTag(B: string): boolean;
	static EqualEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
	static GetTagName(GameplayTag: GameplayTag): string;
	static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;
	static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	static MatchesAnyTags(TagOne: GameplayTag,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static MatchesTag(TagOne: GameplayTag,TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	static NotEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static NotEqual_TagTag(A: GameplayTag,B: string): boolean;
}

declare class BehaviorTreeComponent extends BrainComponent { 
	NodeInstances: BTNode[];
	static Load(ResourceName: string): BehaviorTreeComponent;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeComponent;
	static GetDefaultObject(): BehaviorTreeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeComponent;
	SetDynamicSubtree(InjectTag: GameplayTag,BehaviorAsset: BehaviorTree): void;
	GetTagCooldownEndTime(CooldownTag: GameplayTag): number;
	AddCooldownTagDuration(CooldownTag: GameplayTag,CooldownDuration: number,bAddToExistingDuration: boolean): void;
	static C(Other: UObject | any): BehaviorTreeComponent;
}

declare class BTNode extends UObject { 
	NodeName: string;
	TreeAsset: BehaviorTree;
	ParentNode: BTCompositeNode;
	static Load(ResourceName: string): BTNode;
	static Find(Outer: UObject, ResourceName: string): BTNode;
	static GetDefaultObject(): BTNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTNode;
	static C(Other: UObject | any): BTNode;
	ClearBlackboardValue(Key: BlackboardKeySelector): void;
	ClearBlackboardValueAsVector(Key: BlackboardKeySelector): void;
	GetBlackboardValueAsActor(Key: BlackboardKeySelector): Actor;
	GetBlackboardValueAsBool(Key: BlackboardKeySelector): boolean;
	GetBlackboardValueAsClass(Key: BlackboardKeySelector): UnrealEngineClass;
	GetBlackboardValueAsEnum(Key: BlackboardKeySelector): number;
	GetBlackboardValueAsFloat(Key: BlackboardKeySelector): number;
	GetBlackboardValueAsInt(Key: BlackboardKeySelector): number;
	GetBlackboardValueAsName(Key: BlackboardKeySelector): string;
	GetBlackboardValueAsObject(Key: BlackboardKeySelector): UObject;
	GetBlackboardValueAsRotator(Key: BlackboardKeySelector): Rotator;
	GetBlackboardValueAsString(Key: BlackboardKeySelector): string;
	GetBlackboardValueAsVector(Key: BlackboardKeySelector): Vector;
	GetOwnerComponent(): BehaviorTreeComponent;
	GetOwnersBlackboard(): BlackboardComponent;
	SetBlackboardValueAsBool(Key: BlackboardKeySelector,Value: boolean): void;
	SetBlackboardValueAsClass(Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	SetBlackboardValueAsEnum(Key: BlackboardKeySelector,Value: number): void;
	SetBlackboardValueAsFloat(Key: BlackboardKeySelector,Value: number): void;
	SetBlackboardValueAsInt(Key: BlackboardKeySelector,Value: number): void;
	SetBlackboardValueAsName(Key: BlackboardKeySelector,Value: string): void;
	SetBlackboardValueAsObject(Key: BlackboardKeySelector,Value: UObject): void;
	SetBlackboardValueAsRotator(Key: BlackboardKeySelector,Value: Rotator): void;
	SetBlackboardValueAsString(Key: BlackboardKeySelector,Value: string): void;
	SetBlackboardValueAsVector(Key: BlackboardKeySelector,Value: Vector): void;
	StartUsingExternalEvent(OwningActor: Actor): void;
	StopUsingExternalEvent(): void;
	static ClearBlackboardValue(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static ClearBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static GetBlackboardValueAsActor(NodeOwner: BTNode,Key: BlackboardKeySelector): Actor;
	static GetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector): boolean;
	static GetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector): UnrealEngineClass;
	static GetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector): UObject;
	static GetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector): Rotator;
	static GetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): Vector;
	static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
	static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
	static SetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: boolean): void;
	static SetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	static SetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UObject): void;
	static SetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Rotator): void;
	static SetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Vector): void;
	static StartUsingExternalEvent(NodeOwner: BTNode,OwningActor: Actor): void;
	static StopUsingExternalEvent(NodeOwner: BTNode): void;
}

declare class BTAuxiliaryNode extends BTNode { 
	static Load(ResourceName: string): BTAuxiliaryNode;
	static Find(Outer: UObject, ResourceName: string): BTAuxiliaryNode;
	static GetDefaultObject(): BTAuxiliaryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTAuxiliaryNode;
	static C(Other: UObject | any): BTAuxiliaryNode;
}

declare class BTService extends BTAuxiliaryNode { 
	Interval: number;
	RandomDeviation: number;
	bCallTickOnSearchStart: boolean;
	bRestartTimerOnEachActivation: boolean;
	static Load(ResourceName: string): BTService;
	static Find(Outer: UObject, ResourceName: string): BTService;
	static GetDefaultObject(): BTService;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService;
	static C(Other: UObject | any): BTService;
}

declare class BTTaskNode extends BTNode { 
	Services: BTService[];
	bIgnoreRestartSelf: boolean;
	static Load(ResourceName: string): BTTaskNode;
	static Find(Outer: UObject, ResourceName: string): BTTaskNode;
	static GetDefaultObject(): BTTaskNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTaskNode;
	static C(Other: UObject | any): BTTaskNode;
}

declare type EBTFlowAbortMode = 'None' | 'LowerPriority' | 'Self' | 'Both';
declare var EBTFlowAbortMode : { None:'None',LowerPriority:'LowerPriority',Self:'Self',Both:'Both', };
declare class BTDecorator extends BTAuxiliaryNode { 
	bInverseCondition: boolean;
	FlowAbortMode: EBTFlowAbortMode;
	static Load(ResourceName: string): BTDecorator;
	static Find(Outer: UObject, ResourceName: string): BTDecorator;
	static GetDefaultObject(): BTDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator;
	static C(Other: UObject | any): BTDecorator;
}

declare type EBTDecoratorLogic = 'Invalid' | 'Test' | 'And' | 'Or' | 'Not';
declare var EBTDecoratorLogic : { Invalid:'Invalid',Test:'Test',And:'And',Or:'Or',Not:'Not', };
declare class BTDecoratorLogic { 
	Operation: EBTDecoratorLogic;
	Number: any;
	clone() : BTDecoratorLogic;
	static C(Other: UObject | any): BTDecoratorLogic;
}

declare class BTCompositeChild { 
	ChildComposite: BTCompositeNode;
	ChildTask: BTTaskNode;
	Decorators: BTDecorator[];
	DecoratorOps: BTDecoratorLogic[];
	clone() : BTCompositeChild;
	static C(Other: UObject | any): BTCompositeChild;
}

declare class BTCompositeNode extends BTNode { 
	Children: BTCompositeChild[];
	Services: BTService[];
	static Load(ResourceName: string): BTCompositeNode;
	static Find(Outer: UObject, ResourceName: string): BTCompositeNode;
	static GetDefaultObject(): BTCompositeNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTCompositeNode;
	static C(Other: UObject | any): BTCompositeNode;
}

declare class BehaviorTree extends UObject { 
	RootNode: BTCompositeNode;
	BTGraph: EdGraph;
	LastEditedDocuments: EditedDocumentInfo[];
	BlackboardAsset: BlackboardData;
	RootDecorators: BTDecorator[];
	RootDecoratorOps: BTDecoratorLogic[];
	static Load(ResourceName: string): BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): BehaviorTree;
	static GetDefaultObject(): BehaviorTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTree;
	static C(Other: UObject | any): BehaviorTree;
}

declare type EPathFollowingRequestResult = 'Failed' | 'AlreadyAtGoal' | 'RequestSuccessful';
declare var EPathFollowingRequestResult : { Failed:'Failed',AlreadyAtGoal:'AlreadyAtGoal',RequestSuccessful:'RequestSuccessful', };
declare type EPathFollowingStatus = 'Idle' | 'Waiting' | 'Paused' | 'Moving';
declare var EPathFollowingStatus : { Idle:'Idle',Waiting:'Waiting',Paused:'Paused',Moving:'Moving', };
declare class AIController extends Controller { 
	bStopAILogicOnUnposses: boolean;
	bLOSflag: boolean;
	bSkipExtraLOSChecks: boolean;
	bAllowStrafe: boolean;
	bWantsPlayerState: boolean;
	bSetControlRotationFromPawnOrientation: boolean;
	PathFollowingComponent: PathFollowingComponent;
	BrainComponent: BrainComponent;
	PerceptionComponent: AIPerceptionComponent;
	ActionsComp: PawnActionsComponent;
	Blackboard: BlackboardComponent;
	CachedGameplayTasksComponent: GameplayTasksComponent;
	DefaultNavigationFilterClass: UnrealEngineClass;
	ReceiveMoveCompleted: UnrealEngineMulticastDelegate<(RequestID: AIRequestID, Result: EPathFollowingResult) => void>;
	static GetDefaultObject(): AIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIController;
	UseBlackboard(BlackboardAsset: BlackboardData,BlackboardComponent?: BlackboardComponent): {BlackboardComponent: BlackboardComponent, $: boolean};
	UnclaimTaskResource(ResourceClass: UnrealEngineClass): void;
	SetMoveBlockDetection(bEnable: boolean): void;
	RunBehaviorTree(BTAsset: BehaviorTree): boolean;
	OnUsingBlackBoard(BlackboardComp: BlackboardComponent,BlackboardAsset: BlackboardData): void;
	OnUnpossess(UnpossessedPawn: Pawn): void;
	OnPossess(PossessedPawn: Pawn): void;
	OnGameplayTaskResourcesClaimed(NewlyClaimed: GameplayResourceSet,FreshlyReleased: GameplayResourceSet): void;
	MoveToLocation(Dest: Vector,AcceptanceRadius: number,bStopOnOverlap: boolean,bUsePathfinding: boolean,bProjectDestinationToNavigation: boolean,bCanStrafe: boolean,FilterClass: UnrealEngineClass,bAllowPartialPath: boolean): EPathFollowingRequestResult;
	MoveToActor(Goal: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean,bUsePathfinding: boolean,bCanStrafe: boolean,FilterClass: UnrealEngineClass,bAllowPartialPath: boolean): EPathFollowingRequestResult;
	K2_SetFocus(NewFocus: Actor): void;
	K2_SetFocalPoint(FP: Vector): void;
	K2_ClearFocus(): void;
	HasPartialPath(): boolean;
	GetPathFollowingComponent(): PathFollowingComponent;
	GetMoveStatus(): EPathFollowingStatus;
	GetImmediateMoveDestination(): Vector;
	GetFocusActor(): Actor;
	GetFocalPointOnActor(Actor: Actor): Vector;
	GetFocalPoint(): Vector;
	GetAIPerceptionComponent(): AIPerceptionComponent;
	ClaimTaskResource(ResourceClass: UnrealEngineClass): void;
	static C(Other: UObject | any): AIController;
}

declare class Actor extends UObject { 
	PrimaryActorTick: ActorTickFunction;
	CustomTimeDilation: number;
	bHidden: boolean;
	bNetTemporary: boolean;
	bNetStartup: boolean;
	bOnlyRelevantToOwner: boolean;
	bAlwaysRelevant: boolean;
	bReplicateMovement: boolean;
	bTearOff: boolean;
	bExchangedRoles: boolean;
	bNetLoadOnClient: boolean;
	bNetUseOwnerRelevancy: boolean;
	bBlockInput: boolean;
	bAllowTickBeforeBeginPlay: boolean;
	bActorEnableCollision: boolean;
	bReplicates: boolean;
	RemoteRole: ENetRole;
	Owner: Actor;
	NetDriverName: string;
	ReplicatedMovement: RepMovement;
	InitialLifeSpan: number;
	AttachmentReplication: RepAttachment;
	Role: ENetRole;
	NetDormancy: ENetDormancy;
	AutoReceiveInput: EAutoReceiveInput;
	InputConsumeOption: EInputConsumeOptions;
	InputPriority: number;
	InputComponent: InputComponent;
	NetCullDistanceSquared: number;
	NetTag: number;
	NetUpdateFrequency: number;
	MinNetUpdateFrequency: number;
	NetPriority: number;
	bAutoDestroyWhenFinished: boolean;
	bCanBeDamaged: boolean;
	bActorIsBeingDestroyed: boolean;
	bCollideWhenPlacing: boolean;
	bFindCameraComponentWhenViewTarget: boolean;
	bRelevantForNetworkReplays: boolean;
	bGenerateOverlapEventsDuringLevelStreaming: boolean;
	bCanBeInCluster: boolean;
	bAllowReceiveTickEventOnDedicatedServer: boolean;
	bActorSeamlessTraveled: boolean;
	bIgnoresOriginShifting: boolean;
	bEnableAutoLODGeneration: boolean;
	SpawnCollisionHandlingMethod: SpawnCollisionHandlingMethod;
	Instigator: Pawn;
	Children: Actor[];
	RootComponent: SceneComponent;
	PivotOffset: Vector;
	ControllingMatineeActors: MatineeActor[];
	Layers: string[];
	ParentComponentActor: any;
	ParentComponent: any;
	GroupActor: Actor;
	SpriteScale: number;
	ActorLabel: string;
	FolderPath: string;
	bActorLabelEditable: boolean;
	bHiddenEd: boolean;
	bEditable: boolean;
	bListedInSceneOutliner: boolean;
	bIsEditorPreviewActor: boolean;
	bHiddenEdLayer: boolean;
	bHiddenEdTemporary: boolean;
	bHiddenEdLevel: boolean;
	bLockLocation: boolean;
	Tags: string[];
	HiddenEditorViews: any;
	OnTakeAnyDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnTakePointDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnActorBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnActorEndOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnActorHit: UnrealEngineMulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnDestroyed: UnrealEngineMulticastDelegate<(DestroyedActor: Actor) => void>;
	OnEndPlay: UnrealEngineMulticastDelegate<(Actor: Actor, EndPlayReason: EEndPlayReason) => void>;
	BlueprintCreatedComponents: ActorComponent[];
	InstanceComponents: ActorComponent[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static GetDefaultObject(): Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Actor;
	WasRecentlyRendered(Tolerance: number): boolean;
	UserConstructionScript(): void;
	TearOff(): void;
	SnapRootComponentTo(InParentActor: Actor,InSocketName: string): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetReplicates(bInReplicates: boolean): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	SetOwner(NewOwner: Actor): void;
	SetNetDormancy(NewDormancy: ENetDormancy): void;
	SetLifeSpan(InLifespan: number): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	SetActorTickInterval(TickInterval: number): void;
	SetActorTickEnabled(bEnabled: boolean): void;
	SetActorScale3D(NewScale3D: Vector): void;
	SetActorRelativeScale3D(NewRelativeScale: Vector): void;
	SetActorHiddenInGame(bNewHidden: boolean): void;
	SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveRadialDamage(DamageReceived: number,DamageType: DamageType,Origin: Vector,HitInfo: HitResult,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceivePointDamage(Damage: number,DamageType: DamageType,HitLocation: Vector,HitNormal: Vector,HitComponent: PrimitiveComponent,BoneName: string,ShotFromDirection: Vector,InstigatedBy: Controller,DamageCauser: Actor,HitInfo: HitResult): void;
	ReceiveHit(MyComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,bSelfMoved: boolean,HitLocation: Vector,HitNormal: Vector,NormalImpulse: Vector,Hit: HitResult): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveDestroyed(): void;
	ReceiveBeginPlay(): void;
	ReceiveAnyDamage(Damage: number,DamageType: DamageType,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceiveActorOnReleased(ButtonReleased: Key): void;
	ReceiveActorOnInputTouchLeave(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnter(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnd(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchBegin(FingerIndex: ETouchIndex): void;
	ReceiveActorOnClicked(ButtonPressed: Key): void;
	ReceiveActorEndOverlap(OtherActor: Actor): void;
	ReceiveActorEndCursorOver(): void;
	ReceiveActorBeginOverlap(OtherActor: Actor): void;
	ReceiveActorBeginCursorOver(): void;
	PrestreamTextures(Seconds: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	OnRep_ReplicateMovement(): void;
	OnRep_ReplicatedMovement(): void;
	OnRep_Owner(): void;
	OnRep_Instigator(): void;
	OnRep_AttachmentReplication(): void;
	MakeNoise(Loudness: number,NoiseInstigator: Pawn,NoiseLocation: Vector,MaxRange: number,Tag: string): void;
	MakeMIDForMaterial(Parent: MaterialInterface): MaterialInstanceDynamic;
	K2_TeleportTo(DestLocation: Vector,DestRotation: Rotator): boolean;
	K2_SetActorTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorRotation(NewRotation: Rotator,bTeleportPhysics: boolean): boolean;
	K2_SetActorRelativeTransform(NewRelativeTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeRotation(NewRelativeRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeLocation(NewRelativeLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_OnReset(): void;
	K2_OnEndViewTarget(PC: PlayerController): void;
	K2_OnBecomeViewTarget(PC: PlayerController): void;
	K2_GetRootComponent(): SceneComponent;
	K2_GetActorRotation(): Rotator;
	K2_GetActorLocation(): Vector;
	K2_DetachFromActor(LocationRule: LocationRule,RotationRule: RotationRule,ScaleRule: ScaleRule): void;
	K2_DestroyComponent(Component: ActorComponent): void;
	K2_DestroyActor(): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: LocationRule,RotationRule: RotationRule,ScaleRule: ScaleRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachToActor(ParentActor: Actor,SocketName: string,LocationRule: LocationRule,RotationRule: RotationRule,ScaleRule: ScaleRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentToActor(InParentActor: Actor,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentTo(InParent: SceneComponent,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AddActorWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsTemporarilyHiddenInEditor(bIncludeParent: boolean): boolean;
	IsSelectable(): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsHiddenEdAtStartup(): boolean;
	IsHiddenEd(): boolean;
	IsEditable(): boolean;
	IsChildActor(): boolean;
	IsActorTickEnabled(): boolean;
	IsActorBeingDestroyed(): boolean;
	HasAuthority(): boolean;
	GetVerticalDistanceTo(OtherActor: Actor): number;
	GetVelocity(): Vector;
	GetTransform(): Transform;
	GetTickableWhenPaused(): boolean;
	GetSquaredDistanceTo(OtherActor: Actor): number;
	GetRemoteRole(): ENetRole;
	GetParentComponent(): ChildActorComponent;
	GetParentActor(): Actor;
	GetOwner(): Actor;
	GetOverlappingComponents(OverlappingComponents?: PrimitiveComponent[]): {OverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetLifeSpan(): number;
	GetInstigatorController(): Controller;
	GetInstigator(): Pawn;
	GetInputVectorAxisValue(InputAxisKey: Key): Vector;
	GetInputAxisValue(InputAxisName: string): number;
	GetInputAxisKeyValue(InputAxisKey: Key): number;
	GetHorizontalDotProductTo(OtherActor: Actor): number;
	GetHorizontalDistanceTo(OtherActor: Actor): number;
	GetGameTimeSinceCreation(): number;
	GetDotProductTo(OtherActor: Actor): number;
	GetDistanceTo(OtherActor: Actor): number;
	GetComponentsByTag(ComponentClass: UnrealEngineClass,Tag: string): ActorComponent[];
	GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	GetComponentByClass(ComponentClass: UnrealEngineClass): ActorComponent;
	GetAttachParentSocketName(): string;
	GetAttachParentActor(): Actor;
	GetAttachedActors(OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllChildActors(ChildActors?: Actor[],bIncludeDescendants?: boolean): {ChildActors: Actor[]};
	GetActorUpVector(): Vector;
	GetActorTimeDilation(): number;
	GetActorTickInterval(): number;
	GetActorScale3D(): Vector;
	GetActorRightVector(): Vector;
	GetActorRelativeScale3D(): Vector;
	GetActorForwardVector(): Vector;
	GetActorEyesViewPoint(OutLocation?: Vector,OutRotation?: Rotator): {OutLocation: Vector, OutRotation: Rotator};
	GetActorEnableCollision(): boolean;
	GetActorBounds(bOnlyCollidingComponents: boolean,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ForceNetUpdate(): void;
	FlushNetDormancy(): void;
	EnableInput(PlayerController: PlayerController): void;
	DisableInput(PlayerController: PlayerController): void;
	DetachRootComponentFromParent(bMaintainWorldPosition: boolean): void;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	AddComponent(TemplateName: string,bManualAttachment: boolean,RelativeTransform: Transform,ComponentTemplateContext: UObject): ActorComponent;
	ActorHasTag(Tag: string): boolean;
	static C(Other: UObject | any): Actor;
	ClearActorLabel(): void;
	GetActorLabel(): string;
	GetFolderPath(): string;
	IsActorLabelEditable(): boolean;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetFolderPath(NewFolderPath: string): void;
	SetFolderPath_Recursively(NewFolderPath: string): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	Actor_GetWorld(): World;
	GetLastRenderTime(): number;
	GetLevel(): Level;
	IsPendingKill(): boolean;
	ReregisterAllComponents(): void;
	SetActorFlags(Flags: number): void;
	SetRootComponent(Component: SceneComponent): void;
	GetActorBounds(Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ApplyDamage(BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	ApplyPointDamage(BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	FinishSpawningActor(SpawnTransform: Transform): Actor;
	GetAIController(): AIController;
	GetBlackboard(): BlackboardComponent;
	static ClearActorLabel(Actor: Actor): void;
	static GetActorLabel(Actor: Actor): string;
	static GetFolderPath(Actor: Actor): string;
	static IsActorLabelEditable(Actor: Actor): boolean;
	static SetActorLabel(Actor: Actor,NewActorLabel: string,bMarkDirty: boolean): void;
	static SetFolderPath(Actor: Actor,NewFolderPath: string): void;
	static SetFolderPath_Recursively(Actor: Actor,NewFolderPath: string): void;
	static SetIsTemporarilyHiddenInEditor(Actor: Actor,bIsHidden: boolean): void;
	static Actor_GetWorld(Actor: Actor): World;
	static GetLastRenderTime(Actor: Actor): number;
	static GetLevel(Actor: Actor): Level;
	static IsPendingKill(InActor: Actor): boolean;
	static ReregisterAllComponents(Actor: Actor): void;
	static SetActorFlags(Actor: Actor,Flags: number): void;
	static SetRootComponent(Actor: Actor,Component: SceneComponent): void;
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ApplyDamage(DamagedActor: Actor,BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static ApplyPointDamage(DamagedActor: Actor,BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static FinishSpawningActor(Actor: Actor,SpawnTransform: Transform): Actor;
	static GetAIController(ControlledActor: Actor): AIController;
	static GetBlackboard(Target: Actor): BlackboardComponent;
}

declare class LineBatchComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): LineBatchComponent;
	static Find(Outer: UObject, ResourceName: string): LineBatchComponent;
	static GetDefaultObject(): LineBatchComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LineBatchComponent;
	static C(Other: UObject | any): LineBatchComponent;
}

declare type EStreamingVolumeUsage = 'SVB_Loading' | 'SVB_LoadingAndVisibility' | 'SVB_VisibilityBlockingOnLoad' | 'SVB_BlockingOnLoad' | 'SVB_LoadingNotVisible';
declare var EStreamingVolumeUsage : { SVB_Loading:'SVB_Loading',SVB_LoadingAndVisibility:'SVB_LoadingAndVisibility',SVB_VisibilityBlockingOnLoad:'SVB_VisibilityBlockingOnLoad',SVB_BlockingOnLoad:'SVB_BlockingOnLoad',SVB_LoadingNotVisible:'SVB_LoadingNotVisible', };
declare class LevelStreamingVolume extends Volume { 
	StreamingLevelNames: string[];
	bEditorPreVisOnly: boolean;
	bDisabled: boolean;
	StreamingUsage: EStreamingVolumeUsage;
	static GetDefaultObject(): LevelStreamingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingVolume;
	static C(Other: UObject | any): LevelStreamingVolume;
}

declare class LevelStreaming extends UObject { 
	PackageName: string;
	WorldAsset: any;
	PackageNameToLoad: string;
	LODPackageNames: string[];
	LevelTransform: Transform;
	bShouldBeVisibleInEditor: boolean;
	bLocked: boolean;
	bShouldBeLoaded: boolean;
	bShouldBeVisible: boolean;
	bIsStatic: boolean;
	bShouldBlockOnLoad: boolean;
	LevelLODIndex: number;
	bDisableDistanceStreaming: boolean;
	bDrawOnLevelStatusMap: boolean;
	DrawColor: Color;
	LevelColor: LinearColor;
	EditorStreamingVolumes: LevelStreamingVolume[];
	MinTimeBetweenVolumeUnloadRequests: number;
	Keywords: string[];
	OnLevelLoaded: UnrealEngineMulticastDelegate<() => void>;
	OnLevelUnloaded: UnrealEngineMulticastDelegate<() => void>;
	OnLevelShown: UnrealEngineMulticastDelegate<() => void>;
	OnLevelHidden: UnrealEngineMulticastDelegate<() => void>;
	LoadedLevel: Level;
	PendingUnloadLevel: Level;
	FolderPath: string;
	static Load(ResourceName: string): LevelStreaming;
	static Find(Outer: UObject, ResourceName: string): LevelStreaming;
	static GetDefaultObject(): LevelStreaming;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreaming;
	IsStreamingStatePending(): boolean;
	IsLevelVisible(): boolean;
	IsLevelLoaded(): boolean;
	GetWorldAssetPackageFName(): string;
	GetLevelScriptActor(): LevelScriptActor;
	CreateInstance(UniqueInstanceName: string): LevelStreaming;
	static C(Other: UObject | any): LevelStreaming;
}

declare class DemoNetDriver extends NetDriver { 
	RollbackNetStartupActors: any;
	CheckpointSaveMaxMSPerFrame: number;
	bIsLocalReplay: boolean;
	static Load(ResourceName: string): DemoNetDriver;
	static Find(Outer: UObject, ResourceName: string): DemoNetDriver;
	static GetDefaultObject(): DemoNetDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DemoNetDriver;
	static C(Other: UObject | any): DemoNetDriver;
}

declare class ParticleEventManager extends Actor { 
	static GetDefaultObject(): ParticleEventManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEventManager;
	static C(Other: UObject | any): ParticleEventManager;
}

declare class BlueprintFunctionLibrary extends UObject { 
	static Load(ResourceName: string): BlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionLibrary;
	static GetDefaultObject(): BlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibrary;
	static C(Other: UObject | any): BlueprintFunctionLibrary;
}

declare class CrowdManagerBase extends UObject { 
	static Load(ResourceName: string): CrowdManagerBase;
	static Find(Outer: UObject, ResourceName: string): CrowdManagerBase;
	static GetDefaultObject(): CrowdManagerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManagerBase;
	static C(Other: UObject | any): CrowdManagerBase;
}

declare type ENavDataGatheringModeConfig = 'Invalid' | 'Instant' | 'Lazy';
declare var ENavDataGatheringModeConfig : { Invalid:'Invalid',Instant:'Instant',Lazy:'Lazy', };
declare type FNavigationSystemRunMode = 'InvalidMode' | 'GameMode' | 'EditorMode' | 'SimulationMode' | 'PIEMode';
declare var FNavigationSystemRunMode : { InvalidMode:'InvalidMode',GameMode:'GameMode',EditorMode:'EditorMode',SimulationMode:'SimulationMode',PIEMode:'PIEMode', };
declare class NavMeshBoundsVolume extends Volume { 
	SupportedAgents: NavAgentSelector;
	static GetDefaultObject(): NavMeshBoundsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMeshBoundsVolume;
	static C(Other: UObject | any): NavMeshBoundsVolume;
}

declare type ENavigationQueryResult = 'Invalid' | 'Error' | 'Fail' | 'Success';
declare var ENavigationQueryResult : { Invalid:'Invalid',Error:'Error',Fail:'Fail',Success:'Success', };
declare class NavigationSystem extends BlueprintFunctionLibrary { 
	MainNavData: NavigationData;
	AbstractNavData: NavigationData;
	CrowdManagerClass: UnrealEngineClass;
	bAutoCreateNavigationData: boolean;
	bAllowClientSideNavigation: boolean;
	bSupportRebuilding: boolean;
	bInitialBuildingLocked: boolean;
	bSkipAgentHeightCheckWhenPickingNavData: boolean;
	DataGatheringMode: DataGatheringMode;
	bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
	ActiveTilesUpdateInterval: number;
	SupportedAgents: NavDataConfig[];
	DirtyAreasUpdateFreq: number;
	NavDataSet: NavigationData[];
	NavDataRegistrationQueue: NavigationData[];
	OnNavDataRegisteredEvent: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OnNavigationGenerationFinishedDelegate: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OperationMode: OperationMode;
	static Load(ResourceName: string): NavigationSystem;
	static Find(Outer: UObject, ResourceName: string): NavigationSystem;
	static GetDefaultObject(): NavigationSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystem;
	UnregisterNavigationInvoker(Invoker: Actor): void;
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number): void;
	SetGeometryGatheringMode(NewMode: NewMode): void;
	ResetMaxSimultaneousTileGenerationJobsCount(): void;
	RegisterNavigationInvoker(Invoker: Actor,TileGenerationRadius: number,TileRemovalRadius: number): void;
	static ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,NavData: NavigationData,FilterClass: UnrealEngineClass,QueryExtent: Vector): Vector;
	OnNavigationBoundsUpdated(NavVolume: NavMeshBoundsVolume): void;
	static NavigationRaycast(WorldContextObject: UObject,RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	static K2_ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,ProjectedLocation?: Vector,NavData?: NavigationData,FilterClass?: UnrealEngineClass,QueryExtent?: Vector): {ProjectedLocation: Vector, $: boolean};
	static K2_GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static IsNavigationBeingBuiltOrLocked(WorldContextObject: UObject): boolean;
	static IsNavigationBeingBuilt(WorldContextObject: UObject): boolean;
	static GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetPathLength(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	static GetPathCost(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	static GetNavigationSystem(WorldContextObject: UObject): NavigationSystem;
	static FindPathToLocationSynchronously(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static FindPathToActorSynchronously(WorldContextObject: UObject,PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static C(Other: UObject | any): NavigationSystem;
}

declare class AISystemBase extends UObject { 
	AISystemClassName: SoftClassPath;
	AISystemModuleName: string;
	bInstantiateAISystemOnClient: boolean;
	static Load(ResourceName: string): AISystemBase;
	static Find(Outer: UObject, ResourceName: string): AISystemBase;
	static GetDefaultObject(): AISystemBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISystemBase;
	static C(Other: UObject | any): AISystemBase;
}

declare class AvoidanceManager extends UObject { 
	DefaultTimeToLive: number;
	LockTimeAfterAvoid: number;
	LockTimeAfterClean: number;
	DeltaTimeToPredict: number;
	ArtificialRadiusExpansion: number;
	TestHeightDifference: number;
	HeightCheckMargin: number;
	static Load(ResourceName: string): AvoidanceManager;
	static Find(Outer: UObject, ResourceName: string): AvoidanceManager;
	static GetDefaultObject(): AvoidanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AvoidanceManager;
	RegisterMovementComponent(MovementComp: MovementComponent,AvoidanceWeight: number): boolean;
	GetObjectCount(): number;
	GetNewAvoidanceUID(): number;
	GetAvoidanceVelocityForComponent(MovementComp: MovementComponent): Vector;
	static C(Other: UObject | any): AvoidanceManager;
}

declare class LevelCollection { 
	GameState: GameStateBase;
	NetDriver: NetDriver;
	DemoNetDriver: DemoNetDriver;
	PersistentLevel: Level;
	Levels: any;
	clone() : LevelCollection;
	static C(Other: UObject | any): LevelCollection;
}

declare class MaterialParameterCollectionInstance extends UObject { 
	Collection: MaterialParameterCollection;
	World: World;
	static Load(ResourceName: string): MaterialParameterCollectionInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialParameterCollectionInstance;
	static GetDefaultObject(): MaterialParameterCollectionInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollectionInstance;
	static C(Other: UObject | any): MaterialParameterCollectionInstance;
}

declare class LevelViewportInfo { 
	CamPosition: Vector;
	CamRotation: Rotator;
	CamOrthoZoom: number;
	CamUpdated: boolean;
	clone() : LevelViewportInfo;
	static C(Other: UObject | any): LevelViewportInfo;
}

declare class WorldComposition extends UObject { 
	TilesStreaming: LevelStreaming[];
	TilesStreamingTimeThreshold: any;
	bLoadAllTilesDuringCinematic: boolean;
	bRebaseOriginIn3DSpace: boolean;
	bLockTilesLocation: boolean;
	RebaseOriginDistance: number;
	static Load(ResourceName: string): WorldComposition;
	static Find(Outer: UObject, ResourceName: string): WorldComposition;
	static GetDefaultObject(): WorldComposition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldComposition;
	static C(Other: UObject | any): WorldComposition;
}

declare class URL { 
	Protocol: string;
	Host: string;
	Port: number;
	Map: string;
	RedirectURL: string;
	Op: string[];
	Portal: string;
	Valid: number;
	clone() : URL;
	static C(Other: UObject | any): URL;
}

declare type ERecastPartitioning = 'Monotone' | 'Watershed' | 'ChunkyMonotone';
declare var ERecastPartitioning : { Monotone:'Monotone',Watershed:'Watershed',ChunkyMonotone:'ChunkyMonotone', };
declare class RecastNavMesh extends NavigationData { 
	bDrawTriangleEdges: boolean;
	bDrawPolyEdges: boolean;
	bDrawFilledPolys: boolean;
	bDrawNavMeshEdges: boolean;
	bDrawTileBounds: boolean;
	bDrawPathCollidingGeometry: boolean;
	bDrawTileLabels: boolean;
	bDrawPolygonLabels: boolean;
	bDrawDefaultPolygonCost: boolean;
	bDrawLabelsOnPathNodes: boolean;
	bDrawNavLinks: boolean;
	bDrawFailedNavLinks: boolean;
	bDrawClusters: boolean;
	bDrawOctree: boolean;
	bDistinctlyDrawTilesBeingBuilt: boolean;
	bDrawNavMesh: boolean;
	DrawOffset: number;
	bFixedTilePoolSize: boolean;
	TilePoolSize: number;
	TileSizeUU: number;
	CellSize: number;
	CellHeight: number;
	AgentRadius: number;
	AgentHeight: number;
	AgentMaxHeight: number;
	AgentMaxSlope: number;
	AgentMaxStepHeight: number;
	MinRegionArea: number;
	MergeRegionSize: number;
	MaxSimplificationError: number;
	MaxSimultaneousTileGenerationJobsCount: number;
	TileNumberHardLimit: number;
	PolyRefTileBits: number;
	PolyRefNavPolyBits: number;
	PolyRefSaltBits: number;
	DefaultDrawDistance: number;
	DefaultMaxSearchNodes: number;
	DefaultMaxHierarchicalSearchNodes: number;
	RegionPartitioning: ERecastPartitioning;
	LayerPartitioning: ERecastPartitioning;
	RegionChunkSplits: number;
	LayerChunkSplits: number;
	bSortNavigationAreasByCost: boolean;
	bPerformVoxelFiltering: boolean;
	bMarkLowHeightAreas: boolean;
	bDoFullyAsyncNavDataGathering: boolean;
	bUseBetterOffsetsFromCorners: boolean;
	bStoreEmptyTileLayers: boolean;
	bUseVirtualFilters: boolean;
	bAllowNavLinkAsPathEnd: boolean;
	bUseVoxelCache: boolean;
	TileSetUpdateInterval: number;
	HeuristicScale: number;
	VerticalDeviationFromGroundCompensation: number;
	static GetDefaultObject(): RecastNavMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastNavMesh;
	static C(Other: UObject | any): RecastNavMesh;
}

declare class TraceChannelTestBatchOptions { 
	bLineTrace: boolean;
	bSphereTrace: boolean;
	bCapsuleTrace: boolean;
	bBoxTrace: boolean;
	bChannelTrace: boolean;
	bObjectsTrace: boolean;
	bProfileTrace: boolean;
	clone() : TraceChannelTestBatchOptions;
	static C(Other: UObject | any): TraceChannelTestBatchOptions;
}

declare type EDrawDebugTrace = 'None' | 'ForOneFrame' | 'ForDuration' | 'Persistent';
declare var EDrawDebugTrace : { None:'None',ForOneFrame:'ForOneFrame',ForDuration:'ForDuration',Persistent:'Persistent', };
declare class TraceQueryTestNames { 
	ComponentName: string;
	PhysicalMaterialName: string;
	ActorName: string;
	clone() : TraceQueryTestNames;
	static C(Other: UObject | any): TraceQueryTestNames;
}

declare class TraceQueryTestResultsInnerMost { 
	SingleHit: HitResult;
	SingleNames: TraceQueryTestNames;
	bSingleResult: boolean;
	MultiHits: HitResult[];
	MultiNames: TraceQueryTestNames[];
	bMultiResult: boolean;
	clone() : TraceQueryTestResultsInnerMost;
	static C(Other: UObject | any): TraceQueryTestResultsInnerMost;
}

declare class TraceQueryTestResultsInner { 
	LineResults: TraceQueryTestResultsInnerMost;
	SphereResults: TraceQueryTestResultsInnerMost;
	CapsuleResults: TraceQueryTestResultsInnerMost;
	BoxResults: TraceQueryTestResultsInnerMost;
	clone() : TraceQueryTestResultsInner;
	static C(Other: UObject | any): TraceQueryTestResultsInner;
}

declare class TraceQueryTestResults extends UObject { 
	ChannelResults: TraceQueryTestResultsInner;
	ObjectResults: TraceQueryTestResultsInner;
	ProfileResults: TraceQueryTestResultsInner;
	static Load(ResourceName: string): TraceQueryTestResults;
	static Find(Outer: UObject, ResourceName: string): TraceQueryTestResults;
	static GetDefaultObject(): TraceQueryTestResults;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TraceQueryTestResults;
	ToString(): string;
	static C(Other: UObject | any): TraceQueryTestResults;
}

declare type EComparisonTolerance = 'Zero' | 'Low' | 'Medium' | 'High' | 'Custom';
declare var EComparisonTolerance : { Zero:'Zero',Low:'Low',Medium:'Medium',High:'High',Custom:'Custom', };
declare class ComparisonToleranceAmount { 
	Red: number;
	Green: number;
	Blue: number;
	Alpha: number;
	MinBrightness: number;
	MaxBrightness: number;
	clone() : ComparisonToleranceAmount;
	static C(Other: UObject | any): ComparisonToleranceAmount;
}

declare class AutomationScreenshotOptions { 
	Resolution: Vector2D;
	Delay: number;
	bDisableNoisyRenderingFeatures: boolean;
	VisualizeBuffer: string;
	Tolerance: Tolerance;
	ToleranceAmount: ComparisonToleranceAmount;
	MaximumLocalError: number;
	MaximumGlobalError: number;
	bIgnoreAntiAliasing: boolean;
	bIgnoreColors: boolean;
	clone() : AutomationScreenshotOptions;
	static C(Other: UObject | any): AutomationScreenshotOptions;
	static GetDefaultScreenshotOptionsForGameplay(Tolerance: Tolerance,Delay: number): AutomationScreenshotOptions;
	static GetDefaultScreenshotOptionsForRendering(Tolerance: Tolerance,Delay: number): AutomationScreenshotOptions;
}

declare class AppleARKitFrame { 
	clone() : AppleARKitFrame;
	static C(Other: UObject | any): AppleARKitFrame;
}

declare type EAppleARKitHitTestResultType = 'None' | 'FeaturePoint' | 'EstimatedHorizontalPlane' | 'ExistingPlane' | 'ExistingPlaneUsingExtent' | 'EAppleARKitHitTestResultType_MAX' | '';
declare var EAppleARKitHitTestResultType : { None:'None',FeaturePoint:'FeaturePoint',EstimatedHorizontalPlane:'EstimatedHorizontalPlane',ExistingPlane:'ExistingPlane',ExistingPlaneUsingExtent:'ExistingPlaneUsingExtent',EAppleARKitHitTestResultType_MAX:'EAppleARKitHitTestResultType_MAX',:'', };
declare class AppleARKitAnchor extends UObject { 
	Identifier: Guid;
	static Load(ResourceName: string): AppleARKitAnchor;
	static Find(Outer: UObject, ResourceName: string): AppleARKitAnchor;
	static GetDefaultObject(): AppleARKitAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AppleARKitAnchor;
	GetTransform(): Transform;
	static C(Other: UObject | any): AppleARKitAnchor;
}

declare class AppleARKitHitTestResult { 
	Type: Type;
	Distance: number;
	Transform: Transform;
	Anchor: AppleARKitAnchor;
	clone() : AppleARKitHitTestResult;
	static C(Other: UObject | any): AppleARKitHitTestResult;
}

declare type EARTrackingQuality = 'NotAvailable' | 'Limited' | 'Normal';
declare var EARTrackingQuality : { NotAvailable:'NotAvailable',Limited:'Limited',Normal:'Normal', };
declare class DebugFloatHistory { 
	Samples: number[];
	MaxSamples: number;
	MinValue: number;
	MaxValue: number;
	bAutoAdjustMinMax: boolean;
	clone() : DebugFloatHistory;
	static C(Other: UObject | any): DebugFloatHistory;
	static AddFloatHistorySample(Value: number,FloatHistory: DebugFloatHistory): DebugFloatHistory;
}

declare class TimerHandle { 
	Handle: any;
	clone() : TimerHandle;
	static C(Other: UObject | any): TimerHandle;
	K2_InvalidateTimerHandle(): {Handle: TimerHandle, $: TimerHandle};
	K2_IsValidTimerHandle(): boolean;
	static K2_InvalidateTimerHandle(Handle?: TimerHandle): {Handle: TimerHandle, $: TimerHandle};
	static K2_IsValidTimerHandle(Handle: TimerHandle): boolean;
	static K2_SetTimerDelegate(Delegate: UnrealEngineDelegate<() => void>,Time: number,bLooping: boolean): TimerHandle;
}

declare type EQuitPreference = 'Quit' | 'Background';
declare var EQuitPreference : { Quit:'Quit',Background:'Background', };
declare class TextureRenderTarget extends Texture { 
	TargetGamma: number;
	static Load(ResourceName: string): TextureRenderTarget;
	static Find(Outer: UObject, ResourceName: string): TextureRenderTarget;
	static GetDefaultObject(): TextureRenderTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTarget;
	static C(Other: UObject | any): TextureRenderTarget;
}

declare type ETextureRenderTargetFormat = 'RTF_R8' | 'RTF_RG8' | 'RTF_RGBA8' | 'RTF_R16f' | 'RTF_RG16f' | 'RTF_RGBA16f' | 'RTF_R32f' | 'RTF_RG32f' | 'RTF_RGBA32f';
declare var ETextureRenderTargetFormat : { RTF_R8:'RTF_R8',RTF_RG8:'RTF_RG8',RTF_RGBA8:'RTF_RGBA8',RTF_R16f:'RTF_R16f',RTF_RG16f:'RTF_RG16f',RTF_RGBA16f:'RTF_RGBA16f',RTF_R32f:'RTF_R32f',RTF_RG32f:'RTF_RG32f',RTF_RGBA32f:'RTF_RGBA32f', };
declare type EPixelFormat = 'PF_Unknown' | 'PF_A32B32G32R32F' | 'PF_B8G8R8A8' | 'PF_G8' | 'PF_G16' | 'PF_DXT1' | 'PF_DXT3' | 'PF_DXT5' | 'PF_UYVY' | 'PF_FloatRGB' | 'PF_FloatRGBA' | 'PF_DepthStencil' | 'PF_ShadowDepth' | 'PF_R32_FLOAT' | 'PF_G16R16' | 'PF_G16R16F' | 'PF_G16R16F_FILTER' | 'PF_G32R32F' | 'PF_A2B10G10R10' | 'PF_A16B16G16R16' | 'PF_D24' | 'PF_R16F' | 'PF_R16F_FILTER' | 'PF_BC5' | 'PF_V8U8' | 'PF_A1' | 'PF_FloatR11G11B10' | 'PF_A8' | 'PF_R32_UINT' | 'PF_R32_SINT' | 'PF_PVRTC2' | 'PF_PVRTC4' | 'PF_R16_UINT' | 'PF_R16_SINT' | 'PF_R16G16B16A16_UINT' | 'PF_R16G16B16A16_SINT' | 'PF_R5G6B5_UNORM' | 'PF_R8G8B8A8' | 'PF_A8R8G8B8' | 'PF_BC4' | 'PF_R8G8' | 'PF_ATC_RGB' | 'PF_ATC_RGBA_E' | 'PF_ATC_RGBA_I' | 'PF_X24_G8' | 'PF_ETC1' | 'PF_ETC2_RGB' | 'PF_ETC2_RGBA' | 'PF_R32G32B32A32_UINT' | 'PF_R16G16_UINT' | 'PF_ASTC_4x4' | 'PF_ASTC_6x6' | 'PF_ASTC_8x8' | 'PF_ASTC_10x10' | 'PF_ASTC_12x12' | 'PF_BC6H' | 'PF_BC7' | 'PF_R8_UINT' | 'PF_L8' | 'PF_XGXR8' | 'PF_R8G8B8A8_UINT' | 'PF_R8G8B8A8_SNORM';
declare var EPixelFormat : { PF_Unknown:'PF_Unknown',PF_A32B32G32R32F:'PF_A32B32G32R32F',PF_B8G8R8A8:'PF_B8G8R8A8',PF_G8:'PF_G8',PF_G16:'PF_G16',PF_DXT1:'PF_DXT1',PF_DXT3:'PF_DXT3',PF_DXT5:'PF_DXT5',PF_UYVY:'PF_UYVY',PF_FloatRGB:'PF_FloatRGB',PF_FloatRGBA:'PF_FloatRGBA',PF_DepthStencil:'PF_DepthStencil',PF_ShadowDepth:'PF_ShadowDepth',PF_R32_FLOAT:'PF_R32_FLOAT',PF_G16R16:'PF_G16R16',PF_G16R16F:'PF_G16R16F',PF_G16R16F_FILTER:'PF_G16R16F_FILTER',PF_G32R32F:'PF_G32R32F',PF_A2B10G10R10:'PF_A2B10G10R10',PF_A16B16G16R16:'PF_A16B16G16R16',PF_D24:'PF_D24',PF_R16F:'PF_R16F',PF_R16F_FILTER:'PF_R16F_FILTER',PF_BC5:'PF_BC5',PF_V8U8:'PF_V8U8',PF_A1:'PF_A1',PF_FloatR11G11B10:'PF_FloatR11G11B10',PF_A8:'PF_A8',PF_R32_UINT:'PF_R32_UINT',PF_R32_SINT:'PF_R32_SINT',PF_PVRTC2:'PF_PVRTC2',PF_PVRTC4:'PF_PVRTC4',PF_R16_UINT:'PF_R16_UINT',PF_R16_SINT:'PF_R16_SINT',PF_R16G16B16A16_UINT:'PF_R16G16B16A16_UINT',PF_R16G16B16A16_SINT:'PF_R16G16B16A16_SINT',PF_R5G6B5_UNORM:'PF_R5G6B5_UNORM',PF_R8G8B8A8:'PF_R8G8B8A8',PF_A8R8G8B8:'PF_A8R8G8B8',PF_BC4:'PF_BC4',PF_R8G8:'PF_R8G8',PF_ATC_RGB:'PF_ATC_RGB',PF_ATC_RGBA_E:'PF_ATC_RGBA_E',PF_ATC_RGBA_I:'PF_ATC_RGBA_I',PF_X24_G8:'PF_X24_G8',PF_ETC1:'PF_ETC1',PF_ETC2_RGB:'PF_ETC2_RGB',PF_ETC2_RGBA:'PF_ETC2_RGBA',PF_R32G32B32A32_UINT:'PF_R32G32B32A32_UINT',PF_R16G16_UINT:'PF_R16G16_UINT',PF_ASTC_4x4:'PF_ASTC_4x4',PF_ASTC_6x6:'PF_ASTC_6x6',PF_ASTC_8x8:'PF_ASTC_8x8',PF_ASTC_10x10:'PF_ASTC_10x10',PF_ASTC_12x12:'PF_ASTC_12x12',PF_BC6H:'PF_BC6H',PF_BC7:'PF_BC7',PF_R8_UINT:'PF_R8_UINT',PF_L8:'PF_L8',PF_XGXR8:'PF_XGXR8',PF_R8G8B8A8_UINT:'PF_R8G8B8A8_UINT',PF_R8G8B8A8_SNORM:'PF_R8G8B8A8_SNORM', };
declare class TextureRenderTarget2D extends TextureRenderTarget { 
	SizeX: number;
	SizeY: number;
	ClearColor: LinearColor;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	bForceLinearGamma: boolean;
	bHDR: boolean;
	RenderTargetFormat: ETextureRenderTargetFormat;
	bGPUSharedFlag: boolean;
	bAutoGenerateMips: boolean;
	OverrideFormat: EPixelFormat;
	static Load(ResourceName: string): TextureRenderTarget2D;
	static Find(Outer: UObject, ResourceName: string): TextureRenderTarget2D;
	static GetDefaultObject(): TextureRenderTarget2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTarget2D;
	static C(Other: UObject | any): TextureRenderTarget2D;
	ReleaseRenderTarget2D(): void;
	RenderTargetCreateStaticTexture2DEditorOnly(Name: string,CompressionSettings: TextureCompressionSettings,MipSettings: TextureMipGenSettings): Texture2D;
	static ReleaseRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D): void;
	static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Name: string,CompressionSettings: TextureCompressionSettings,MipSettings: TextureMipGenSettings): Texture2D;
}

declare class DrawToRenderTargetContext { 
	RenderTarget: TextureRenderTarget2D;
	clone() : DrawToRenderTargetContext;
	static C(Other: UObject | any): DrawToRenderTargetContext;
}

declare class PredictProjectilePathParams { 
	StartLocation: Vector;
	LaunchVelocity: Vector;
	bTraceWithCollision: boolean;
	ProjectileRadius: number;
	MaxSimTime: number;
	bTraceWithChannel: boolean;
	TraceChannel: ECollisionChannel;
	ObjectTypes: EObjectTypeQuery[];
	ActorsToIgnore: Actor[];
	SimFrequency: number;
	OverrideGravityZ: number;
	DrawDebugType: EDrawDebugTrace;
	DrawDebugTime: number;
	bTraceComplex: boolean;
	clone() : PredictProjectilePathParams;
	static C(Other: UObject | any): PredictProjectilePathParams;
}

declare class PredictProjectilePathPointData { 
	Location: Vector;
	Velocity: Vector;
	Time: number;
	clone() : PredictProjectilePathPointData;
	static C(Other: UObject | any): PredictProjectilePathPointData;
}

declare class PredictProjectilePathResult { 
	PathData: PredictProjectilePathPointData[];
	LastTraceDestination: PredictProjectilePathPointData;
	HitResult: HitResult;
	clone() : PredictProjectilePathResult;
	static C(Other: UObject | any): PredictProjectilePathResult;
}

declare type ESuggestProjVelocityTraceOption = 'DoNotTrace' | 'TraceFullPath' | 'OnlyTraceWhileAscending';
declare var ESuggestProjVelocityTraceOption : { DoNotTrace:'DoNotTrace',TraceFullPath:'TraceFullPath',OnlyTraceWhileAscending:'OnlyTraceWhileAscending', };
declare type EGrammaticalGender = 'Neuter' | 'Masculine' | 'Feminine' | 'Mixed';
declare var EGrammaticalGender : { Neuter:'Neuter',Masculine:'Masculine',Feminine:'Feminine',Mixed:'Mixed', };
declare type EGrammaticalNumber = 'Singular' | 'Plural';
declare var EGrammaticalNumber : { Singular:'Singular',Plural:'Plural', };
declare class DialogueVoice extends UObject { 
	Gender: EGrammaticalGender;
	Plurality: EGrammaticalNumber;
	LocalizationGUID: Guid;
	static Load(ResourceName: string): DialogueVoice;
	static Find(Outer: UObject, ResourceName: string): DialogueVoice;
	static GetDefaultObject(): DialogueVoice;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueVoice;
	static C(Other: UObject | any): DialogueVoice;
}

declare class DialogueContext { 
	Speaker: DialogueVoice;
	Targets: DialogueVoice[];
	clone() : DialogueContext;
	static C(Other: UObject | any): DialogueContext;
}

declare class DialogueSoundWaveProxy extends SoundBase { 
	static Load(ResourceName: string): DialogueSoundWaveProxy;
	static Find(Outer: UObject, ResourceName: string): DialogueSoundWaveProxy;
	static GetDefaultObject(): DialogueSoundWaveProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueSoundWaveProxy;
	static C(Other: UObject | any): DialogueSoundWaveProxy;
}

declare class DialogueContextMapping { 
	Context: DialogueContext;
	SoundWave: SoundWave;
	LocalizationKeyFormat: string;
	Proxy: DialogueSoundWaveProxy;
	clone() : DialogueContextMapping;
	static C(Other: UObject | any): DialogueContextMapping;
}

declare class DialogueWave extends UObject { 
	bMature: boolean;
	bOverride_SubtitleOverride: boolean;
	SpokenText: string;
	SubtitleOverride: string;
	VoiceActorDirection: string;
	ContextMappings: DialogueContextMapping[];
	LocalizationGUID: Guid;
	static Load(ResourceName: string): DialogueWave;
	static Find(Outer: UObject, ResourceName: string): DialogueWave;
	static GetDefaultObject(): DialogueWave;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueWave;
	static C(Other: UObject | any): DialogueWave;
	SpawnDialogueAttached(Context: DialogueContext,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	static SpawnDialogueAttached(Dialogue: DialogueWave,Context: DialogueContext,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
}

declare class AIAsyncTaskBlueprintProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(MovementResult: EPathFollowingResult) => void>;
	OnFail: UnrealEngineMulticastDelegate<(MovementResult: EPathFollowingResult) => void>;
	static Load(ResourceName: string): AIAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): AIAsyncTaskBlueprintProxy;
	static GetDefaultObject(): AIAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIAsyncTaskBlueprintProxy;
	OnMoveCompleted(RequestID: AIRequestID,MovementResult: EPathFollowingResult): void;
	static C(Other: UObject | any): AIAsyncTaskBlueprintProxy;
}

declare class World extends UObject { 
	Layers: Layer[];
	ActiveGroupActors: Actor[];
	ThumbnailInfo: ThumbnailInfo;
	PersistentLevel: Level;
	NetDriver: NetDriver;
	LineBatcher: LineBatchComponent;
	PersistentLineBatcher: LineBatchComponent;
	ForegroundLineBatcher: LineBatchComponent;
	NetworkManager: GameNetworkManager;
	PhysicsCollisionHandler: PhysicsCollisionHandler;
	ExtraReferencedObjects: UObject[];
	PerModuleDataObjects: UObject[];
	StreamingLevels: LevelStreaming[];
	StreamingLevelsPrefix: string;
	CurrentLevelPendingVisibility: Level;
	CurrentLevelPendingInvisibility: Level;
	DemoNetDriver: DemoNetDriver;
	MyParticleEventManager: ParticleEventManager;
	DefaultPhysicsVolume: PhysicsVolume;
	NavigationSystem: NavigationSystem;
	AuthorityGameMode: GameModeBase;
	GameState: GameStateBase;
	AISystem: AISystemBase;
	AvoidanceManager: AvoidanceManager;
	Levels: Level[];
	LevelCollections: LevelCollection[];
	CurrentLevel: Level;
	OwningGameInstance: GameInstance;
	ParameterCollectionInstances: MaterialParameterCollectionInstance[];
	CanvasForRenderingToTarget: Canvas;
	CanvasForDrawMaterialToRenderTarget: Canvas;
	EditorViews: LevelViewportInfo[];
	SelectedLevels: Level[];
	WorldComposition: WorldComposition;
	bAreConstraintsDirty: boolean;
	static Load(ResourceName: string): World;
	static Find(Outer: UObject, ResourceName: string): World;
	static GetDefaultObject(): World;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): World;
	static C(Other: UObject | any): World;
	EditorDestroyActor(Actor: Actor,bShouldModifyLevel: boolean): boolean;
	ExportNavigation(Path: string): string;
	GetDefaultBrush(): Brush;
	InvalidateModelGeometry(InLevel: Level): void;
	RemoveLevelInstance(): void;
	BeginPlay(): void;
	DestroyWorld(): void;
	InitializeActorsForPlay(URL: URL): void;
	GenerateNavigation(NavData: RecastNavMesh): void;
	GetAllActorsOfClassAndTags(ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	GetLevels(): Level[];
	GetModel(): Model;
	IsGameWorld(): boolean;
	IsPlayInEditor(): boolean;
	IsPlayInPreview(): boolean;
	TraceChannelTestUtil(BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	RunAllFunctionalTests(bNewLog: boolean,bRunLooped: boolean,bWaitForNavigationBuildFinish: boolean,FailedTestsReproString: string): boolean;
	DisableStatGroup(GroupName: string): void;
	EnableStatGroup(GroupName: string): void;
	TakeAutomationScreenshot(LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	TakeAutomationScreenshotAtCamera(LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Options: AutomationScreenshotOptions): void;
	TakeAutomationScreenshotOfUI(LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	GetCurrentFrame(OutCurrentFrame?: AppleARKitFrame): {OutCurrentFrame: AppleARKitFrame, $: boolean};
	HitTestAtScreenPosition_TrackingSpace(ScreenPosition: Vector2D,Types: Types,OutResults?: AppleARKitHitTestResult[]): {OutResults: AppleARKitHitTestResult[], $: boolean};
	GetTrackingQuality(): ReturnValue;
	GetIsMyTurn(PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	GetMyPlayerIndex(PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	GetPlayerDisplayName(PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	RegisterTurnBasedMatchInterfaceObject(PlayerController: PlayerController,UObject: UObject): void;
	GetCachedAchievementDescription(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	GetCachedAchievementProgress(PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	LogBox(BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string): void;
	LogLocation(Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string): void;
	LogText(Text: string,LogCategory: string): void;
	FindPathToActorSynchronously(PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	FindPathToLocationSynchronously(PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	GetNavigationSystem(): NavigationSystem;
	GetPathCost(PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	GetPathLength(PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	GetRandomPointInNavigableRadius(Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	GetRandomReachablePointInRadius(Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	IsNavigationBeingBuilt(): boolean;
	IsNavigationBeingBuiltOrLocked(): boolean;
	K2_GetRandomPointInNavigableRadius(Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	K2_GetRandomReachablePointInRadius(Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	K2_ProjectPointToNavigation(Point: Vector,ProjectedLocation?: Vector,NavData?: NavigationData,FilterClass?: UnrealEngineClass,QueryExtent?: Vector): {ProjectedLocation: Vector, $: boolean};
	NavigationRaycast(RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	ProjectPointToNavigation(Point: Vector,NavData: NavigationData,FilterClass: UnrealEngineClass,QueryExtent: Vector): Vector;
	BoxOverlapActors(BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	BoxOverlapComponents(BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	BoxTraceMulti(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceMultiByProfile(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceMultiForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	BoxTraceSingle(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BoxTraceSingleByProfile(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BoxTraceSingleForObjects(Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleOverlapActors(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	CapsuleOverlapComponents(CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	CapsuleTraceMulti(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceMultiByProfile(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceMultiForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	CapsuleTraceSingle(Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleTraceSingleByProfile(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	CapsuleTraceSingleForObjects(Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	Delay(Duration: number,LatentInfo: LatentActionInfo): void;
	DrawDebugArrow(LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugBox(Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	DrawDebugCapsule(Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugCircle(Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	DrawDebugCone(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugConeInDegrees(Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugCoordinateSystem(AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	DrawDebugCylinder(Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugFloatHistoryLocation(FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFloatHistoryTransform(FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	DrawDebugFrustum(FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugLine(LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugPlane(PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	DrawDebugPoint(Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	DrawDebugSphere(Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	DrawDebugString(TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	ExecuteConsoleCommand(Command: string,SpecificPlayer: PlayerController): void;
	FlushDebugStrings(): void;
	FlushPersistentDebugLines(): void;
	GetGameTimeInSeconds(): number;
	IsDedicatedServer(): boolean;
	IsServer(): boolean;
	IsStandalone(): boolean;
	K2_ClearAndInvalidateTimerHandle(Handle?: TimerHandle): {Handle: TimerHandle};
	K2_ClearTimerHandle(Handle: TimerHandle): void;
	K2_GetTimerElapsedTimeHandle(Handle: TimerHandle): number;
	K2_GetTimerRemainingTimeHandle(Handle: TimerHandle): number;
	K2_IsTimerActiveHandle(Handle: TimerHandle): boolean;
	K2_IsTimerPausedHandle(Handle: TimerHandle): boolean;
	K2_PauseTimerHandle(Handle: TimerHandle): void;
	K2_TimerExistsHandle(Handle: TimerHandle): boolean;
	K2_UnPauseTimerHandle(Handle: TimerHandle): void;
	LineTraceMulti(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceMultiByProfile(Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceMultiForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	LineTraceSingle(Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LineTraceSingleByProfile(Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LineTraceSingleForObjects(Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	LoadAsset(Asset: any,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	LoadAssetClass(AssetClass: any,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	PrintString(InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number): void;
	PrintText(InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number): void;
	QuitGame(SpecificPlayer: PlayerController,QuitPreference: EQuitPreference): void;
	RetriggerableDelay(Duration: number,LatentInfo: LatentActionInfo): void;
	SetSuppressViewportTransitionMessage(bState: boolean): void;
	SphereOverlapActors(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	SphereOverlapComponents(SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SphereTraceMulti(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceMultiByProfile(Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceMultiForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	SphereTraceSingle(Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	SphereTraceSingleByProfile(Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	SphereTraceSingleForObjects(Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	BeginDrawCanvasToRenderTarget(TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	ClearRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	ConvertRenderTargetToTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	CreateRenderTarget2D(Width: number,Height: number,Format: ETextureRenderTargetFormat): TextureRenderTarget2D;
	DrawMaterialToRenderTarget(TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	EndDrawCanvasToRenderTarget(Context: DrawToRenderTargetContext): void;
	ExportRenderTarget(TextureRenderTarget: TextureRenderTarget2D,FilePath: string,FileName: string): void;
	ExportTexture2D(Texture: Texture2D,FilePath: string,FileName: string): void;
	MinimumAreaRectangle(InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	CreateDynamicMaterialInstance(Parent: MaterialInterface): MaterialInstanceDynamic;
	GetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string): number;
	GetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	SetScalarParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	SetVectorParameterValue(Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	ActivateReverbEffect(ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	ApplyRadialDamage(BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	ApplyRadialDamageWithFalloff(BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	AreAnyListenersWithinRange(Location: Vector,MaximumRange: number): boolean;
	BeginDeferredActorSpawnFromClass(ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: CollisionHandlingOverride,Owner: Actor): Actor;
	BeginSpawningActorFromBlueprint(Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	BeginSpawningActorFromClass(ActorClass: UnrealEngineClass,SpawnTransform: Transform,bNoCollisionFail: boolean,Owner: Actor): Actor;
	Blueprint_PredictProjectilePath_Advanced(PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	Blueprint_PredictProjectilePath_ByObjectType(OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	Blueprint_PredictProjectilePath_ByTraceChannel(OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	BlueprintSuggestProjectileVelocity(TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	ClearSoundMixClassOverride(InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	ClearSoundMixModifiers(): void;
	CreatePlayer(ControllerId: number,bSpawnPawn: boolean): PlayerController;
	CreateSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	DeactivateReverbEffect(TagName: string): void;
	FlushLevelStreaming(): void;
	GetAccurateRealTime(Seconds?: number,PartialSeconds?: number): {Seconds: number, PartialSeconds: number};
	GetAllActorsOfClass(ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithInterface(Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAllActorsWithTag(Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	GetAudioTimeSeconds(): number;
	GetCurrentLevelName(bRemovePrefixString: boolean): string;
	GetCurrentReverbEffect(): ReverbEffect;
	GetGameInstance(): GameInstance;
	GetGameMode(): GameModeBase;
	GetGameState(): GameStateBase;
	GetGlobalTimeDilation(): number;
	GetPlayerCameraManager(PlayerIndex: number): PlayerCameraManager;
	GetPlayerCharacter(PlayerIndex: number): Character;
	GetPlayerController(PlayerIndex: number): PlayerController;
	GetPlayerPawn(PlayerIndex: number): Pawn;
	GetRealTimeSeconds(): number;
	GetStreamingLevel(PackageName: string): LevelStreaming;
	GetTimeSeconds(): number;
	GetUnpausedTimeSeconds(): number;
	GetWorldDeltaSeconds(): number;
	GetWorldOriginLocation(): IntVector;
	GrassOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	IsGamePaused(): boolean;
	LoadStreamLevel(LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	OpenLevel(LevelName: string,bAbsolute: boolean,Options: string): void;
	PlayDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	PlayDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	PlaySound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor): void;
	PlaySoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor): void;
	PlayWorldCameraShake(Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	PopSoundMixModifier(InSoundMixModifier: SoundMix): void;
	PushSoundMixModifier(InSoundMixModifier: SoundMix): void;
	RebaseLocalOriginOntoZero(WorldLocation: Vector): Vector;
	RebaseZeroOriginOntoLocal(WorldLocation: Vector): Vector;
	SetBaseSoundMix(InSoundMix: SoundMix): void;
	SetGamePaused(bPaused: boolean): boolean;
	SetGlobalListenerFocusParameters(FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	SetGlobalPitchModulation(PitchModulation: number,TimeSec: number): void;
	SetGlobalTimeDilation(TimeDilation: number): void;
	SetSoundMixClassOverride(InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	SetWorldOriginLocation(NewLocation: IntVector): void;
	SpawnDecalAtLocation(DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	SpawnDialogue2D(Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	SpawnDialogueAtLocation(Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	SpawnEmitterAtLocation(EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean): ParticleSystemComponent;
	SpawnForceFeedbackAtLocation(ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	SpawnSound2D(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	SpawnSoundAtLocation(Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	SuggestProjectileVelocity_CustomArc(OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	UnloadStreamLevel(LevelName: string,LatentInfo: LatentActionInfo): void;
	FoliageOverlappingBoxCount(StaticMesh: StaticMesh,Box: Box): number;
	FoliageOverlappingSphereCount(StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	GetMousePositionOnViewport(): Vector2D;
	GetViewportScale(): number;
	GetViewportSize(): Vector2D;
	GetViewportWidgetGeometry(): Geometry;
	RemoveAllWidgets(): void;
	Create(WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	GetAllWidgetsOfClass(FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetAllWidgetsWithInterface(Interface: UnrealEngineClass,FoundWidgets?: UserWidget[],TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	GetSafeZonePadding(SafePadding?: Vector2D,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector2D): {SafePadding: Vector2D, SafePaddingScale: Vector2D, SpillOverPadding: Vector2D};
	SetHardwareCursor(CursorShape: EMouseCursor,CursorName: string,HotSpot: Vector2D): boolean;
	AbsoluteToViewport(AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	LocalToViewport(Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	ScreenToViewport(ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	ScreenToWidgetAbsolute(ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D): {AbsoluteCoordinate: Vector2D};
	ScreenToWidgetLocal(Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D): {LocalCoordinate: Vector2D};
	AddMasterSubmixEffect(SubmixEffectPreset: SoundEffectSubmixPreset): void;
	AddSourceEffectToPresetChain(PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	ClearMasterSubmixEffects(): void;
	GetNumberOfEntriesInSourceEffectChain(PresetChain: SoundEffectSourcePresetChain): number;
	RemoveMasterSubmixEffect(SubmixEffectPreset: SoundEffectSubmixPreset): void;
	RemoveSourceEffectFromPresetChain(PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	SetBypassSourceEffectChainEntry(PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	CreateMoveToProxyObject(Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	SpawnAIFromClass(PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean): Pawn;
	GetAllActorsOfClassMatchingTagQuery(ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	GetWorldToMetersScale(): number;
	SetWorldToMetersScale(NewScale: number): void;
	static EditorDestroyActor(World: World,Actor: Actor,bShouldModifyLevel: boolean): boolean;
	static ExportNavigation(InWorld: World,Path: string): string;
	static GetDefaultBrush(World: World): Brush;
	static InvalidateModelGeometry(World: World,InLevel: Level): void;
	static RemoveLevelInstance(World: World): void;
	static BeginPlay(World: World): void;
	static DestroyWorld(World: World): void;
	static InitializeActorsForPlay(World: World,URL: URL): void;
	static GenerateNavigation(world: World,NavData: RecastNavMesh): void;
	static GetAllActorsOfClassAndTags(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	static GetLevels(World: World): Level[];
	static GetModel(World: World): Model;
	static IsGameWorld(World: World): boolean;
	static IsPlayInEditor(World: World): boolean;
	static IsPlayInPreview(World: World): boolean;
	static TraceChannelTestUtil(WorldContextObject: UObject,BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	static RunAllFunctionalTests(WorldContextObject: UObject,bNewLog: boolean,bRunLooped: boolean,bWaitForNavigationBuildFinish: boolean,FailedTestsReproString: string): boolean;
	static DisableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static EnableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static TakeAutomationScreenshot(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotAtCamera(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotOfUI(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	static GetCurrentFrame(WorldContextObject: UObject,OutCurrentFrame?: AppleARKitFrame): {OutCurrentFrame: AppleARKitFrame, $: boolean};
	static HitTestAtScreenPosition_TrackingSpace(WorldContextObject: UObject,ScreenPosition: Vector2D,Types: Types,OutResults?: AppleARKitHitTestResult[]): {OutResults: AppleARKitHitTestResult[], $: boolean};
	static GetTrackingQuality(WorldContextObject: UObject): ReturnValue;
	static GetIsMyTurn(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	static GetMyPlayerIndex(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	static GetPlayerDisplayName(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: UObject,PlayerController: PlayerController,UObject: UObject): void;
	static GetCachedAchievementDescription(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	static GetCachedAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	static LogBox(WorldContextObject: UObject,BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string): void;
	static LogLocation(WorldContextObject: UObject,Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string): void;
	static LogText(WorldContextObject: UObject,Text: string,LogCategory: string): void;
	static FindPathToActorSynchronously(WorldContextObject: UObject,PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static FindPathToLocationSynchronously(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static GetNavigationSystem(WorldContextObject: UObject): NavigationSystem;
	static GetPathCost(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	static GetPathLength(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	static GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static IsNavigationBeingBuilt(WorldContextObject: UObject): boolean;
	static IsNavigationBeingBuiltOrLocked(WorldContextObject: UObject): boolean;
	static K2_GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,ProjectedLocation?: Vector,NavData?: NavigationData,FilterClass?: UnrealEngineClass,QueryExtent?: Vector): {ProjectedLocation: Vector, $: boolean};
	static NavigationRaycast(WorldContextObject: UObject,RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	static ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,NavData: NavigationData,FilterClass: UnrealEngineClass,QueryExtent: Vector): Vector;
	static BoxOverlapActors(WorldContextObject: UObject,BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static BoxOverlapComponents(WorldContextObject: UObject,BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static BoxTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleOverlapActors(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CapsuleOverlapComponents(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static CapsuleTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static Delay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static DrawDebugArrow(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugBox(WorldContextObject: UObject,Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	static DrawDebugCapsule(WorldContextObject: UObject,Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCircle(WorldContextObject: UObject,Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	static DrawDebugCone(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugConeInDegrees(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCoordinateSystem(WorldContextObject: UObject,AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	static DrawDebugCylinder(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFloatHistoryLocation(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFloatHistoryTransform(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFrustum(WorldContextObject: UObject,FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugLine(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugPlane(WorldContextObject: UObject,PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	static DrawDebugPoint(WorldContextObject: UObject,Position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	static DrawDebugSphere(WorldContextObject: UObject,Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugString(WorldContextObject: UObject,TextLocation: Vector,Text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	static ExecuteConsoleCommand(WorldContextObject: UObject,Command: string,SpecificPlayer: PlayerController): void;
	static FlushDebugStrings(WorldContextObject: UObject): void;
	static FlushPersistentDebugLines(WorldContextObject: UObject): void;
	static GetGameTimeInSeconds(WorldContextObject: UObject): number;
	static IsDedicatedServer(WorldContextObject: UObject): boolean;
	static IsServer(WorldContextObject: UObject): boolean;
	static IsStandalone(WorldContextObject: UObject): boolean;
	static K2_ClearAndInvalidateTimerHandle(WorldContextObject: UObject,Handle?: TimerHandle): {Handle: TimerHandle};
	static K2_ClearTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_GetTimerElapsedTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerRemainingTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_IsTimerActiveHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerPausedHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_PauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_TimerExistsHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_UnPauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static LineTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LoadAsset(WorldContextObject: UObject,Asset: any,OnLoaded: UnrealEngineDelegate<(Loaded: UObject) => void>,LatentInfo: LatentActionInfo): void;
	static LoadAssetClass(WorldContextObject: UObject,AssetClass: any,OnLoaded: UnrealEngineDelegate<(Loaded: UnrealEngineClass) => void>,LatentInfo: LatentActionInfo): void;
	static PrintString(WorldContextObject: UObject,InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number): void;
	static PrintText(WorldContextObject: UObject,InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number): void;
	static QuitGame(WorldContextObject: UObject,SpecificPlayer: PlayerController,QuitPreference: EQuitPreference): void;
	static RetriggerableDelay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static SetSuppressViewportTransitionMessage(WorldContextObject: UObject,bState: boolean): void;
	static SphereOverlapActors(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static SphereOverlapComponents(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SphereTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BeginDrawCanvasToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	static ClearRenderTarget2D(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: UObject,RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	static CreateRenderTarget2D(WorldContextObject: UObject,Width: number,Height: number,Format: ETextureRenderTargetFormat): TextureRenderTarget2D;
	static DrawMaterialToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	static EndDrawCanvasToRenderTarget(WorldContextObject: UObject,Context: DrawToRenderTargetContext): void;
	static ExportRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,FilePath: string,FileName: string): void;
	static ExportTexture2D(WorldContextObject: UObject,Texture: Texture2D,FilePath: string,FileName: string): void;
	static MinimumAreaRectangle(WorldContextObject: UObject,InVerts: Vector[],SampleSurfaceNormal: Vector,OutRectCenter?: Vector,OutRectRotation?: Rotator,OutSideLengthX?: number,OutSideLengthY?: number,bDebugDraw?: boolean): {OutRectCenter: Vector, OutRectRotation: Rotator, OutSideLengthX: number, OutSideLengthY: number};
	static CreateDynamicMaterialInstance(WorldContextObject: UObject,Parent: MaterialInterface): MaterialInstanceDynamic;
	static GetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): number;
	static GetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string): LinearColor;
	static SetScalarParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: number): void;
	static SetVectorParameterValue(WorldContextObject: UObject,Collection: MaterialParameterCollection,ParameterName: string,ParameterValue: LinearColor): void;
	static ActivateReverbEffect(WorldContextObject: UObject,ReverbEffect: ReverbEffect,TagName: string,Priority: number,Volume: number,FadeTime: number): void;
	static ApplyRadialDamage(WorldContextObject: UObject,BaseDamage: number,Origin: Vector,DamageRadius: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,bDoFullDamage: boolean,DamagePreventionChannel: ECollisionChannel): boolean;
	static ApplyRadialDamageWithFalloff(WorldContextObject: UObject,BaseDamage: number,MinimumDamage: number,Origin: Vector,DamageInnerRadius: number,DamageOuterRadius: number,DamageFalloff: number,DamageTypeClass: UnrealEngineClass,IgnoreActors: Actor[],DamageCauser: Actor,InstigatedByController: Controller,DamagePreventionChannel: ECollisionChannel): boolean;
	static AreAnyListenersWithinRange(WorldContextObject: UObject,Location: Vector,MaximumRange: number): boolean;
	static BeginDeferredActorSpawnFromClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,SpawnTransform: Transform,CollisionHandlingOverride: CollisionHandlingOverride,Owner: Actor): Actor;
	static BeginSpawningActorFromBlueprint(WorldContextObject: UObject,Blueprint: Blueprint,SpawnTransform: Transform,bNoCollisionFail: boolean): Actor;
	static BeginSpawningActorFromClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,SpawnTransform: Transform,bNoCollisionFail: boolean,Owner: Actor): Actor;
	static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: UObject,PredictParams: PredictProjectilePathParams,PredictResult?: PredictProjectilePathResult): {PredictResult: PredictProjectilePathResult, $: boolean};
	static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,ObjectTypes?: EObjectTypeQuery[],bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: UObject,OutHit?: HitResult,OutPathPositions?: Vector[],OutLastTraceDestination?: Vector,StartPos?: Vector,LaunchVelocity?: Vector,bTracePath?: boolean,ProjectileRadius?: number,TraceChannel?: ECollisionChannel,bTraceComplex?: boolean,ActorsToIgnore?: Actor[],DrawDebugType?: EDrawDebugTrace,DrawDebugTime?: number,SimFrequency?: number,MaxSimTime?: number,OverrideGravityZ?: number): {OutHit: HitResult, OutPathPositions: Vector[], OutLastTraceDestination: Vector, $: boolean};
	static BlueprintSuggestProjectileVelocity(WorldContextObject: UObject,TossVelocity?: Vector,StartLocation?: Vector,EndLocation?: Vector,LaunchSpeed?: number,OverrideGravityZ?: number,TraceOption?: ESuggestProjVelocityTraceOption,CollisionRadius?: number,bFavorHighArc?: boolean,bDrawDebug?: boolean): {TossVelocity: Vector, $: boolean};
	static ClearSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,FadeOutTime: number): void;
	static ClearSoundMixModifiers(WorldContextObject: UObject): void;
	static CreatePlayer(WorldContextObject: UObject,ControllerId: number,bSpawnPawn: boolean): PlayerController;
	static CreateSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static DeactivateReverbEffect(WorldContextObject: UObject,TagName: string): void;
	static FlushLevelStreaming(WorldContextObject: UObject): void;
	static GetAccurateRealTime(WorldContextObject: UObject,Seconds?: number,PartialSeconds?: number): {Seconds: number, PartialSeconds: number};
	static GetAllActorsOfClass(WorldContextObject: UObject,ActorClass: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithInterface(WorldContextObject: UObject,Interface: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAllActorsWithTag(WorldContextObject: UObject,Tag: string,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetAudioTimeSeconds(WorldContextObject: UObject): number;
	static GetCurrentLevelName(WorldContextObject: UObject,bRemovePrefixString: boolean): string;
	static GetCurrentReverbEffect(WorldContextObject: UObject): ReverbEffect;
	static GetGameInstance(WorldContextObject: UObject): GameInstance;
	static GetGameMode(WorldContextObject: UObject): GameModeBase;
	static GetGameState(WorldContextObject: UObject): GameStateBase;
	static GetGlobalTimeDilation(WorldContextObject: UObject): number;
	static GetPlayerCameraManager(WorldContextObject: UObject,PlayerIndex: number): PlayerCameraManager;
	static GetPlayerCharacter(WorldContextObject: UObject,PlayerIndex: number): Character;
	static GetPlayerController(WorldContextObject: UObject,PlayerIndex: number): PlayerController;
	static GetPlayerPawn(WorldContextObject: UObject,PlayerIndex: number): Pawn;
	static GetRealTimeSeconds(WorldContextObject: UObject): number;
	static GetStreamingLevel(WorldContextObject: UObject,PackageName: string): LevelStreaming;
	static GetTimeSeconds(WorldContextObject: UObject): number;
	static GetUnpausedTimeSeconds(WorldContextObject: UObject): number;
	static GetWorldDeltaSeconds(WorldContextObject: UObject): number;
	static GetWorldOriginLocation(WorldContextObject: UObject): IntVector;
	static GrassOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static IsGamePaused(WorldContextObject: UObject): boolean;
	static LoadStreamLevel(WorldContextObject: UObject,LevelName: string,bMakeVisibleAfterLoad: boolean,bShouldBlockOnLoad: boolean,LatentInfo: LatentActionInfo): void;
	static OpenLevel(WorldContextObject: UObject,LevelName: string,bAbsolute: boolean,Options: string): void;
	static PlayDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number): void;
	static PlayDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation): void;
	static PlaySound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,OwningActor: Actor): void;
	static PlaySoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,OwningActor: Actor): void;
	static PlayWorldCameraShake(WorldContextObject: UObject,Shake: UnrealEngineClass,Epicenter: Vector,InnerRadius: number,OuterRadius: number,Falloff: number,bOrientShakeTowardsEpicenter: boolean): void;
	static PopSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static PushSoundMixModifier(WorldContextObject: UObject,InSoundMixModifier: SoundMix): void;
	static RebaseLocalOriginOntoZero(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static RebaseZeroOriginOntoLocal(WorldContextObject: UObject,WorldLocation: Vector): Vector;
	static SetBaseSoundMix(WorldContextObject: UObject,InSoundMix: SoundMix): void;
	static SetGamePaused(WorldContextObject: UObject,bPaused: boolean): boolean;
	static SetGlobalListenerFocusParameters(WorldContextObject: UObject,FocusAzimuthScale: number,NonFocusAzimuthScale: number,FocusDistanceScale: number,NonFocusDistanceScale: number,FocusVolumeScale: number,NonFocusVolumeScale: number,FocusPriorityScale: number,NonFocusPriorityScale: number): void;
	static SetGlobalPitchModulation(WorldContextObject: UObject,PitchModulation: number,TimeSec: number): void;
	static SetGlobalTimeDilation(WorldContextObject: UObject,TimeDilation: number): void;
	static SetSoundMixClassOverride(WorldContextObject: UObject,InSoundMixModifier: SoundMix,InSoundClass: SoundClass,Volume: number,Pitch: number,FadeInTime: number,bApplyToChildren: boolean): void;
	static SetWorldOriginLocation(WorldContextObject: UObject,NewLocation: IntVector): void;
	static SpawnDecalAtLocation(WorldContextObject: UObject,DecalMaterial: MaterialInterface,DecalSize: Vector,Location: Vector,Rotation: Rotator,LifeSpan: number): DecalComponent;
	static SpawnDialogue2D(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,bAutoDestroy: boolean): AudioComponent;
	static SpawnDialogueAtLocation(WorldContextObject: UObject,Dialogue: DialogueWave,Context: DialogueContext,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,bAutoDestroy: boolean): AudioComponent;
	static SpawnEmitterAtLocation(WorldContextObject: UObject,EmitterTemplate: ParticleSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean): ParticleSystemComponent;
	static SpawnForceFeedbackAtLocation(WorldContextObject: UObject,ForceFeedbackEffect: ForceFeedbackEffect,Location: Vector,Rotation: Rotator,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnSound2D(WorldContextObject: UObject,Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,ConcurrencySettings: SoundConcurrency,bPersistAcrossLevelTransition: boolean,bAutoDestroy: boolean): AudioComponent;
	static SpawnSoundAtLocation(WorldContextObject: UObject,Sound: SoundBase,Location: Vector,Rotation: Rotator,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static SuggestProjectileVelocity_CustomArc(WorldContextObject: UObject,OutLaunchVelocity?: Vector,StartPos?: Vector,EndPos?: Vector,OverrideGravityZ?: number,ArcParam?: number): {OutLaunchVelocity: Vector, $: boolean};
	static UnloadStreamLevel(WorldContextObject: UObject,LevelName: string,LatentInfo: LatentActionInfo): void;
	static FoliageOverlappingBoxCount(WorldContextObject: UObject,StaticMesh: StaticMesh,Box: Box): number;
	static FoliageOverlappingSphereCount(WorldContextObject: UObject,StaticMesh: StaticMesh,CenterPosition: Vector,Radius: number): number;
	static GetMousePositionOnViewport(WorldContextObject: UObject): Vector2D;
	static GetViewportScale(WorldContextObject: UObject): number;
	static GetViewportSize(WorldContextObject: UObject): Vector2D;
	static GetViewportWidgetGeometry(WorldContextObject: UObject): Geometry;
	static RemoveAllWidgets(WorldContextObject: UObject): void;
	static Create(WorldContextObject: UObject,WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	static GetAllWidgetsOfClass(WorldContextObject: UObject,FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetAllWidgetsWithInterface(WorldContextObject: UObject,Interface: UnrealEngineClass,FoundWidgets?: UserWidget[],TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetSafeZonePadding(WorldContextObject: UObject,SafePadding?: Vector2D,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector2D): {SafePadding: Vector2D, SafePaddingScale: Vector2D, SpillOverPadding: Vector2D};
	static SetHardwareCursor(WorldContextObject: UObject,CursorShape: EMouseCursor,CursorName: string,HotSpot: Vector2D): boolean;
	static AbsoluteToViewport(WorldContextObject: UObject,AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static LocalToViewport(WorldContextObject: UObject,Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static ScreenToViewport(WorldContextObject: UObject,ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	static ScreenToWidgetAbsolute(WorldContextObject: UObject,ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D): {AbsoluteCoordinate: Vector2D};
	static ScreenToWidgetLocal(WorldContextObject: UObject,Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D): {LocalCoordinate: Vector2D};
	static AddMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static AddSourceEffectToPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	static ClearMasterSubmixEffects(WorldContextObject: UObject): void;
	static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain): number;
	static RemoveMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static RemoveSourceEffectFromPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	static SetBypassSourceEffectChainEntry(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean): Pawn;
	static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: UObject,ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
}

declare class Package extends UObject { 
	static Load(ResourceName: string): Package;
	static Find(Outer: UObject, ResourceName: string): Package;
	static GetDefaultObject(): Package;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Package;
	static C(Other: UObject | any): Package;
	DeletePackage(): boolean;
	FindWorldInPackage(): World;
	SavePackage(FileName: string): boolean;
	GetLongPackagePath(): string;
	HasAnyPackageFlags(Flags: number): boolean;
	LoadPackage(PackageName: string): Package;
	static DeletePackage(Package: Package): boolean;
	static FindWorldInPackage(Package: Package): World;
	static SavePackage(Package: Package,FileName: string): boolean;
	static GetLongPackagePath(InPackage: Package): string;
	static HasAnyPackageFlags(Package: Package,Flags: number): boolean;
	static LoadPackage(InOuter: Package,PackageName: string): Package;
}

declare class DirectoryItem { 
	Name: string;
	bIsDirectory: boolean;
	clone() : DirectoryItem;
	static C(Other: UObject | any): DirectoryItem;
}

declare class PrimaryAssetType { 
	Name: string;
	clone() : PrimaryAssetType;
	static C(Other: UObject | any): PrimaryAssetType;
	Conv_PrimaryAssetTypeToString(): string;
	EqualEqual_PrimaryAssetType(B: PrimaryAssetType): boolean;
	GetPrimaryAssetIdList(OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	IsValidPrimaryAssetType(): boolean;
	NotEqual_PrimaryAssetType(B: PrimaryAssetType): boolean;
	static Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType): string;
	static EqualEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
	static GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType,OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	static IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType): boolean;
	static NotEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
}

declare class PrimaryAssetId { 
	PrimaryAssetType: PrimaryAssetType;
	PrimaryAssetName: string;
	clone() : PrimaryAssetId;
	static C(Other: UObject | any): PrimaryAssetId;
	Conv_PrimaryAssetIdToString(): string;
	EqualEqual_PrimaryAssetId(B: PrimaryAssetId): boolean;
	GetClassFromPrimaryAssetId(): UnrealEngineClass;
	GetCurrentBundleState(bForceCurrentState: boolean,OutBundles?: string[]): {OutBundles: string[], $: boolean};
	GetObjectFromPrimaryAssetId(): UObject;
	GetSoftClassReferenceFromPrimaryAssetId(): any;
	GetSoftObjectReferenceFromPrimaryAssetId(): any;
	IsValidPrimaryAssetId(): boolean;
	NotEqual_PrimaryAssetId(B: PrimaryAssetId): boolean;
	UnloadPrimaryAsset(): void;
	static Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId): string;
	static EqualEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UnrealEngineClass;
	static GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId,bForceCurrentState: boolean,OutBundles?: string[]): {OutBundles: string[], $: boolean};
	static GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): any;
	static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): any;
	static IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): boolean;
	static NotEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): void;
}

declare class CollisionProfileName { 
	Name: string;
	clone() : CollisionProfileName;
	static C(Other: UObject | any): CollisionProfileName;
}

declare class GenericStruct { 
	Data: number;
	clone() : GenericStruct;
	static C(Other: UObject | any): GenericStruct;
}

declare class UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UObject;
	static Find(Outer: UObject, ResourceName: string): UObject;
	static StaticClass: any;
	static GetClassObject(): Class;
	static GetDefaultObject(): UObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UObject;
	ExecuteUbergraph(EntryPoint: number): void;
	static C(Other: UObject | any): UObject;
	AddWhitelistedObject(): void;
	BroadcastAssetCreated(): void;
	MarkPackageDirty(): boolean;
	ModifyObject(bAlwaysMarkDirty: boolean): void;
	PostEditChange(): void;
	CreateEnum(Name: string,DisplayNames: string[]): Enum;
	CreatePackage(PackageName: string): Package;
	Duplicate(Outer: UObject,Name: string): UObject;
	FindObjectWithOuter(ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	FindPackage(PackageName: string): Package;
	GetArchetypePathName(): string;
	GetDir(WhichDir: string): string;
	GetFields(bIncludeSuper: boolean): Field[];
	GetFileSize(Filename: string): number;
	GetName(): string;
	GetObjectsWithOuter(Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetOuter(): UObject;
	GetOutermost(): UObject;
	HasAnyFlags(Flags: number): boolean;
	ReadDirectory(Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	ReadFile(Filename: string): boolean;
	ReadStringFromFile(Filename: string): string;
	SetObjectFlags(Flags: number): void;
	WriteFile(Filename: string): boolean;
	WriteStringToFile(Filename: string,Data: string): boolean;
	Conv_ObjectToText(): string;
	Conv_ObjectToSoftObjectReference(): any;
	Conv_SoftObjectReferenceToObject(): UObject;
	Conv_SoftObjectReferenceToString(): string;
	CreateCopyForUndoBuffer(): void;
	DoesImplementInterface(Interface: UnrealEngineClass): boolean;
	EqualEqual_SoftObjectReference(B: any): boolean;
	GetDisplayName(): string;
	GetObjectName(): string;
	GetPathName(): string;
	GetPrimaryAssetIdFromObject(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftObjectReference(): PrimaryAssetId;
	IsValid(): boolean;
	IsValidSoftObjectReference(): boolean;
	K2_ClearTimer(FunctionName: string): void;
	K2_GetTimerElapsedTime(FunctionName: string): number;
	K2_GetTimerRemainingTime(FunctionName: string): number;
	K2_IsTimerActive(FunctionName: string): boolean;
	K2_IsTimerPaused(FunctionName: string): boolean;
	K2_PauseTimer(FunctionName: string): void;
	K2_SetTimer(FunctionName: string,Time: number,bLooping: boolean): TimerHandle;
	K2_TimerExists(FunctionName: string): boolean;
	K2_UnPauseTimer(FunctionName: string): void;
	NotEqual_SoftObjectReference(B: any): boolean;
	SetBoolPropertyByName(PropertyName: string,Value: boolean): void;
	SetBytePropertyByName(PropertyName: string,Value: number): void;
	SetClassPropertyByName(PropertyName: string,Value: UnrealEngineClass): void;
	SetCollisionProfileNameProperty(PropertyName: string,Value: CollisionProfileName): void;
	SetFloatPropertyByName(PropertyName: string,Value: number): void;
	SetInterfacePropertyByName(PropertyName: string,Value: any): void;
	SetIntPropertyByName(PropertyName: string,Value: number): void;
	SetLinearColorPropertyByName(PropertyName: string,Value: LinearColor): void;
	SetNamePropertyByName(PropertyName: string,Value: string): void;
	SetObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetRotatorPropertyByName(PropertyName: string,Value: Rotator): void;
	SetSoftClassPropertyByName(PropertyName: string,Value: any): void;
	SetSoftObjectPropertyByName(PropertyName: string,Value: any): void;
	SetStringPropertyByName(PropertyName: string,Value: string): void;
	SetStructurePropertyByName(PropertyName: string,Value: GenericStruct): void;
	SetTextPropertyByName(PropertyName: string,Value: string): void;
	SetTransformPropertyByName(PropertyName: string,Value: Transform): void;
	SetVectorPropertyByName(PropertyName: string,Value: Vector): void;
	Conv_ObjectToString(): string;
	EqualEqual_ObjectObject(B: UObject): boolean;
	NotEqual_ObjectObject(B: UObject): boolean;
	SelectObject(B: UObject,bSelectA: boolean): UObject;
	SetArrayPropertyByName(PropertyName: string,Value: number[]): void;
	GetObjectClass(): UnrealEngineClass;
	SetSetPropertyByName(PropertyName: string,Value: any): void;
	SetMapPropertyByName(PropertyName: string,Value: any): void;
	static AddWhitelistedObject(InObject: UObject): void;
	static BroadcastAssetCreated(NewAsset: UObject): void;
	static MarkPackageDirty(InObject: UObject): boolean;
	static ModifyObject(UObject: UObject,bAlwaysMarkDirty: boolean): void;
	static PostEditChange(InObject: UObject): void;
	static CreateEnum(Outer: UObject,Name: string,DisplayNames: string[]): Enum;
	static CreatePackage(Outer: UObject,PackageName: string): Package;
	static Duplicate(UObject: UObject,Outer: UObject,Name: string): UObject;
	static FindObjectWithOuter(Outer: UObject,ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	static FindPackage(InOuter: UObject,PackageName: string): Package;
	static GetArchetypePathName(UObject: UObject): string;
	static GetDir(UObject: UObject,WhichDir: string): string;
	static GetFields(UObject: UObject,bIncludeSuper: boolean): Field[];
	static GetFileSize(UObject: UObject,Filename: string): number;
	static GetName(UObject: UObject): string;
	static GetObjectsWithOuter(Outer: UObject,Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetOuter(UObject: UObject): UObject;
	static GetOutermost(UObject: UObject): UObject;
	static HasAnyFlags(UObject: UObject,Flags: number): boolean;
	static ReadDirectory(UObject: UObject,Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	static ReadFile(UObject: UObject,Filename: string): boolean;
	static ReadStringFromFile(UObject: UObject,Filename: string): string;
	static SetObjectFlags(Obj: UObject,Flags: number): void;
	static WriteFile(UObject: UObject,Filename: string): boolean;
	static WriteStringToFile(UObject: UObject,Filename: string,Data: string): boolean;
	static Conv_ObjectToText(InObj: UObject): string;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): any;
	static Conv_SoftObjectReferenceToObject(SoftObject: any): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: any): string;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static EqualEqual_SoftObjectReference(A: any,B: any): boolean;
	static GetDisplayName(UObject: UObject): string;
	static GetObjectName(UObject: UObject): string;
	static GetPathName(UObject: UObject): string;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: any): PrimaryAssetId;
	static IsValid(UObject: UObject): boolean;
	static IsValidSoftObjectReference(SoftObjectReference: any): boolean;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean): TimerHandle;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static NotEqual_SoftObjectReference(A: any,B: any): boolean;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetFloatPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetInterfacePropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static Conv_ObjectToString(InObj: UObject): string;
	static EqualEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static NotEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static SelectObject(A: UObject,B: UObject,bSelectA: boolean): UObject;
	static SetArrayPropertyByName(UObject: UObject,PropertyName: string,Value: number[]): void;
	static GetObjectClass(UObject: UObject): UnrealEngineClass;
	static SetSetPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetMapPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
}

declare class GCObjectReferencer extends UObject { 
	static Load(ResourceName: string): GCObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): GCObjectReferencer;
	static GetDefaultObject(): GCObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GCObjectReferencer;
	static C(Other: UObject | any): GCObjectReferencer;
}

declare class TextBuffer extends UObject { 
	static Load(ResourceName: string): TextBuffer;
	static Find(Outer: UObject, ResourceName: string): TextBuffer;
	static GetDefaultObject(): TextBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBuffer;
	static C(Other: UObject | any): TextBuffer;
}

declare class ScriptStruct extends Struct { 
	static Load(ResourceName: string): ScriptStruct;
	static Find(Outer: UObject, ResourceName: string): ScriptStruct;
	static GetDefaultObject(): ScriptStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScriptStruct;
	static C(Other: UObject | any): ScriptStruct;
}

declare class DynamicBlueprintBinding extends UObject { 
	static Load(ResourceName: string): DynamicBlueprintBinding;
	static Find(Outer: UObject, ResourceName: string): DynamicBlueprintBinding;
	static GetDefaultObject(): DynamicBlueprintBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicBlueprintBinding;
	static C(Other: UObject | any): DynamicBlueprintBinding;
}

declare class Class extends Struct { 
	static Load(ResourceName: string): Class;
	static Find(Outer: UObject, ResourceName: string): Class;
	static GetDefaultObject(): Class;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Class;
	static C(Other: UObject | any): Class;
	AddDynamicBinding(BindingObject: DynamicBlueprintBinding): void;
	GetClassPathName(): string;
	GetDerivedClasses(Results?: UnrealEngineClass[],bRecursive?: boolean): {Results: UnrealEngineClass[]};
	GetDynamicBinding(BindingObjectClass: UnrealEngineClass): DynamicBlueprintBinding;
	GetObjectsOfClass(Results?: UObject[],bIncludeDerivedClasses?: boolean,ExcludeFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetSuperClasses(): UnrealEngineClass[];
	IsGeneratedByBlueprint(): boolean;
	Conv_ClassToSoftClassReference(): any;
	Conv_SoftClassReferenceToClass(): UnrealEngineClass;
	Conv_SoftClassReferenceToString(): string;
	EqualEqual_SoftClassReference(B: any): boolean;
	GetClassDisplayName(): string;
	GetPrimaryAssetIdFromClass(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftClassReference(): PrimaryAssetId;
	IsValidClass(): boolean;
	IsValidSoftClassReference(): boolean;
	NotEqual_SoftClassReference(B: any): boolean;
	ClassIsChildOf(ParentClass: UnrealEngineClass): boolean;
	EqualEqual_ClassClass(B: UnrealEngineClass): boolean;
	NotEqual_ClassClass(B: UnrealEngineClass): boolean;
	SelectClass(B: UnrealEngineClass,bSelectA: boolean): UnrealEngineClass;
	CreateSaveGameObject(): SaveGame;
	SpawnObject(Outer: UObject): UObject;
	CreateDragDropOperation(): DragDropOperation;
	static AddDynamicBinding(Outer: UnrealEngineClass,BindingObject: DynamicBlueprintBinding): void;
	static GetClassPathName(Class: UnrealEngineClass): string;
	static GetDerivedClasses(ClassToLookFor: UnrealEngineClass,Results?: UnrealEngineClass[],bRecursive?: boolean): {Results: UnrealEngineClass[]};
	static GetDynamicBinding(Outer: UnrealEngineClass,BindingObjectClass: UnrealEngineClass): DynamicBlueprintBinding;
	static GetObjectsOfClass(ClassToLookFor: UnrealEngineClass,Results?: UObject[],bIncludeDerivedClasses?: boolean,ExcludeFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetSuperClasses(InClass: UnrealEngineClass): UnrealEngineClass[];
	static IsGeneratedByBlueprint(InClass: UnrealEngineClass): boolean;
	static Conv_ClassToSoftClassReference(Class: UnrealEngineClass): any;
	static Conv_SoftClassReferenceToClass(SoftClass: any): UnrealEngineClass;
	static Conv_SoftClassReferenceToString(SoftClassReference: any): string;
	static EqualEqual_SoftClassReference(A: any,B: any): boolean;
	static GetClassDisplayName(Class: UnrealEngineClass): string;
	static GetPrimaryAssetIdFromClass(Class: UnrealEngineClass): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: any): PrimaryAssetId;
	static IsValidClass(Class: UnrealEngineClass): boolean;
	static IsValidSoftClassReference(SoftClassReference: any): boolean;
	static NotEqual_SoftClassReference(A: any,B: any): boolean;
	static ClassIsChildOf(TestClass: UnrealEngineClass,ParentClass: UnrealEngineClass): boolean;
	static EqualEqual_ClassClass(A: UnrealEngineClass,B: UnrealEngineClass): boolean;
	static NotEqual_ClassClass(A: UnrealEngineClass,B: UnrealEngineClass): boolean;
	static SelectClass(A: UnrealEngineClass,B: UnrealEngineClass,bSelectA: boolean): UnrealEngineClass;
	static CreateSaveGameObject(SaveGameClass: UnrealEngineClass): SaveGame;
	static SpawnObject(ObjectClass: UnrealEngineClass,Outer: UObject): UObject;
	static CreateDragDropOperation(OperationClass: UnrealEngineClass): DragDropOperation;
}

declare class UFunction extends Struct { 
	static Load(ResourceName: string): UFunction;
	static Find(Outer: UObject, ResourceName: string): UFunction;
	static GetDefaultObject(): UFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UFunction;
	static C(Other: UObject | any): UFunction;
	GetFunctionParmsSize(): number;
	static GetFunctionParmsSize(UFunction: UFunction): number;
}

declare class DelegateFunction extends UFunction { 
	static Load(ResourceName: string): DelegateFunction;
	static Find(Outer: UObject, ResourceName: string): DelegateFunction;
	static GetDefaultObject(): DelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateFunction;
	static C(Other: UObject | any): DelegateFunction;
}

declare class DynamicClass extends Class { 
	static Load(ResourceName: string): DynamicClass;
	static Find(Outer: UObject, ResourceName: string): DynamicClass;
	static GetDefaultObject(): DynamicClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicClass;
	static C(Other: UObject | any): DynamicClass;
}

declare class EnumProperty extends Property { 
	static Load(ResourceName: string): EnumProperty;
	static Find(Outer: UObject, ResourceName: string): EnumProperty;
	static GetDefaultObject(): EnumProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumProperty;
	static C(Other: UObject | any): EnumProperty;
}

declare class LinkerPlaceholderClass extends Class { 
	static Load(ResourceName: string): LinkerPlaceholderClass;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderClass;
	static GetDefaultObject(): LinkerPlaceholderClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderClass;
	static C(Other: UObject | any): LinkerPlaceholderClass;
}

declare class LinkerPlaceholderExportObject extends UObject { 
	static Load(ResourceName: string): LinkerPlaceholderExportObject;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderExportObject;
	static GetDefaultObject(): LinkerPlaceholderExportObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderExportObject;
	static C(Other: UObject | any): LinkerPlaceholderExportObject;
}

declare class LinkerPlaceholderFunction extends UFunction { 
	static Load(ResourceName: string): LinkerPlaceholderFunction;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderFunction;
	static GetDefaultObject(): LinkerPlaceholderFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderFunction;
	static C(Other: UObject | any): LinkerPlaceholderFunction;
}

declare class MetaData extends UObject { 
	static Load(ResourceName: string): MetaData;
	static Find(Outer: UObject, ResourceName: string): MetaData;
	static GetDefaultObject(): MetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaData;
	static C(Other: UObject | any): MetaData;
}

declare class ObjectRedirector extends UObject { 
	static Load(ResourceName: string): ObjectRedirector;
	static Find(Outer: UObject, ResourceName: string): ObjectRedirector;
	static GetDefaultObject(): ObjectRedirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectRedirector;
	static C(Other: UObject | any): ObjectRedirector;
}

declare class ArrayProperty extends Property { 
	static Load(ResourceName: string): ArrayProperty;
	static Find(Outer: UObject, ResourceName: string): ArrayProperty;
	static GetDefaultObject(): ArrayProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrayProperty;
	static C(Other: UObject | any): ArrayProperty;
}

declare class ObjectPropertyBase extends Property { 
	static Load(ResourceName: string): ObjectPropertyBase;
	static Find(Outer: UObject, ResourceName: string): ObjectPropertyBase;
	static GetDefaultObject(): ObjectPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectPropertyBase;
	static C(Other: UObject | any): ObjectPropertyBase;
}

declare class BoolProperty extends Property { 
	static Load(ResourceName: string): BoolProperty;
	static Find(Outer: UObject, ResourceName: string): BoolProperty;
	static GetDefaultObject(): BoolProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolProperty;
	static C(Other: UObject | any): BoolProperty;
}

declare class NumericProperty extends Property { 
	static Load(ResourceName: string): NumericProperty;
	static Find(Outer: UObject, ResourceName: string): NumericProperty;
	static GetDefaultObject(): NumericProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NumericProperty;
	static C(Other: UObject | any): NumericProperty;
}

declare class ByteProperty extends NumericProperty { 
	static Load(ResourceName: string): ByteProperty;
	static Find(Outer: UObject, ResourceName: string): ByteProperty;
	static GetDefaultObject(): ByteProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ByteProperty;
	static C(Other: UObject | any): ByteProperty;
}

declare class ObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): ObjectProperty;
	static Find(Outer: UObject, ResourceName: string): ObjectProperty;
	static GetDefaultObject(): ObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectProperty;
	static C(Other: UObject | any): ObjectProperty;
}

declare class ClassProperty extends ObjectProperty { 
	static Load(ResourceName: string): ClassProperty;
	static Find(Outer: UObject, ResourceName: string): ClassProperty;
	static GetDefaultObject(): ClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassProperty;
	static C(Other: UObject | any): ClassProperty;
}

declare class DelegateProperty extends Property { 
	static Load(ResourceName: string): DelegateProperty;
	static Find(Outer: UObject, ResourceName: string): DelegateProperty;
	static GetDefaultObject(): DelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateProperty;
	static C(Other: UObject | any): DelegateProperty;
}

declare class DoubleProperty extends NumericProperty { 
	static Load(ResourceName: string): DoubleProperty;
	static Find(Outer: UObject, ResourceName: string): DoubleProperty;
	static GetDefaultObject(): DoubleProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleProperty;
	static C(Other: UObject | any): DoubleProperty;
}

declare class FloatProperty extends NumericProperty { 
	static Load(ResourceName: string): FloatProperty;
	static Find(Outer: UObject, ResourceName: string): FloatProperty;
	static GetDefaultObject(): FloatProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatProperty;
	static C(Other: UObject | any): FloatProperty;
}

declare class IntProperty extends NumericProperty { 
	static Load(ResourceName: string): IntProperty;
	static Find(Outer: UObject, ResourceName: string): IntProperty;
	static GetDefaultObject(): IntProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntProperty;
	static C(Other: UObject | any): IntProperty;
}

declare class Int16Property extends NumericProperty { 
	static Load(ResourceName: string): Int16Property;
	static Find(Outer: UObject, ResourceName: string): Int16Property;
	static GetDefaultObject(): Int16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int16Property;
	static C(Other: UObject | any): Int16Property;
}

declare class Int64Property extends NumericProperty { 
	static Load(ResourceName: string): Int64Property;
	static Find(Outer: UObject, ResourceName: string): Int64Property;
	static GetDefaultObject(): Int64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int64Property;
	static C(Other: UObject | any): Int64Property;
}

declare class Int8Property extends NumericProperty { 
	static Load(ResourceName: string): Int8Property;
	static Find(Outer: UObject, ResourceName: string): Int8Property;
	static GetDefaultObject(): Int8Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int8Property;
	static C(Other: UObject | any): Int8Property;
}

declare class InterfaceProperty extends Property { 
	static Load(ResourceName: string): InterfaceProperty;
	static Find(Outer: UObject, ResourceName: string): InterfaceProperty;
	static GetDefaultObject(): InterfaceProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterfaceProperty;
	static C(Other: UObject | any): InterfaceProperty;
}

declare class LazyObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): LazyObjectProperty;
	static Find(Outer: UObject, ResourceName: string): LazyObjectProperty;
	static GetDefaultObject(): LazyObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LazyObjectProperty;
	static C(Other: UObject | any): LazyObjectProperty;
}

declare class MapProperty extends Property { 
	static Load(ResourceName: string): MapProperty;
	static Find(Outer: UObject, ResourceName: string): MapProperty;
	static GetDefaultObject(): MapProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapProperty;
	static C(Other: UObject | any): MapProperty;
}

declare class MulticastDelegateProperty extends Property { 
	static Load(ResourceName: string): MulticastDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegateProperty;
	static GetDefaultObject(): MulticastDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegateProperty;
	static C(Other: UObject | any): MulticastDelegateProperty;
}

declare class NameProperty extends Property { 
	static Load(ResourceName: string): NameProperty;
	static Find(Outer: UObject, ResourceName: string): NameProperty;
	static GetDefaultObject(): NameProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NameProperty;
	static C(Other: UObject | any): NameProperty;
}

declare class SetProperty extends Property { 
	static Load(ResourceName: string): SetProperty;
	static Find(Outer: UObject, ResourceName: string): SetProperty;
	static GetDefaultObject(): SetProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SetProperty;
	static C(Other: UObject | any): SetProperty;
}

declare class SoftObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): SoftObjectProperty;
	static Find(Outer: UObject, ResourceName: string): SoftObjectProperty;
	static GetDefaultObject(): SoftObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftObjectProperty;
	static C(Other: UObject | any): SoftObjectProperty;
}

declare class SoftClassProperty extends SoftObjectProperty { 
	static Load(ResourceName: string): SoftClassProperty;
	static Find(Outer: UObject, ResourceName: string): SoftClassProperty;
	static GetDefaultObject(): SoftClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftClassProperty;
	static C(Other: UObject | any): SoftClassProperty;
}

declare class StrProperty extends Property { 
	static Load(ResourceName: string): StrProperty;
	static Find(Outer: UObject, ResourceName: string): StrProperty;
	static GetDefaultObject(): StrProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StrProperty;
	static C(Other: UObject | any): StrProperty;
}

declare class StructProperty extends Property { 
	static Load(ResourceName: string): StructProperty;
	static Find(Outer: UObject, ResourceName: string): StructProperty;
	static GetDefaultObject(): StructProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructProperty;
	static C(Other: UObject | any): StructProperty;
}

declare class UInt16Property extends NumericProperty { 
	static Load(ResourceName: string): UInt16Property;
	static Find(Outer: UObject, ResourceName: string): UInt16Property;
	static GetDefaultObject(): UInt16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt16Property;
	static C(Other: UObject | any): UInt16Property;
}

declare class UInt32Property extends NumericProperty { 
	static Load(ResourceName: string): UInt32Property;
	static Find(Outer: UObject, ResourceName: string): UInt32Property;
	static GetDefaultObject(): UInt32Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt32Property;
	static C(Other: UObject | any): UInt32Property;
}

declare class UInt64Property extends NumericProperty { 
	static Load(ResourceName: string): UInt64Property;
	static Find(Outer: UObject, ResourceName: string): UInt64Property;
	static GetDefaultObject(): UInt64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt64Property;
	static C(Other: UObject | any): UInt64Property;
}

declare class WeakObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): WeakObjectProperty;
	static Find(Outer: UObject, ResourceName: string): WeakObjectProperty;
	static GetDefaultObject(): WeakObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WeakObjectProperty;
	static C(Other: UObject | any): WeakObjectProperty;
}

declare class TextProperty extends Property { 
	static Load(ResourceName: string): TextProperty;
	static Find(Outer: UObject, ResourceName: string): TextProperty;
	static GetDefaultObject(): TextProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextProperty;
	static C(Other: UObject | any): TextProperty;
}

declare class InputCoreTypes extends UObject { 
	static Load(ResourceName: string): InputCoreTypes;
	static Find(Outer: UObject, ResourceName: string): InputCoreTypes;
	static GetDefaultObject(): InputCoreTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputCoreTypes;
	static C(Other: UObject | any): InputCoreTypes;
}

declare class FontFaceInterface extends Interface { 
	static Load(ResourceName: string): FontFaceInterface;
	static Find(Outer: UObject, ResourceName: string): FontFaceInterface;
	static GetDefaultObject(): FontFaceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFaceInterface;
	static C(Other: UObject | any): FontFaceInterface;
}

declare class FontProviderInterface extends Interface { 
	static Load(ResourceName: string): FontProviderInterface;
	static Find(Outer: UObject, ResourceName: string): FontProviderInterface;
	static GetDefaultObject(): FontProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontProviderInterface;
	static C(Other: UObject | any): FontProviderInterface;
}

declare class SlateTypes extends UObject { 
	static Load(ResourceName: string): SlateTypes;
	static Find(Outer: UObject, ResourceName: string): SlateTypes;
	static GetDefaultObject(): SlateTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTypes;
	static C(Other: UObject | any): SlateTypes;
}

declare class SlateWidgetStyleContainerBase extends UObject { 
	static Load(ResourceName: string): SlateWidgetStyleContainerBase;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerBase;
	static GetDefaultObject(): SlateWidgetStyleContainerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerBase;
	static C(Other: UObject | any): SlateWidgetStyleContainerBase;
}

declare class SlateWidgetStyleAsset extends UObject { 
	CustomStyle: SlateWidgetStyleContainerBase;
	static Load(ResourceName: string): SlateWidgetStyleAsset;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleAsset;
	static GetDefaultObject(): SlateWidgetStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAsset;
	static C(Other: UObject | any): SlateWidgetStyleAsset;
}

declare class SlateWidgetStyleContainerInterface extends Interface { 
	static Load(ResourceName: string): SlateWidgetStyleContainerInterface;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerInterface;
	static GetDefaultObject(): SlateWidgetStyleContainerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerInterface;
	static C(Other: UObject | any): SlateWidgetStyleContainerInterface;
}

declare class SlateWidgetStyle { 
	clone() : SlateWidgetStyle;
	static C(Other: UObject | any): SlateWidgetStyle;
}

declare class SlateSound { 
	ResourceObject: UObject;
	clone() : SlateSound;
	static C(Other: UObject | any): SlateSound;
}

declare class ButtonStyle extends SlateWidgetStyle { 
	Normal: SlateBrush;
	Hovered: SlateBrush;
	Pressed: SlateBrush;
	Disabled: SlateBrush;
	NormalPadding: Margin;
	PressedPadding: Margin;
	PressedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	PressedSound: string;
	HoveredSound: string;
	clone() : ButtonStyle;
	static C(Other: UObject | any): ButtonStyle;
}

declare class ButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ButtonStyle: ButtonStyle;
	static Load(ResourceName: string): ButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ButtonWidgetStyle;
	static GetDefaultObject(): ButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonWidgetStyle;
	static C(Other: UObject | any): ButtonWidgetStyle;
}

declare type ESlateCheckBoxType = 'CheckBox' | 'ToggleButton';
declare var ESlateCheckBoxType : { CheckBox:'CheckBox',ToggleButton:'ToggleButton', };
declare class CheckBoxStyle extends SlateWidgetStyle { 
	CheckBoxType: ESlateCheckBoxType;
	UncheckedImage: SlateBrush;
	UncheckedHoveredImage: SlateBrush;
	UncheckedPressedImage: SlateBrush;
	CheckedImage: SlateBrush;
	CheckedHoveredImage: SlateBrush;
	CheckedPressedImage: SlateBrush;
	UndeterminedImage: SlateBrush;
	UndeterminedHoveredImage: SlateBrush;
	UndeterminedPressedImage: SlateBrush;
	Padding: Margin;
	ForegroundColor: SlateColor;
	BorderBackgroundColor: SlateColor;
	CheckedSlateSound: SlateSound;
	UncheckedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	CheckedSound: string;
	UncheckedSound: string;
	HoveredSound: string;
	clone() : CheckBoxStyle;
	static C(Other: UObject | any): CheckBoxStyle;
}

declare class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	CheckBoxStyle: CheckBoxStyle;
	static Load(ResourceName: string): CheckBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): CheckBoxWidgetStyle;
	static GetDefaultObject(): CheckBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxWidgetStyle;
	static C(Other: UObject | any): CheckBoxWidgetStyle;
}

declare class ComboButtonStyle extends SlateWidgetStyle { 
	ButtonStyle: ButtonStyle;
	DownArrowImage: SlateBrush;
	MenuBorderBrush: SlateBrush;
	MenuBorderPadding: Margin;
	clone() : ComboButtonStyle;
	static C(Other: UObject | any): ComboButtonStyle;
}

declare class ComboBoxStyle extends SlateWidgetStyle { 
	ComboButtonStyle: ComboButtonStyle;
	PressedSlateSound: SlateSound;
	SelectionChangeSlateSound: SlateSound;
	PressedSound: string;
	SelectionChangeSound: string;
	clone() : ComboBoxStyle;
	static C(Other: UObject | any): ComboBoxStyle;
}

declare class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboBoxStyle: ComboBoxStyle;
	static Load(ResourceName: string): ComboBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboBoxWidgetStyle;
	static GetDefaultObject(): ComboBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxWidgetStyle;
	static C(Other: UObject | any): ComboBoxWidgetStyle;
}

declare class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboButtonStyle: ComboButtonStyle;
	static Load(ResourceName: string): ComboButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboButtonWidgetStyle;
	static GetDefaultObject(): ComboButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboButtonWidgetStyle;
	static C(Other: UObject | any): ComboButtonWidgetStyle;
}

declare class FontOutlineSettings { 
	OutlineSize: number;
	OutlineMaterial: UObject;
	OutlineColor: LinearColor;
	bSeparateFillAlpha: boolean;
	clone() : FontOutlineSettings;
	static C(Other: UObject | any): FontOutlineSettings;
}

declare class SlateFontInfo { 
	FontObject: UObject;
	FontMaterial: UObject;
	OutlineSettings: FontOutlineSettings;
	TypefaceFontName: string;
	Size: number;
	FontName: string;
	Hinting: Hinting;
	clone() : SlateFontInfo;
	static C(Other: UObject | any): SlateFontInfo;
}

declare class ScrollBarStyle extends SlateWidgetStyle { 
	HorizontalBackgroundImage: SlateBrush;
	VerticalBackgroundImage: SlateBrush;
	VerticalTopSlotImage: SlateBrush;
	HorizontalTopSlotImage: SlateBrush;
	VerticalBottomSlotImage: SlateBrush;
	HorizontalBottomSlotImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DraggedThumbImage: SlateBrush;
	clone() : ScrollBarStyle;
	static C(Other: UObject | any): ScrollBarStyle;
}

declare class EditableTextBoxStyle extends SlateWidgetStyle { 
	BackgroundImageNormal: SlateBrush;
	BackgroundImageHovered: SlateBrush;
	BackgroundImageFocused: SlateBrush;
	BackgroundImageReadOnly: SlateBrush;
	Padding: Margin;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	BackgroundColor: SlateColor;
	ReadOnlyForegroundColor: SlateColor;
	HScrollBarPadding: Margin;
	VScrollBarPadding: Margin;
	ScrollBarStyle: ScrollBarStyle;
	clone() : EditableTextBoxStyle;
	static C(Other: UObject | any): EditableTextBoxStyle;
}

declare class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextBoxStyle: EditableTextBoxStyle;
	static Load(ResourceName: string): EditableTextBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextBoxWidgetStyle;
	static GetDefaultObject(): EditableTextBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBoxWidgetStyle;
	static C(Other: UObject | any): EditableTextBoxWidgetStyle;
}

declare class EditableTextStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	BackgroundImageSelected: SlateBrush;
	BackgroundImageComposing: SlateBrush;
	CaretImage: SlateBrush;
	clone() : EditableTextStyle;
	static C(Other: UObject | any): EditableTextStyle;
}

declare class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextStyle: EditableTextStyle;
	static Load(ResourceName: string): EditableTextWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextWidgetStyle;
	static GetDefaultObject(): EditableTextWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextWidgetStyle;
	static C(Other: UObject | any): EditableTextWidgetStyle;
}

declare class ProgressBarStyle extends SlateWidgetStyle { 
	BackgroundImage: SlateBrush;
	FillImage: SlateBrush;
	MarqueeImage: SlateBrush;
	clone() : ProgressBarStyle;
	static C(Other: UObject | any): ProgressBarStyle;
}

declare class ProgressWidgetStyle extends SlateWidgetStyleContainerBase { 
	ProgressBarStyle: ProgressBarStyle;
	static Load(ResourceName: string): ProgressWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ProgressWidgetStyle;
	static GetDefaultObject(): ProgressWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressWidgetStyle;
	static C(Other: UObject | any): ProgressWidgetStyle;
}

declare class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBarStyle: ScrollBarStyle;
	static Load(ResourceName: string): ScrollBarWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBarWidgetStyle;
	static GetDefaultObject(): ScrollBarWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBarWidgetStyle;
	static C(Other: UObject | any): ScrollBarWidgetStyle;
}

declare class ScrollBoxStyle extends SlateWidgetStyle { 
	TopShadowBrush: SlateBrush;
	BottomShadowBrush: SlateBrush;
	LeftShadowBrush: SlateBrush;
	RightShadowBrush: SlateBrush;
	clone() : ScrollBoxStyle;
	static C(Other: UObject | any): ScrollBoxStyle;
}

declare class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBoxStyle: ScrollBoxStyle;
	static Load(ResourceName: string): ScrollBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBoxWidgetStyle;
	static GetDefaultObject(): ScrollBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxWidgetStyle;
	static C(Other: UObject | any): ScrollBoxWidgetStyle;
}

declare class SlateSettings extends UObject { 
	bExplicitCanvasChildZOrder: boolean;
	static Load(ResourceName: string): SlateSettings;
	static Find(Outer: UObject, ResourceName: string): SlateSettings;
	static GetDefaultObject(): SlateSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateSettings;
	static C(Other: UObject | any): SlateSettings;
}

declare class SpinBoxStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	HoveredBackgroundBrush: SlateBrush;
	ActiveFillBrush: SlateBrush;
	InactiveFillBrush: SlateBrush;
	ArrowsImage: SlateBrush;
	ForegroundColor: SlateColor;
	TextPadding: Margin;
	clone() : SpinBoxStyle;
	static C(Other: UObject | any): SpinBoxStyle;
}

declare class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	SpinBoxStyle: SpinBoxStyle;
	static Load(ResourceName: string): SpinBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): SpinBoxWidgetStyle;
	static GetDefaultObject(): SpinBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBoxWidgetStyle;
	static C(Other: UObject | any): SpinBoxWidgetStyle;
}

declare class TextBlockStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	SelectedBackgroundColor: SlateColor;
	HighlightColor: LinearColor;
	HighlightShape: SlateBrush;
	UnderlineBrush: SlateBrush;
	clone() : TextBlockStyle;
	static C(Other: UObject | any): TextBlockStyle;
}

declare class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase { 
	TextBlockStyle: TextBlockStyle;
	static Load(ResourceName: string): TextBlockWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): TextBlockWidgetStyle;
	static GetDefaultObject(): TextBlockWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlockWidgetStyle;
	static C(Other: UObject | any): TextBlockWidgetStyle;
}

declare type EColorVisionDeficiency = 'CVD_NormalVision' | 'CVD_Deuteranomly' | 'CVD_Deuteranopia' | 'CVD_Protanomly' | 'CVD_Protanopia' | 'CVD_Tritanomaly' | 'CVD_Tritanopia' | 'CVD_Achromatopsia';
declare var EColorVisionDeficiency : { CVD_NormalVision:'CVD_NormalVision',CVD_Deuteranomly:'CVD_Deuteranomly',CVD_Deuteranopia:'CVD_Deuteranopia',CVD_Protanomly:'CVD_Protanomly',CVD_Protanopia:'CVD_Protanopia',CVD_Tritanomaly:'CVD_Tritanomaly',CVD_Tritanopia:'CVD_Tritanopia',CVD_Achromatopsia:'CVD_Achromatopsia', };
declare type ELogTimes = 'None' | 'UTC' | 'SinceGStartTime' | 'Local';
declare var ELogTimes : { None:'None',UTC:'UTC',SinceGStartTime:'SinceGStartTime',Local:'Local', };
declare type EAssetEditorOpenLocation = 'Default' | 'NewWindow' | 'MainWindow' | 'ContentBrowser' | 'LastDockedWindowOrNewWindow' | 'LastDockedWindowOrMainWindow' | 'LastDockedWindowOrContentBrowser';
declare var EAssetEditorOpenLocation : { Default:'Default',NewWindow:'NewWindow',MainWindow:'MainWindow',ContentBrowser:'ContentBrowser',LastDockedWindowOrNewWindow:'LastDockedWindowOrNewWindow',LastDockedWindowOrMainWindow:'LastDockedWindowOrMainWindow',LastDockedWindowOrContentBrowser:'LastDockedWindowOrContentBrowser', };
declare class EditorStyleSettings extends UObject { 
	SelectionColor: LinearColor;
	PressedSelectionColor: LinearColor;
	InactiveSelectionColor: LinearColor;
	KeyboardFocusColor: LinearColor;
	ColorVisionDeficiencyPreviewType: EColorVisionDeficiency;
	EditorWindowBackgroundColor: LinearColor;
	EditorMainWindowBackgroundOverride: SlateBrush;
	EditorChildWindowBackgroundOverride: SlateBrush;
	bResetEditorWindowBackgroundSettings: boolean;
	bUseSmallToolBarIcons: boolean;
	bUseGrid: boolean;
	RegularColor: LinearColor;
	RuleColor: LinearColor;
	CenterColor: LinearColor;
	GridSnapSize: any;
	bEnableWindowAnimations: boolean;
	bShowFriendlyNames: boolean;
	bExpandConfigurationMenus: boolean;
	bShowProjectMenus: boolean;
	bShowLaunchMenus: boolean;
	LogBackgroundColor: LinearColor;
	LogSelectionBackgroundColor: LinearColor;
	LogNormalColor: LinearColor;
	LogCommandColor: LinearColor;
	LogWarningColor: LinearColor;
	LogErrorColor: LinearColor;
	bShowAllAdvancedDetails: boolean;
	bShowHiddenPropertiesWhilePlaying: boolean;
	LogFontSize: number;
	LogTimestampMode: ELogTimes;
	bPromoteOutputLogWarningsDuringPIE: boolean;
	AssetEditorOpenLocation: AssetEditorOpenLocation;
	bEnableColorizedEditorTabs: boolean;
	static Load(ResourceName: string): EditorStyleSettings;
	static Find(Outer: UObject, ResourceName: string): EditorStyleSettings;
	static GetDefaultObject(): EditorStyleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorStyleSettings;
	static C(Other: UObject | any): EditorStyleSettings;
}

declare class MaterialShaderQualitySettings extends UObject { 
	ForwardSettingMap: any;
	static Load(ResourceName: string): MaterialShaderQualitySettings;
	static Find(Outer: UObject, ResourceName: string): MaterialShaderQualitySettings;
	static GetDefaultObject(): MaterialShaderQualitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialShaderQualitySettings;
	static C(Other: UObject | any): MaterialShaderQualitySettings;
}

declare type EMobileCSMQuality = 'NoFiltering' | 'PCF_1x1' | 'PCF_2x2';
declare var EMobileCSMQuality : { NoFiltering:'NoFiltering',PCF_1x1:'PCF_1x1',PCF_2x2:'PCF_2x2', };
declare class MaterialQualityOverrides { 
	bEnableOverride: boolean;
	bForceFullyRough: boolean;
	bForceNonMetal: boolean;
	bForceDisableLMDirectionality: boolean;
	bForceLQReflections: boolean;
	MobileCSMQuality: MobileCSMQuality;
	clone() : MaterialQualityOverrides;
	static C(Other: UObject | any): MaterialQualityOverrides;
}

declare class ShaderPlatformQualitySettings extends UObject { 
	QualityOverrides: MaterialQualityOverrides;
	static Load(ResourceName: string): ShaderPlatformQualitySettings;
	static Find(Outer: UObject, ResourceName: string): ShaderPlatformQualitySettings;
	static GetDefaultObject(): ShaderPlatformQualitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderPlatformQualitySettings;
	static C(Other: UObject | any): ShaderPlatformQualitySettings;
}

declare class ClothingAssetFactoryBase extends UObject { 
	static Load(ResourceName: string): ClothingAssetFactoryBase;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetFactoryBase;
	static GetDefaultObject(): ClothingAssetFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetFactoryBase;
	static C(Other: UObject | any): ClothingAssetFactoryBase;
}

declare class AssetRegistryImpl extends UObject { 
	static Load(ResourceName: string): AssetRegistryImpl;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryImpl;
	static GetDefaultObject(): AssetRegistryImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryImpl;
	static C(Other: UObject | any): AssetRegistryImpl;
}

declare class AssetData { 
	ObjectPath: string;
	PackageName: string;
	PackagePath: string;
	AssetName: string;
	AssetClass: string;
	clone() : AssetData;
	static C(Other: UObject | any): AssetData;
}

declare class ARFilter { 
	PackageNames: string[];
	PackagePaths: string[];
	ObjectPaths: string[];
	ClassNames: string[];
	RecursiveClassesExclusionSet: any;
	bRecursivePaths: boolean;
	bRecursiveClasses: boolean;
	bIncludeOnlyOnDiskAssets: boolean;
	clone() : ARFilter;
	static C(Other: UObject | any): ARFilter;
}

declare class TagAndValue { 
	Tag: string;
	Value: string;
	clone() : TagAndValue;
	static C(Other: UObject | any): TagAndValue;
}

declare class AssetRegistryHelpers extends UObject { 
	static Load(ResourceName: string): AssetRegistryHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryHelpers;
	static GetDefaultObject(): AssetRegistryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryHelpers;
	static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;
	static SetFilterTagsAndValues(InFilter: ARFilter,InTagsAndValues: TagAndValue[]): ARFilter;
	static IsValid(InAssetData: AssetData): boolean;
	static IsUAsset(InAssetData: AssetData): boolean;
	static IsRedirector(InAssetData: AssetData): boolean;
	static IsAssetLoaded(InAssetData: AssetData): boolean;
	static GetTagValue(InAssetData: AssetData,InTagName: string,OutTagValue?: string): {OutTagValue: string, $: boolean};
	static GetFullName(InAssetData: AssetData): string;
	static GetExportTextName(InAssetData: AssetData): string;
	static GetClass(InAssetData: AssetData): UnrealEngineClass;
	static GetAsset(InAssetData: AssetData): UObject;
	static CreateAssetData(InAsset: UObject,bAllowBlueprintClass: boolean): AssetData;
	static C(Other: UObject | any): AssetRegistryHelpers;
}

declare class AssetRegistry extends Interface { 
	static Load(ResourceName: string): AssetRegistry;
	static Find(Outer: UObject, ResourceName: string): AssetRegistry;
	static GetDefaultObject(): AssetRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistry;
	RunAssetsThroughFilter(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	IsLoadingAssets(): boolean;
	HasAssets(PackagePath: string,bRecursive: boolean): boolean;
	GetSubPaths(InBasePath: string,OutPathList?: string[],bInRecurse?: boolean): {OutPathList: string[]};
	GetAssetsByPath(PackagePath: string,OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPackageName(PackageName: string,OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByClass(ClassName: string,OutAssetData?: AssetData[],bSearchSubClasses?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssets(Filter: ARFilter,OutAssetData?: AssetData[]): {OutAssetData: AssetData[], $: boolean};
	GetAssetByObjectPath(ObjectPath: string,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	GetAllCachedPaths(OutPathList?: string[]): {OutPathList: string[]};
	GetAllAssets(OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	static C(Other: UObject | any): AssetRegistry;
}

declare class AutoCompleteCommand { 
	Command: string;
	Desc: string;
	clone() : AutoCompleteCommand;
	static C(Other: UObject | any): AutoCompleteCommand;
}

declare class ConsoleSettings extends UObject { 
	MaxScrollbackSize: number;
	ManualAutoCompleteList: AutoCompleteCommand[];
	AutoCompleteMapPaths: string[];
	BackgroundOpacityPercentage: number;
	bOrderTopToBottom: boolean;
	InputColor: Color;
	HistoryColor: Color;
	AutoCompleteCommandColor: Color;
	AutoCompleteCVarColor: Color;
	AutoCompleteFadedColor: Color;
	static Load(ResourceName: string): ConsoleSettings;
	static Find(Outer: UObject, ResourceName: string): ConsoleSettings;
	static GetDefaultObject(): ConsoleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConsoleSettings;
	static C(Other: UObject | any): ConsoleSettings;
}

declare type ETwoPlayerSplitScreenType = 'Horizontal' | 'Vertical';
declare var ETwoPlayerSplitScreenType : { Horizontal:'Horizontal',Vertical:'Vertical', };
declare type EThreePlayerSplitScreenType = 'FavorTop' | 'FavorBottom';
declare var EThreePlayerSplitScreenType : { FavorTop:'FavorTop',FavorBottom:'FavorBottom', };
declare class GameModeName { 
	Name: string;
	GameMode: SoftClassPath;
	clone() : GameModeName;
	static C(Other: UObject | any): GameModeName;
}

declare class GameMapsSettings extends UObject { 
	EditorStartupMap: SoftObjectPath;
	LocalMapOptions: string;
	TransitionMap: SoftObjectPath;
	bUseSplitscreen: boolean;
	TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
	ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
	bOffsetPlayerGamepadIds: boolean;
	GameInstanceClass: SoftClassPath;
	GameDefaultMap: SoftObjectPath;
	ServerDefaultMap: SoftObjectPath;
	GlobalDefaultGameMode: SoftClassPath;
	GlobalDefaultServerGameMode: SoftClassPath;
	GameModeMapPrefixes: GameModeName[];
	GameModeClassAliases: GameModeName[];
	static Load(ResourceName: string): GameMapsSettings;
	static Find(Outer: UObject, ResourceName: string): GameMapsSettings;
	static GetDefaultObject(): GameMapsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMapsSettings;
	static C(Other: UObject | any): GameMapsSettings;
}

declare class GameNetworkManagerSettings extends UObject { 
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	TotalNetBandwidth: number;
	BadPingThreshold: number;
	bIsStandbyCheckingEnabled: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	static Load(ResourceName: string): GameNetworkManagerSettings;
	static Find(Outer: UObject, ResourceName: string): GameNetworkManagerSettings;
	static GetDefaultObject(): GameNetworkManagerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManagerSettings;
	static C(Other: UObject | any): GameNetworkManagerSettings;
}

declare class GameSessionSettings extends UObject { 
	MaxSpectators: number;
	MaxPlayers: number;
	bRequiresPushToTalk: boolean;
	static Load(ResourceName: string): GameSessionSettings;
	static Find(Outer: UObject, ResourceName: string): GameSessionSettings;
	static GetDefaultObject(): GameSessionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSessionSettings;
	static C(Other: UObject | any): GameSessionSettings;
}

declare class GeneralEngineSettings extends UObject { 
	static Load(ResourceName: string): GeneralEngineSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralEngineSettings;
	static GetDefaultObject(): GeneralEngineSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralEngineSettings;
	static C(Other: UObject | any): GeneralEngineSettings;
}

declare class GeneralProjectSettings extends UObject { 
	CompanyName: string;
	CompanyDistinguishedName: string;
	CopyrightNotice: string;
	Description: string;
	Homepage: string;
	LicensingTerms: string;
	PrivacyPolicy: string;
	ProjectID: Guid;
	ProjectName: string;
	ProjectVersion: string;
	SupportContact: string;
	ProjectDisplayedTitle: string;
	ProjectDebugTitleInfo: string;
	bShouldWindowPreserveAspectRatio: boolean;
	bUseBorderlessWindow: boolean;
	bStartInVR: boolean;
	bStartInAR: boolean;
	bAllowWindowResize: boolean;
	bAllowClose: boolean;
	bAllowMaximize: boolean;
	bAllowMinimize: boolean;
	static Load(ResourceName: string): GeneralProjectSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralProjectSettings;
	static GetDefaultObject(): GeneralProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralProjectSettings;
	static C(Other: UObject | any): GeneralProjectSettings;
}

declare class HudSettings extends UObject { 
	bShowHUD: boolean;
	DebugDisplay: string[];
	static Load(ResourceName: string): HudSettings;
	static Find(Outer: UObject, ResourceName: string): HudSettings;
	static GetDefaultObject(): HudSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HudSettings;
	static C(Other: UObject | any): HudSettings;
}

declare class HandlerComponentFactory extends UObject { 
	static Load(ResourceName: string): HandlerComponentFactory;
	static Find(Outer: UObject, ResourceName: string): HandlerComponentFactory;
	static GetDefaultObject(): HandlerComponentFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HandlerComponentFactory;
	static C(Other: UObject | any): HandlerComponentFactory;
}

declare class JsonUtilitiesDummyObject extends UObject { 
	static Load(ResourceName: string): JsonUtilitiesDummyObject;
	static Find(Outer: UObject, ResourceName: string): JsonUtilitiesDummyObject;
	static GetDefaultObject(): JsonUtilitiesDummyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonUtilitiesDummyObject;
	static C(Other: UObject | any): JsonUtilitiesDummyObject;
}

declare type EPIEPreviewDeviceType = 'Unset' | 'Android' | 'IOS' | 'TVOS';
declare var EPIEPreviewDeviceType : { Unset:'Unset',Android:'Android',IOS:'IOS',TVOS:'TVOS', };
declare class PIEPreviewDeviceSpecification extends UObject { 
	PreviewDeviceType: PreviewDeviceType;
	GPUFamily: string;
	GLVersion: string;
	VulkanVersion: string;
	AndroidVersion: string;
	DeviceMake: string;
	DeviceModel: string;
	UsingHoudini: boolean;
	static Load(ResourceName: string): PIEPreviewDeviceSpecification;
	static Find(Outer: UObject, ResourceName: string): PIEPreviewDeviceSpecification;
	static GetDefaultObject(): PIEPreviewDeviceSpecification;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PIEPreviewDeviceSpecification;
	static C(Other: UObject | any): PIEPreviewDeviceSpecification;
}

declare class PropertyConfigFileDisplayRow extends UObject { 
	ConfigFileName: string;
	ExternalProperty: Property;
	bIsFileWritable: boolean;
	static Load(ResourceName: string): PropertyConfigFileDisplayRow;
	static Find(Outer: UObject, ResourceName: string): PropertyConfigFileDisplayRow;
	static GetDefaultObject(): PropertyConfigFileDisplayRow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyConfigFileDisplayRow;
	static C(Other: UObject | any): PropertyConfigFileDisplayRow;
}

declare class ConfigHierarchyPropertyView extends UObject { 
	EditProperty: any;
	ConfigFilePropertyObjects: PropertyConfigFileDisplayRow[];
	static Load(ResourceName: string): ConfigHierarchyPropertyView;
	static Find(Outer: UObject, ResourceName: string): ConfigHierarchyPropertyView;
	static GetDefaultObject(): ConfigHierarchyPropertyView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConfigHierarchyPropertyView;
	static C(Other: UObject | any): ConfigHierarchyPropertyView;
}

declare class ClothingAssetCustomData extends UObject { 
	static Load(ResourceName: string): ClothingAssetCustomData;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCustomData;
	static GetDefaultObject(): ClothingAssetCustomData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCustomData;
	static C(Other: UObject | any): ClothingAssetCustomData;
}

declare type EClothingWindMethod = 'Legacy' | 'Accurate';
declare var EClothingWindMethod : { Legacy:'Legacy',Accurate:'Accurate', };
declare class ClothConstraintSetup { 
	Stiffness: number;
	StiffnessMultiplier: number;
	StretchLimit: number;
	CompressionLimit: number;
	clone() : ClothConstraintSetup;
	static C(Other: UObject | any): ClothConstraintSetup;
}

declare class ClothConfig { 
	WindMethod: WindMethod;
	VerticalConstraintConfig: ClothConstraintSetup;
	HorizontalConstraintConfig: ClothConstraintSetup;
	BendConstraintConfig: ClothConstraintSetup;
	ShearConstraintConfig: ClothConstraintSetup;
	SelfCollisionRadius: number;
	SelfCollisionStiffness: number;
	SelfCollisionCullScale: number;
	Damping: Vector;
	Friction: number;
	WindDragCoefficient: number;
	WindLiftCoefficient: number;
	LinearDrag: Vector;
	AngularDrag: Vector;
	LinearInertiaScale: Vector;
	AngularInertiaScale: Vector;
	CentrifugalInertiaScale: Vector;
	SolverFrequency: number;
	StiffnessFrequency: number;
	GravityScale: number;
	TetherStiffness: number;
	TetherLimit: number;
	CollisionThickness: number;
	clone() : ClothConfig;
	static C(Other: UObject | any): ClothConfig;
}

declare class ClothVertBoneData { 
	NumInfluences: number;
	BoneIndices: any;
	BoneWeights: number;
	clone() : ClothVertBoneData;
	static C(Other: UObject | any): ClothVertBoneData;
}

declare class ClothPhysicalMeshData { 
	Vertices: Vector[];
	Normals: Vector[];
	Indices: any[];
	MaxDistances: number[];
	BackstopDistances: number[];
	BackstopRadiuses: number[];
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	MaxBoneWeights: number;
	NumFixedVerts: number;
	SelfCollisionIndices: any[];
	clone() : ClothPhysicalMeshData;
	static C(Other: UObject | any): ClothPhysicalMeshData;
}

declare class ClothCollisionPrim_Sphere { 
	BoneIndex: number;
	Radius: number;
	LocalPosition: Vector;
	clone() : ClothCollisionPrim_Sphere;
	static C(Other: UObject | any): ClothCollisionPrim_Sphere;
}

declare class ClothCollisionPrim_SphereConnection { 
	SphereIndices: number;
	clone() : ClothCollisionPrim_SphereConnection;
	static C(Other: UObject | any): ClothCollisionPrim_SphereConnection;
}

declare class ClothCollisionPrim_Convex { 
	Planes: Plane[];
	BoneIndex: number;
	clone() : ClothCollisionPrim_Convex;
	static C(Other: UObject | any): ClothCollisionPrim_Convex;
}

declare class ClothCollisionData { 
	Spheres: ClothCollisionPrim_Sphere[];
	SphereConnections: ClothCollisionPrim_SphereConnection[];
	Convexes: ClothCollisionPrim_Convex[];
	clone() : ClothCollisionData;
	static C(Other: UObject | any): ClothCollisionData;
}

declare type MaskTarget_PhysMesh = 'None' | 'MaxDistance' | 'BackstopDistance' | 'BackstopRadius';
declare var MaskTarget_PhysMesh : { None:'None',MaxDistance:'MaxDistance',BackstopDistance:'BackstopDistance',BackstopRadius:'BackstopRadius', };
declare class ClothParameterMask_PhysMesh { 
	MaskName: string;
	CurrentTarget: CurrentTarget;
	MaxValue: number;
	MinValue: number;
	Values: number[];
	bEnabled: boolean;
	clone() : ClothParameterMask_PhysMesh;
	static C(Other: UObject | any): ClothParameterMask_PhysMesh;
}

declare class ClothLODData { 
	PhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	ParameterMasks: ClothParameterMask_PhysMesh[];
	clone() : ClothLODData;
	static C(Other: UObject | any): ClothLODData;
}

declare class ClothingAsset extends ClothingAssetBase { 
	PhysicsAsset: PhysicsAsset;
	ClothConfig: ClothConfig;
	LodData: ClothLODData[];
	LodMap: number[];
	UsedBoneNames: string[];
	UsedBoneIndices: number[];
	ReferenceBoneIndex: number;
	CustomData: ClothingAssetCustomData;
	static Load(ResourceName: string): ClothingAsset;
	static Find(Outer: UObject, ResourceName: string): ClothingAsset;
	static GetDefaultObject(): ClothingAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAsset;
	static C(Other: UObject | any): ClothingAsset;
}

declare class ClothingSimulationFactoryNv extends ClothingSimulationFactory { 
	static Load(ResourceName: string): ClothingSimulationFactoryNv;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationFactoryNv;
	static GetDefaultObject(): ClothingSimulationFactoryNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationFactoryNv;
	static C(Other: UObject | any): ClothingSimulationFactoryNv;
}

declare class ClothingAssetFactory extends ClothingAssetFactoryBase { 
	static Load(ResourceName: string): ClothingAssetFactory;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetFactory;
	static GetDefaultObject(): ClothingAssetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetFactory;
	static C(Other: UObject | any): ClothingAssetFactory;
}

declare type ELocalizationTargetConflictStatus = 'Unknown' | 'ConflictsPresent' | 'Clear';
declare var ELocalizationTargetConflictStatus : { Unknown:'Unknown',ConflictsPresent:'ConflictsPresent',Clear:'Clear', };
declare class FilePath { 
	FilePath: string;
	clone() : FilePath;
	static C(Other: UObject | any): FilePath;
}

declare class GatherTextSearchDirectory { 
	Path: string;
	clone() : GatherTextSearchDirectory;
	static C(Other: UObject | any): GatherTextSearchDirectory;
}

declare class GatherTextExcludePath { 
	Pattern: string;
	clone() : GatherTextExcludePath;
	static C(Other: UObject | any): GatherTextExcludePath;
}

declare class GatherTextFileExtension { 
	Pattern: string;
	clone() : GatherTextFileExtension;
	static C(Other: UObject | any): GatherTextFileExtension;
}

declare class GatherTextFromTextFilesConfiguration { 
	IsEnabled: boolean;
	SearchDirectories: GatherTextSearchDirectory[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromTextFilesConfiguration;
	static C(Other: UObject | any): GatherTextFromTextFilesConfiguration;
}

declare class GatherTextIncludePath { 
	Pattern: string;
	clone() : GatherTextIncludePath;
	static C(Other: UObject | any): GatherTextIncludePath;
}

declare class GatherTextFromPackagesConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	Collections: string[];
	ShouldGatherFromEditorOnlyData: boolean;
	SkipGatherCache: boolean;
	clone() : GatherTextFromPackagesConfiguration;
	static C(Other: UObject | any): GatherTextFromPackagesConfiguration;
}

declare class MetaDataKeyName { 
	Name: string;
	clone() : MetaDataKeyName;
	static C(Other: UObject | any): MetaDataKeyName;
}

declare class MetaDataTextKeyPattern { 
	Pattern: string;
	clone() : MetaDataTextKeyPattern;
	static C(Other: UObject | any): MetaDataTextKeyPattern;
}

declare class MetaDataKeyGatherSpecification { 
	MetaDataKey: MetaDataKeyName;
	TextNamespace: string;
	TextKeyPattern: MetaDataTextKeyPattern;
	clone() : MetaDataKeyGatherSpecification;
	static C(Other: UObject | any): MetaDataKeyGatherSpecification;
}

declare class GatherTextFromMetaDataConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	KeySpecifications: MetaDataKeyGatherSpecification[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromMetaDataConfiguration;
	static C(Other: UObject | any): GatherTextFromMetaDataConfiguration;
}

declare type ELocalizedTextCollapseMode = 'IdenticalTextIdAndSource' | 'IdenticalPackageIdTextIdAndSource' | 'IdenticalNamespaceAndSource';
declare var ELocalizedTextCollapseMode : { IdenticalTextIdAndSource:'IdenticalTextIdAndSource',IdenticalPackageIdTextIdAndSource:'IdenticalPackageIdTextIdAndSource',IdenticalNamespaceAndSource:'IdenticalNamespaceAndSource', };
declare class LocalizationExportingSettings { 
	CollapseMode: CollapseMode;
	ShouldPersistCommentsOnExport: boolean;
	ShouldAddSourceLocationsAsComments: boolean;
	clone() : LocalizationExportingSettings;
	static C(Other: UObject | any): LocalizationExportingSettings;
}

declare class LocalizationCompilationSettings { 
	SkipSourceCheck: boolean;
	clone() : LocalizationCompilationSettings;
	static C(Other: UObject | any): LocalizationCompilationSettings;
}

declare class DirectoryPath { 
	Path: string;
	clone() : DirectoryPath;
	static C(Other: UObject | any): DirectoryPath;
}

declare class LocalizationImportDialogueSettings { 
	RawAudioPath: DirectoryPath;
	ImportedDialogueFolder: string;
	bImportNativeAsSource: boolean;
	clone() : LocalizationImportDialogueSettings;
	static C(Other: UObject | any): LocalizationImportDialogueSettings;
}

declare class CultureStatistics { 
	CultureName: string;
	WordCount: any;
	clone() : CultureStatistics;
	static C(Other: UObject | any): CultureStatistics;
}

declare class LocalizationTargetSettings { 
	Name: string;
	Guid: Guid;
	ConflictStatus: ConflictStatus;
	TargetDependencies: Guid[];
	AdditionalManifestDependencies: FilePath[];
	RequiredModuleNames: string[];
	GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
	GatherFromPackages: GatherTextFromPackagesConfiguration;
	GatherFromMetaData: GatherTextFromMetaDataConfiguration;
	ExportSettings: LocalizationExportingSettings;
	CompileSettings: LocalizationCompilationSettings;
	ImportDialogueSettings: LocalizationImportDialogueSettings;
	NativeCultureIndex: number;
	SupportedCulturesStatistics: CultureStatistics[];
	clone() : LocalizationTargetSettings;
	static C(Other: UObject | any): LocalizationTargetSettings;
}

declare class LocalizationTarget extends UObject { 
	Settings: LocalizationTargetSettings;
	static Load(ResourceName: string): LocalizationTarget;
	static Find(Outer: UObject, ResourceName: string): LocalizationTarget;
	static GetDefaultObject(): LocalizationTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTarget;
	static C(Other: UObject | any): LocalizationTarget;
}

declare class LocalizationTargetSet extends UObject { 
	TargetObjects: LocalizationTarget[];
	static Load(ResourceName: string): LocalizationTargetSet;
	static Find(Outer: UObject, ResourceName: string): LocalizationTargetSet;
	static GetDefaultObject(): LocalizationTargetSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTargetSet;
	static C(Other: UObject | any): LocalizationTargetSet;
}

declare class LocalizationSettings extends UObject { 
	EngineTargetSet: LocalizationTargetSet;
	EngineTargetsSettings: LocalizationTargetSettings[];
	GameTargetSet: LocalizationTargetSet;
	GameTargetsSettings: LocalizationTargetSettings[];
	static Load(ResourceName: string): LocalizationSettings;
	static Find(Outer: UObject, ResourceName: string): LocalizationSettings;
	static GetDefaultObject(): LocalizationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationSettings;
	static C(Other: UObject | any): LocalizationSettings;
}

declare type EHMDTrackingOrigin = 'Floor' | 'Eye';
declare var EHMDTrackingOrigin : { Floor:'Floor',Eye:'Eye', };
declare type ESpectatorScreenMode = 'Disabled' | 'SingleEyeLetterboxed' | 'Undistorted' | 'Distorted' | 'SingleEye' | 'SingleEyeCroppedToFill' | 'Texture' | 'TexturePlusEye';
declare var ESpectatorScreenMode : { Disabled:'Disabled',SingleEyeLetterboxed:'SingleEyeLetterboxed',Undistorted:'Undistorted',Distorted:'Distorted',SingleEye:'SingleEye',SingleEyeCroppedToFill:'SingleEyeCroppedToFill',Texture:'Texture',TexturePlusEye:'TexturePlusEye', };
declare type EHMDWornState = 'Unknown' | 'Worn' | 'NotWorn';
declare var EHMDWornState : { Unknown:'Unknown',Worn:'Worn',NotWorn:'NotWorn', };
declare class HeadMountedDisplayFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static GetDefaultObject(): HeadMountedDisplayFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HeadMountedDisplayFunctionLibrary;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
	static SetTrackingOrigin(Origin: EHMDTrackingOrigin): void;
	static SetSpectatorScreenTexture(InTexture: Texture): void;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean): void;
	static SetSpectatorScreenMode(Mode: Mode): void;
	static SetClippingPlanes(Near: number,Far: number): void;
	static ResetOrientationAndPosition(Yaw: number,Options: EOrientPositionSelector): void;
	static IsSpectatorScreenModeControllable(): boolean;
	static IsInLowPersistenceMode(): boolean;
	static IsHeadMountedDisplayEnabled(): boolean;
	static IsHeadMountedDisplayConnected(): boolean;
	static HasValidTrackingPosition(): boolean;
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static GetVRFocusState(bUseFocus?: boolean,bHasFocus?: boolean): {bUseFocus: boolean, bHasFocus: boolean};
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static GetTrackingOrigin(): EHMDTrackingOrigin;
	static GetScreenPercentage(): number;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static GetNumOfTrackingSensors(): number;
	static GetHMDWornState(): EHMDWornState;
	static GetHMDDeviceName(): string;
	static EnableLowPersistenceMode(bEnable: boolean): void;
	static EnableHMD(bEnable: boolean): boolean;
	static C(Other: UObject | any): HeadMountedDisplayFunctionLibrary;
}

declare type ETrackingStatus = 'NotTracked' | 'InertialOnly' | 'Tracked';
declare var ETrackingStatus : { NotTracked:'NotTracked',InertialOnly:'InertialOnly',Tracked:'Tracked', };
declare class MotionControllerComponent extends PrimitiveComponent { 
	PlayerIndex: number;
	Hand: Hand;
	bDisableLowLatencyUpdate: boolean;
	CurrentTrackingStatus: CurrentTrackingStatus;
	static Load(ResourceName: string): MotionControllerComponent;
	static Find(Outer: UObject, ResourceName: string): MotionControllerComponent;
	static GetDefaultObject(): MotionControllerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionControllerComponent;
	IsTracked(): boolean;
	static C(Other: UObject | any): MotionControllerComponent;
	DisableMotionTrackingForComponent(): void;
	EnableMotionTrackingForComponent(): boolean;
	IsMotionTrackingEnabledForComponent(): boolean;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
}

declare class MotionTrackedDeviceFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static GetDefaultObject(): MotionTrackedDeviceFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrackedDeviceFunctionLibrary;
	static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean): void;
	static IsMotionTrackingEnabledForDevice(PlayerIndex: number,Hand: Hand): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackedDeviceCountManagementNecessary(): boolean;
	static GetMotionTrackingEnabledControllerCount(): number;
	static GetMaximumMotionTrackedControllerCount(): number;
	static EnableMotionTrackingOfDevice(PlayerIndex: number,Hand: Hand): boolean;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static DisableMotionTrackingOfDevice(PlayerIndex: number,Hand: Hand): void;
	static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number): void;
	static DisableMotionTrackingOfAllControllers(): void;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static C(Other: UObject | any): MotionTrackedDeviceFunctionLibrary;
}

declare class VRNotificationsComponent extends ActorComponent { 
	HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDTrackingInitializedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDLostDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDReconnectedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDConnectCanceledDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDPutOnHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRemovedFromHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	VRControllerRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): VRNotificationsComponent;
	static Find(Outer: UObject, ResourceName: string): VRNotificationsComponent;
	static GetDefaultObject(): VRNotificationsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRNotificationsComponent;
	static C(Other: UObject | any): VRNotificationsComponent;
}

declare class CookerStats extends UObject { 
	Assets: any[];
	SizeBefore: number;
	SizeAfter: number;
	Path: string;
	static Load(ResourceName: string): CookerStats;
	static Find(Outer: UObject, ResourceName: string): CookerStats;
	static GetDefaultObject(): CookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerStats;
	static C(Other: UObject | any): CookerStats;
}

declare class LightingBuildInfo extends UObject { 
	UObject: any;
	LightingTime: number;
	UnmappedTexelsPercentage: number;
	UnmappedTexelsMemory: number;
	TotalTexelMemory: number;
	LevelName: string;
	static Load(ResourceName: string): LightingBuildInfo;
	static Find(Outer: UObject, ResourceName: string): LightingBuildInfo;
	static GetDefaultObject(): LightingBuildInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightingBuildInfo;
	static C(Other: UObject | any): LightingBuildInfo;
}

declare class PrimitiveStats extends UObject { 
	UObject: any;
	Actors: any[];
	Type: string;
	Count: number;
	Sections: number;
	InstSections: number;
	Triangles: number;
	InstTriangles: number;
	ResourceSize: number;
	VertexColorMem: number;
	InstVertexColorMem: number;
	LightsLM: number;
	LightsOther: number;
	LightsTotal: number;
	ObjLightCost: number;
	LightMapData: number;
	LMSMResolution: number;
	RadiusMin: number;
	RadiusMax: number;
	RadiusAvg: number;
	static Load(ResourceName: string): PrimitiveStats;
	static Find(Outer: UObject, ResourceName: string): PrimitiveStats;
	static GetDefaultObject(): PrimitiveStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveStats;
	static C(Other: UObject | any): PrimitiveStats;
}

declare class StaticMeshLightingInfo extends UObject { 
	StaticMeshActor: any;
	StaticMesh: any;
	LevelName: string;
	TextureMapping: string;
	bTextureMapping: boolean;
	bHasLightmapTexCoords: boolean;
	StaticLightingResolution: number;
	TextureLightMapMemoryUsage: number;
	VertexLightMapMemoryUsage: number;
	LightMapLightCount: number;
	TextureShadowMapMemoryUsage: number;
	VertexShadowMapMemoryUsage: number;
	ShadowMapLightCount: number;
	static Load(ResourceName: string): StaticMeshLightingInfo;
	static Find(Outer: UObject, ResourceName: string): StaticMeshLightingInfo;
	static GetDefaultObject(): StaticMeshLightingInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshLightingInfo;
	static C(Other: UObject | any): StaticMeshLightingInfo;
}

declare class TextureStats extends UObject { 
	Texture: any;
	Actors: any[];
	Type: string;
	MaxDim: Vector2D;
	CurrentDim: Vector2D;
	Format: EPixelFormat;
	Group: TextureGroup;
	LODBias: number;
	CurrentKB: number;
	FullyLoadedKB: number;
	NumUses: number;
	LastTimeRendered: number;
	Path: string;
	static Load(ResourceName: string): TextureStats;
	static Find(Outer: UObject, ResourceName: string): TextureStats;
	static GetDefaultObject(): TextureStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureStats;
	static C(Other: UObject | any): TextureStats;
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	ParameterStateId: Guid;
	static Load(ResourceName: string): MaterialInstanceConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceConstant;
	static GetDefaultObject(): MaterialInstanceConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	static C(Other: UObject | any): MaterialInstanceConstant;
	ClearAllMaterialInstanceParameters(): void;
	GetMaterialInstanceScalarParameterValue(ParameterName: string): number;
	GetMaterialInstanceTextureParameterValue(ParameterName: string): Texture;
	GetMaterialInstanceVectorParameterValue(ParameterName: string): LinearColor;
	SetMaterialInstanceParent(NewParent: MaterialInterface): void;
	SetMaterialInstanceScalarParameterValue(ParameterName: string,Value: number): boolean;
	SetMaterialInstanceTextureParameterValue(ParameterName: string,Value: Texture): boolean;
	SetMaterialInstanceVectorParameterValue(ParameterName: string,Value: LinearColor): boolean;
	UpdateMaterialInstance(): void;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string): number;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string): Texture;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string): LinearColor;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture): boolean;
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor): boolean;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
}

declare class MaterialEditingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MaterialEditingLibrary;
	static Find(Outer: UObject, ResourceName: string): MaterialEditingLibrary;
	static GetDefaultObject(): MaterialEditingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditingLibrary;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunction,PreviewMaterial: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number): boolean;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static RecompileMaterial(Material: Material): void;
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static GetNumMaterialExpressions(Material: Material): number;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string): LinearColor;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string): Texture;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string): number;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static C(Other: UObject | any): MaterialEditingLibrary;
}

declare class PreviewSceneProfile { 
	ProfileName: string;
	bSharedProfile: boolean;
	DirectionalLightIntensity: number;
	DirectionalLightColor: LinearColor;
	SkyLightIntensity: number;
	bRotateLightingRig: boolean;
	bShowEnvironment: boolean;
	bShowFloor: boolean;
	EnvironmentColor: LinearColor;
	EnvironmentIntensity: number;
	EnvironmentCubeMap: any;
	EnvironmentCubeMapPath: string;
	PostProcessingSettings: PostProcessSettings;
	bPostProcessingEnabled: boolean;
	LightingRigRotation: number;
	RotationSpeed: number;
	DirectionalLightRotation: Rotator;
	clone() : PreviewSceneProfile;
	static C(Other: UObject | any): PreviewSceneProfile;
}

declare class LocalProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): LocalProfiles;
	static Find(Outer: UObject, ResourceName: string): LocalProfiles;
	static GetDefaultObject(): LocalProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalProfiles;
	static C(Other: UObject | any): LocalProfiles;
}

declare class SharedProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): SharedProfiles;
	static Find(Outer: UObject, ResourceName: string): SharedProfiles;
	static GetDefaultObject(): SharedProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SharedProfiles;
	static C(Other: UObject | any): SharedProfiles;
}

declare class AssetViewerSettings extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): AssetViewerSettings;
	static Find(Outer: UObject, ResourceName: string): AssetViewerSettings;
	static GetDefaultObject(): AssetViewerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetViewerSettings;
	static C(Other: UObject | any): AssetViewerSettings;
}

declare class Manipulator extends Actor { 
	AssociatedComponent: SceneComponent;
	StaticMeshComponent: StaticMeshComponent;
	static GetDefaultObject(): Manipulator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Manipulator;
	static C(Other: UObject | any): Manipulator;
}

declare class GameplayTask_ClaimResource extends GameplayTask { 
	static Load(ResourceName: string): GameplayTask_ClaimResource;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_ClaimResource;
	static GetDefaultObject(): GameplayTask_ClaimResource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_ClaimResource;
	static C(Other: UObject | any): GameplayTask_ClaimResource;
}

declare class GameplayTask_SpawnActor extends GameplayTask { 
	Success: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	DidNotSpawn: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	ClassToSpawn: UnrealEngineClass;
	static Load(ResourceName: string): GameplayTask_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_SpawnActor;
	static GetDefaultObject(): GameplayTask_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_SpawnActor;
	FinishSpawningActor(WorldContextObject: UObject,SpawnedActor: Actor): void;
	BeginSpawningActor(WorldContextObject: UObject,SpawnedActor?: Actor): {SpawnedActor: Actor, $: boolean};
	static C(Other: UObject | any): GameplayTask_SpawnActor;
}

declare class GameplayTask_TimeLimitedExecution extends GameplayTask { 
	OnFinished: UnrealEngineMulticastDelegate<() => void>;
	OnTimeExpired: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): GameplayTask_TimeLimitedExecution;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_TimeLimitedExecution;
	static GetDefaultObject(): GameplayTask_TimeLimitedExecution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_TimeLimitedExecution;
	static C(Other: UObject | any): GameplayTask_TimeLimitedExecution;
}

declare class GameplayTask_WaitDelay extends GameplayTask { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): GameplayTask_WaitDelay;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_WaitDelay;
	static GetDefaultObject(): GameplayTask_WaitDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_WaitDelay;
	static C(Other: UObject | any): GameplayTask_WaitDelay;
}

declare class GameplayTaskOwnerInterface extends Interface { 
	static Load(ResourceName: string): GameplayTaskOwnerInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTaskOwnerInterface;
	static GetDefaultObject(): GameplayTaskOwnerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskOwnerInterface;
	static C(Other: UObject | any): GameplayTaskOwnerInterface;
}

declare class BlueprintGameplayTagLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintGameplayTagLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintGameplayTagLibrary;
	static GetDefaultObject(): BlueprintGameplayTagLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGameplayTagLibrary;
	static RemoveGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static NotEqual_TagTag(A: GameplayTag,B: string): boolean;
	static NotEqual_TagContainerTagContainer(A: GameplayTagContainer,B: string): boolean;
	static NotEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static NotEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static MatchesTag(TagOne: GameplayTag,TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	static MatchesAnyTags(TagOne: GameplayTag,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
	static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;
	static MakeGameplayTagContainerFromArray(GameplayTags: GameplayTag[]): GameplayTagContainer;
	static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;
	static HasTag(TagContainer: GameplayTagContainer,Tag: GameplayTag,bExactMatch: boolean): boolean;
	static HasAnyTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasAllTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static GetTagName(GameplayTag: GameplayTag): string;
	static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
	static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;
	static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
	static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: UObject,ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	static EqualEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static EqualEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer,TagQuery: GameplayTagQuery): boolean;
	static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer,GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	static AppendGameplayTagContainers(InOutTagContainer?: GameplayTagContainer,InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	static AddGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	static C(Other: UObject | any): BlueprintGameplayTagLibrary;
}

declare class GameplayTagAssetInterface extends Interface { 
	static Load(ResourceName: string): GameplayTagAssetInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTagAssetInterface;
	static GetDefaultObject(): GameplayTagAssetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagAssetInterface;
	HasMatchingGameplayTag(TagToCheck: GameplayTag): boolean;
	HasAnyMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
	HasAllMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
	GetOwnedGameplayTags(TagContainer?: GameplayTagContainer): {TagContainer: GameplayTagContainer};
	static C(Other: UObject | any): GameplayTagAssetInterface;
}

declare class EditableGameplayTagQueryExpression extends UObject { 
	static Load(ResourceName: string): EditableGameplayTagQueryExpression;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression;
	static GetDefaultObject(): EditableGameplayTagQueryExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression;
}

declare class EditableGameplayTagQuery extends UObject { 
	UserDescription: string;
	RootExpression: EditableGameplayTagQueryExpression;
	TagQueryExportText_Helper: GameplayTagQuery;
	static Load(ResourceName: string): EditableGameplayTagQuery;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQuery;
	static GetDefaultObject(): EditableGameplayTagQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQuery;
	static C(Other: UObject | any): EditableGameplayTagQuery;
}

declare class EditableGameplayTagQueryExpression_AnyTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AnyTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AllTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AllTagsMatch;
}

declare class EditableGameplayTagQueryExpression_NoTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_NoTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AnyExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AnyExprMatch;
}

declare class EditableGameplayTagQueryExpression_AllExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AllExprMatch;
}

declare class EditableGameplayTagQueryExpression_NoExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_NoExprMatch;
}

declare type EGameplayTagSourceType = 'Native' | 'DefaultTagList' | 'TagList' | 'DataTable' | 'Invalid';
declare var EGameplayTagSourceType : { Native:'Native',DefaultTagList:'DefaultTagList',TagList:'TagList',DataTable:'DataTable',Invalid:'Invalid', };
declare class TableRowBase { 
	clone() : TableRowBase;
	static C(Other: UObject | any): TableRowBase;
}

declare class GameplayTagTableRow extends TableRowBase { 
	Tag: string;
	DevComment: string;
	clone() : GameplayTagTableRow;
	static C(Other: UObject | any): GameplayTagTableRow;
}

declare class GameplayTagsList extends UObject { 
	ConfigFileName: string;
	GameplayTagList: GameplayTagTableRow[];
	static Load(ResourceName: string): GameplayTagsList;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsList;
	static GetDefaultObject(): GameplayTagsList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsList;
	static C(Other: UObject | any): GameplayTagsList;
}

declare class GameplayTagSource { 
	SourceName: string;
	SourceType: SourceType;
	SourceTagList: GameplayTagsList;
	clone() : GameplayTagSource;
	static C(Other: UObject | any): GameplayTagSource;
}

declare class DataTable extends UObject { 
	RowStruct: ScriptStruct;
	AssetImportData: AssetImportData;
	ImportPath: string;
	RowStructName: string;
	static Load(ResourceName: string): DataTable;
	static Find(Outer: UObject, ResourceName: string): DataTable;
	static GetDefaultObject(): DataTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataTable;
	static C(Other: UObject | any): DataTable;
	GetDataTableRowFromName(RowName: string,OutRow?: TableRowBase): {OutRow: TableRowBase, $: boolean};
	GetDataTableRowNames(OutRowNames?: string[]): {OutRowNames: string[]};
	static GetDataTableRowFromName(Table: DataTable,RowName: string,OutRow?: TableRowBase): {OutRow: TableRowBase, $: boolean};
	static GetDataTableRowNames(Table: DataTable,OutRowNames?: string[]): {OutRowNames: string[]};
}

declare class GameplayTagsManager extends UObject { 
	TagSources: GameplayTagSource[];
	GameplayTagTables: DataTable[];
	static Load(ResourceName: string): GameplayTagsManager;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsManager;
	static GetDefaultObject(): GameplayTagsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsManager;
	static C(Other: UObject | any): GameplayTagsManager;
}

declare class GameplayTagCategoryRemap { 
	BaseCategory: string;
	RemapCategories: string[];
	clone() : GameplayTagCategoryRemap;
	static C(Other: UObject | any): GameplayTagCategoryRemap;
}

declare class GameplayTagRedirect { 
	OldTagName: string;
	NewTagName: string;
	clone() : GameplayTagRedirect;
	static C(Other: UObject | any): GameplayTagRedirect;
}

declare class GameplayTagsSettings extends GameplayTagsList { 
	ImportTagsFromConfig: boolean;
	WarnOnInvalidTags: boolean;
	CategoryRemapping: GameplayTagCategoryRemap[];
	FastReplication: boolean;
	GameplayTagTableList: SoftObjectPath[];
	GameplayTagRedirects: GameplayTagRedirect[];
	CommonlyReplicatedTags: string[];
	NumBitsForContainerSize: number;
	NetIndexFirstBitSegment: number;
	static Load(ResourceName: string): GameplayTagsSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsSettings;
	static GetDefaultObject(): GameplayTagsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsSettings;
	static C(Other: UObject | any): GameplayTagsSettings;
}

declare class GameplayTagsDeveloperSettings extends UObject { 
	DeveloperConfigName: string;
	static Load(ResourceName: string): GameplayTagsDeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsDeveloperSettings;
	static GetDefaultObject(): GameplayTagsDeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsDeveloperSettings;
	static C(Other: UObject | any): GameplayTagsDeveloperSettings;
}

declare class GameplayDebuggerNetPack { 
	clone() : GameplayDebuggerNetPack;
	static C(Other: UObject | any): GameplayDebuggerNetPack;
}

declare class GameplayDebuggerDebugActor { 
	Actor: Actor;
	ActorName: string;
	SyncCounter: number;
	clone() : GameplayDebuggerDebugActor;
	static C(Other: UObject | any): GameplayDebuggerDebugActor;
}

declare class GameplayDebuggerRenderingComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): GameplayDebuggerRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerRenderingComponent;
	static GetDefaultObject(): GameplayDebuggerRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerRenderingComponent;
	static C(Other: UObject | any): GameplayDebuggerRenderingComponent;
}

declare class GameplayDebuggerCategoryReplicator extends Actor { 
	OwnerPC: PlayerController;
	bIsEnabled: boolean;
	ReplicatedData: GameplayDebuggerNetPack;
	DebugActor: GameplayDebuggerDebugActor;
	RenderingComp: GameplayDebuggerRenderingComponent;
	static GetDefaultObject(): GameplayDebuggerCategoryReplicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerCategoryReplicator;
	ServerSetEnabled(bEnable: boolean): void;
	ServerSetDebugActor(Actor: Actor): void;
	ServerSetCategoryEnabled(CategoryId: number,bEnable: boolean): void;
	ServerSendExtensionInputEvent(ExtensionId: number,HandlerId: number): void;
	ServerSendCategoryInputEvent(CategoryId: number,HandlerId: number): void;
	static C(Other: UObject | any): GameplayDebuggerCategoryReplicator;
}

declare type EGameplayDebuggerOverrideMode = 'Enable' | 'Disable' | 'UseDefault';
declare var EGameplayDebuggerOverrideMode : { Enable:'Enable',Disable:'Disable',UseDefault:'UseDefault', };
declare class GameplayDebuggerInputConfig { 
	ConfigName: string;
	Key: Key;
	bModShift: boolean;
	bModCtrl: boolean;
	bModAlt: boolean;
	bModCmd: boolean;
	clone() : GameplayDebuggerInputConfig;
	static C(Other: UObject | any): GameplayDebuggerInputConfig;
}

declare class GameplayDebuggerCategoryConfig { 
	CategoryName: string;
	SlotIdx: number;
	ActiveInGame: ActiveInGame;
	ActiveInSimulate: ActiveInSimulate;
	Hidden: Hidden;
	bOverrideSlotIdx: boolean;
	InputHandlers: GameplayDebuggerInputConfig[];
	clone() : GameplayDebuggerCategoryConfig;
	static C(Other: UObject | any): GameplayDebuggerCategoryConfig;
}

declare class GameplayDebuggerExtensionConfig { 
	ExtensionName: string;
	UseExtension: UseExtension;
	InputHandlers: GameplayDebuggerInputConfig[];
	clone() : GameplayDebuggerExtensionConfig;
	static C(Other: UObject | any): GameplayDebuggerExtensionConfig;
}

declare class GameplayDebuggerConfig extends UObject { 
	ActivationKey: Key;
	CategoryRowNextKey: Key;
	CategoryRowPrevKey: Key;
	CategorySlot0: Key;
	CategorySlot1: Key;
	CategorySlot2: Key;
	CategorySlot3: Key;
	CategorySlot4: Key;
	CategorySlot5: Key;
	CategorySlot6: Key;
	CategorySlot7: Key;
	CategorySlot8: Key;
	CategorySlot9: Key;
	DebugCanvasPaddingLeft: number;
	DebugCanvasPaddingRight: number;
	DebugCanvasPaddingTop: number;
	DebugCanvasPaddingBottom: number;
	Categories: GameplayDebuggerCategoryConfig[];
	Extensions: GameplayDebuggerExtensionConfig[];
	static Load(ResourceName: string): GameplayDebuggerConfig;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerConfig;
	static GetDefaultObject(): GameplayDebuggerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerConfig;
	static C(Other: UObject | any): GameplayDebuggerConfig;
}

declare class GameplayDebuggerPlayerData { 
	Controller: GameplayDebuggerLocalController;
	InputComponent: InputComponent;
	Replicator: GameplayDebuggerCategoryReplicator;
	clone() : GameplayDebuggerPlayerData;
	static C(Other: UObject | any): GameplayDebuggerPlayerData;
}

declare class GameplayDebuggerPlayerManager extends Actor { 
	PlayerData: GameplayDebuggerPlayerData[];
	PendingRegistrations: GameplayDebuggerCategoryReplicator[];
	static GetDefaultObject(): GameplayDebuggerPlayerManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerPlayerManager;
	static C(Other: UObject | any): GameplayDebuggerPlayerManager;
}

declare class GameplayDebuggerLocalController extends UObject { 
	CachedReplicator: GameplayDebuggerCategoryReplicator;
	CachedPlayerManager: GameplayDebuggerPlayerManager;
	DebugActorCandidate: Actor;
	static Load(ResourceName: string): GameplayDebuggerLocalController;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerLocalController;
	static GetDefaultObject(): GameplayDebuggerLocalController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerLocalController;
	static C(Other: UObject | any): GameplayDebuggerLocalController;
}

declare class AIBlueprintHelperLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AIBlueprintHelperLibrary;
	static Find(Outer: UObject, ResourceName: string): AIBlueprintHelperLibrary;
	static GetDefaultObject(): AIBlueprintHelperLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIBlueprintHelperLibrary;
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean): Pawn;
	static SendAIMessage(Target: Pawn,Message: string,MessageSource: UObject,bSuccess: boolean): void;
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static GetCurrentPath(Controller: Controller): NavigationPath;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static GetAIController(ControlledActor: Actor): AIController;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): AIBlueprintHelperLibrary;
}

declare class AIDataProvider extends UObject { 
	static Load(ResourceName: string): AIDataProvider;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider;
	static GetDefaultObject(): AIDataProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider;
	static C(Other: UObject | any): AIDataProvider;
}

declare class AIDataProvider_QueryParams extends AIDataProvider { 
	ParamName: string;
	FloatValue: number;
	IntValue: number;
	BoolValue: boolean;
	static Load(ResourceName: string): AIDataProvider_QueryParams;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider_QueryParams;
	static GetDefaultObject(): AIDataProvider_QueryParams;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_QueryParams;
	static C(Other: UObject | any): AIDataProvider_QueryParams;
}

declare class AIDataProvider_Random extends AIDataProvider_QueryParams { 
	Min: number;
	Max: number;
	bInteger: boolean;
	static Load(ResourceName: string): AIDataProvider_Random;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider_Random;
	static GetDefaultObject(): AIDataProvider_Random;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_Random;
	static C(Other: UObject | any): AIDataProvider_Random;
}

declare class AIHotSpotManager extends UObject { 
	static Load(ResourceName: string): AIHotSpotManager;
	static Find(Outer: UObject, ResourceName: string): AIHotSpotManager;
	static GetDefaultObject(): AIHotSpotManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIHotSpotManager;
	static C(Other: UObject | any): AIHotSpotManager;
}

declare class AIPerceptionListenerInterface extends Interface { 
	static Load(ResourceName: string): AIPerceptionListenerInterface;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionListenerInterface;
	static GetDefaultObject(): AIPerceptionListenerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionListenerInterface;
	static C(Other: UObject | any): AIPerceptionListenerInterface;
}

declare class AIPerceptionStimuliSourceComponent extends ActorComponent { 
	bAutoRegisterAsSource: boolean;
	RegisterAsSourceForSenses: UnrealEngineClass[];
	static Load(ResourceName: string): AIPerceptionStimuliSourceComponent;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionStimuliSourceComponent;
	static GetDefaultObject(): AIPerceptionStimuliSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionStimuliSourceComponent;
	UnregisterFromSense(SenseClass: UnrealEngineClass): void;
	UnregisterFromPerceptionSystem(): void;
	RegisterWithPerceptionSystem(): void;
	RegisterForSense(SenseClass: UnrealEngineClass): void;
	static C(Other: UObject | any): AIPerceptionStimuliSourceComponent;
}

declare class AIResourceInterface extends Interface { 
	static Load(ResourceName: string): AIResourceInterface;
	static Find(Outer: UObject, ResourceName: string): AIResourceInterface;
	static GetDefaultObject(): AIResourceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResourceInterface;
	static C(Other: UObject | any): AIResourceInterface;
}

declare class AIResource_Movement extends GameplayTaskResource { 
	static Load(ResourceName: string): AIResource_Movement;
	static Find(Outer: UObject, ResourceName: string): AIResource_Movement;
	static GetDefaultObject(): AIResource_Movement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Movement;
	static C(Other: UObject | any): AIResource_Movement;
}

declare class AIResource_Logic extends GameplayTaskResource { 
	static Load(ResourceName: string): AIResource_Logic;
	static Find(Outer: UObject, ResourceName: string): AIResource_Logic;
	static GetDefaultObject(): AIResource_Logic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Logic;
	static C(Other: UObject | any): AIResource_Logic;
}

declare type EUserDefinedStructureStatus = 'UDSS_UpToDate' | 'UDSS_Dirty' | 'UDSS_Error' | 'UDSS_Duplicate';
declare var EUserDefinedStructureStatus : { UDSS_UpToDate:'UDSS_UpToDate',UDSS_Dirty:'UDSS_Dirty',UDSS_Error:'UDSS_Error',UDSS_Duplicate:'UDSS_Duplicate', };
declare class UserDefinedStruct extends ScriptStruct { 
	Status: EUserDefinedStructureStatus;
	PrimaryStruct: any;
	ErrorMessage: string;
	EditorData: UObject;
	Guid: Guid;
	static Load(ResourceName: string): UserDefinedStruct;
	static Find(Outer: UObject, ResourceName: string): UserDefinedStruct;
	static GetDefaultObject(): UserDefinedStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedStruct;
	static C(Other: UObject | any): UserDefinedStruct;
}

declare class AISense_Blueprint extends AISense { 
	ListenerDataType: UnrealEngineClass;
	ListenerContainer: AIPerceptionComponent[];
	UnprocessedEvents: AISenseEvent[];
	static Load(ResourceName: string): AISense_Blueprint;
	static Find(Outer: UObject, ResourceName: string): AISense_Blueprint;
	static GetDefaultObject(): AISense_Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Blueprint;
	OnUpdate(EventsToProcess: AISenseEvent[]): number;
	OnListenerUpdated(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerUnregistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerRegistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	K2_OnNewPawn(NewPawn: Pawn): void;
	GetAllListenerComponents(ListenerComponents?: AIPerceptionComponent[]): {ListenerComponents: AIPerceptionComponent[]};
	GetAllListenerActors(ListenerActors?: Actor[]): {ListenerActors: Actor[]};
	static C(Other: UObject | any): AISense_Blueprint;
}

declare class AIDamageEvent { 
	Amount: number;
	Location: Vector;
	HitLocation: Vector;
	DamagedActor: Actor;
	Instigator: Actor;
	clone() : AIDamageEvent;
	static C(Other: UObject | any): AIDamageEvent;
}

declare class AISense_Damage extends AISense { 
	RegisteredEvents: AIDamageEvent[];
	static Load(ResourceName: string): AISense_Damage;
	static Find(Outer: UObject, ResourceName: string): AISense_Damage;
	static GetDefaultObject(): AISense_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Damage;
	static ReportDamageEvent(WorldContextObject: UObject,DamagedActor: Actor,Instigator: Actor,DamageAmount: number,EventLocation: Vector,HitLocation: Vector): void;
	static C(Other: UObject | any): AISense_Damage;
}

declare class AINoiseEvent { 
	NoiseLocation: Vector;
	Loudness: number;
	MaxRange: number;
	Instigator: Actor;
	Tag: string;
	clone() : AINoiseEvent;
	static C(Other: UObject | any): AINoiseEvent;
}

declare class AISense_Hearing extends AISense { 
	NoiseEvents: AINoiseEvent[];
	SpeedOfSoundSq: number;
	static Load(ResourceName: string): AISense_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISense_Hearing;
	static GetDefaultObject(): AISense_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Hearing;
	static ReportNoiseEvent(WorldContextObject: UObject,NoiseLocation: Vector,Loudness: number,Instigator: Actor,MaxRange: number,Tag: string): void;
	static C(Other: UObject | any): AISense_Hearing;
}

declare class AIPredictionEvent { 
	Requestor: Actor;
	PredictedActor: Actor;
	clone() : AIPredictionEvent;
	static C(Other: UObject | any): AIPredictionEvent;
}

declare class AISense_Prediction extends AISense { 
	RegisteredEvents: AIPredictionEvent[];
	static Load(ResourceName: string): AISense_Prediction;
	static Find(Outer: UObject, ResourceName: string): AISense_Prediction;
	static GetDefaultObject(): AISense_Prediction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Prediction;
	static RequestPawnPredictionEvent(Requestor: Pawn,PredictedActor: Actor,PredictionTime: number): void;
	static RequestControllerPredictionEvent(Requestor: AIController,PredictedActor: Actor,PredictionTime: number): void;
	static C(Other: UObject | any): AISense_Prediction;
}

declare class AISense_Sight extends AISense { 
	MaxTracesPerTick: number;
	MinQueriesPerTimeSliceCheck: number;
	MaxTimeSlicePerTick: any;
	HighImportanceQueryDistanceThreshold: number;
	MaxQueryImportance: number;
	SightLimitQueryImportance: number;
	static Load(ResourceName: string): AISense_Sight;
	static Find(Outer: UObject, ResourceName: string): AISense_Sight;
	static GetDefaultObject(): AISense_Sight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Sight;
	static C(Other: UObject | any): AISense_Sight;
}

declare class AITeamStimulusEvent { 
	Broadcaster: Actor;
	Enemy: Actor;
	clone() : AITeamStimulusEvent;
	static C(Other: UObject | any): AITeamStimulusEvent;
}

declare class AISense_Team extends AISense { 
	RegisteredEvents: AITeamStimulusEvent[];
	static Load(ResourceName: string): AISense_Team;
	static Find(Outer: UObject, ResourceName: string): AISense_Team;
	static GetDefaultObject(): AISense_Team;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Team;
	static C(Other: UObject | any): AISense_Team;
}

declare class AITouchEvent { 
	TouchReceiver: Actor;
	OtherActor: Actor;
	clone() : AITouchEvent;
	static C(Other: UObject | any): AITouchEvent;
}

declare class AISense_Touch extends AISense { 
	RegisteredEvents: AITouchEvent[];
	static Load(ResourceName: string): AISense_Touch;
	static Find(Outer: UObject, ResourceName: string): AISense_Touch;
	static GetDefaultObject(): AISense_Touch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Touch;
	static C(Other: UObject | any): AISense_Touch;
}

declare class AISenseBlueprintListener extends UserDefinedStruct { 
	static Load(ResourceName: string): AISenseBlueprintListener;
	static Find(Outer: UObject, ResourceName: string): AISenseBlueprintListener;
	static GetDefaultObject(): AISenseBlueprintListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseBlueprintListener;
	static C(Other: UObject | any): AISenseBlueprintListener;
}

declare class AISenseConfig_Blueprint extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	static Load(ResourceName: string): AISenseConfig_Blueprint;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Blueprint;
	static GetDefaultObject(): AISenseConfig_Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Blueprint;
	static C(Other: UObject | any): AISenseConfig_Blueprint;
}

declare class AISenseConfig_Damage extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	static Load(ResourceName: string): AISenseConfig_Damage;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Damage;
	static GetDefaultObject(): AISenseConfig_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Damage;
	static C(Other: UObject | any): AISenseConfig_Damage;
}

declare class AISenseAffiliationFilter { 
	bDetectEnemies: boolean;
	bDetectNeutrals: boolean;
	bDetectFriendlies: boolean;
	clone() : AISenseAffiliationFilter;
	static C(Other: UObject | any): AISenseAffiliationFilter;
}

declare class AISenseConfig_Hearing extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	HearingRange: number;
	LoSHearingRange: number;
	bUseLoSHearing: boolean;
	DetectionByAffiliation: AISenseAffiliationFilter;
	static Load(ResourceName: string): AISenseConfig_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Hearing;
	static GetDefaultObject(): AISenseConfig_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Hearing;
	static C(Other: UObject | any): AISenseConfig_Hearing;
}

declare class AISenseConfig_Prediction extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Prediction;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Prediction;
	static GetDefaultObject(): AISenseConfig_Prediction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Prediction;
	static C(Other: UObject | any): AISenseConfig_Prediction;
}

declare class AISenseConfig_Sight extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	SightRadius: number;
	LoseSightRadius: number;
	PeripheralVisionAngleDegrees: number;
	DetectionByAffiliation: AISenseAffiliationFilter;
	AutoSuccessRangeFromLastSeenLocation: number;
	static Load(ResourceName: string): AISenseConfig_Sight;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Sight;
	static GetDefaultObject(): AISenseConfig_Sight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Sight;
	static C(Other: UObject | any): AISenseConfig_Sight;
}

declare class AISenseConfig_Team extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Team;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Team;
	static GetDefaultObject(): AISenseConfig_Team;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Team;
	static C(Other: UObject | any): AISenseConfig_Team;
}

declare class AISenseConfig_Touch extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Touch;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Touch;
	static GetDefaultObject(): AISenseConfig_Touch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Touch;
	static C(Other: UObject | any): AISenseConfig_Touch;
}

declare class AISenseEvent_Damage extends AISenseEvent { 
	Event: AIDamageEvent;
	static Load(ResourceName: string): AISenseEvent_Damage;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent_Damage;
	static GetDefaultObject(): AISenseEvent_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Damage;
	static C(Other: UObject | any): AISenseEvent_Damage;
}

declare class AISenseEvent_Hearing extends AISenseEvent { 
	Event: AINoiseEvent;
	static Load(ResourceName: string): AISenseEvent_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent_Hearing;
	static GetDefaultObject(): AISenseEvent_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Hearing;
	static C(Other: UObject | any): AISenseEvent_Hearing;
}

declare class AISightTargetInterface extends Interface { 
	static Load(ResourceName: string): AISightTargetInterface;
	static Find(Outer: UObject, ResourceName: string): AISightTargetInterface;
	static GetDefaultObject(): AISightTargetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISightTargetInterface;
	static C(Other: UObject | any): AISightTargetInterface;
}

declare class BehaviorTreeTemplateInfo { 
	Asset: BehaviorTree;
	Template: BTCompositeNode;
	clone() : BehaviorTreeTemplateInfo;
	static C(Other: UObject | any): BehaviorTreeTemplateInfo;
}

declare class BehaviorTreeManager extends UObject { 
	MaxDebuggerSteps: number;
	LoadedTemplates: BehaviorTreeTemplateInfo[];
	ActiveComponents: BehaviorTreeComponent[];
	static Load(ResourceName: string): BehaviorTreeManager;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeManager;
	static GetDefaultObject(): BehaviorTreeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeManager;
	static C(Other: UObject | any): BehaviorTreeManager;
}

declare class EnvQueryNode extends UObject { 
	VerNum: number;
	static Load(ResourceName: string): EnvQueryNode;
	static Find(Outer: UObject, ResourceName: string): EnvQueryNode;
	static GetDefaultObject(): EnvQueryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryNode;
	static C(Other: UObject | any): EnvQueryNode;
}

declare class EnvQueryItemType extends UObject { 
	static Load(ResourceName: string): EnvQueryItemType;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType;
	static GetDefaultObject(): EnvQueryItemType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType;
	static C(Other: UObject | any): EnvQueryItemType;
}

declare class EnvQueryGenerator extends EnvQueryNode { 
	OptionName: string;
	ItemType: UnrealEngineClass;
	bAutoSortTests: boolean;
	static Load(ResourceName: string): EnvQueryGenerator;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator;
	static GetDefaultObject(): EnvQueryGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator;
	static C(Other: UObject | any): EnvQueryGenerator;
}

declare type EEnvTestPurpose = 'Filter' | 'Score' | 'FilterAndScore';
declare var EEnvTestPurpose : { Filter:'Filter',Score:'Score',FilterAndScore:'FilterAndScore', };
declare type EEnvTestFilterOperator = 'AllPass' | 'AnyPass';
declare var EEnvTestFilterOperator : { AllPass:'AllPass',AnyPass:'AnyPass', };
declare type EEnvTestScoreOperator = 'AverageScore' | 'MinScore' | 'MaxScore';
declare var EEnvTestScoreOperator : { AverageScore:'AverageScore',MinScore:'MinScore',MaxScore:'MaxScore', };
declare type EEnvTestFilterType = 'Minimum' | 'Maximum' | 'Range' | 'Match';
declare var EEnvTestFilterType : { Minimum:'Minimum',Maximum:'Maximum',Range:'Range',Match:'Match', };
declare class AIDataProviderValue { 
	CachedProperty: Property;
	DataBinding: AIDataProvider;
	DataField: string;
	clone() : AIDataProviderValue;
	static C(Other: UObject | any): AIDataProviderValue;
}

declare class AIDataProviderTypedValue extends AIDataProviderValue { 
	PropertyType: UnrealEngineClass;
	clone() : AIDataProviderTypedValue;
	static C(Other: UObject | any): AIDataProviderTypedValue;
}

declare class AIDataProviderBoolValue extends AIDataProviderTypedValue { 
	DefaultValue: boolean;
	clone() : AIDataProviderBoolValue;
	static C(Other: UObject | any): AIDataProviderBoolValue;
}

declare class AIDataProviderFloatValue extends AIDataProviderTypedValue { 
	DefaultValue: number;
	clone() : AIDataProviderFloatValue;
	static C(Other: UObject | any): AIDataProviderFloatValue;
}

declare type EEnvTestScoreEquation = 'Linear' | 'Square' | 'InverseLinear' | 'SquareRoot' | 'Constant';
declare var EEnvTestScoreEquation : { Linear:'Linear',Square:'Square',InverseLinear:'InverseLinear',SquareRoot:'SquareRoot',Constant:'Constant', };
declare type EEnvQueryTestClamping = 'None' | 'SpecifiedValue' | 'FilterThreshold';
declare var EEnvQueryTestClamping : { None:'None',SpecifiedValue:'SpecifiedValue',FilterThreshold:'FilterThreshold', };
declare type EEQSNormalizationType = 'Absolute' | 'RelativeToScores';
declare var EEQSNormalizationType : { Absolute:'Absolute',RelativeToScores:'RelativeToScores', };
declare class EnvQueryTest extends EnvQueryNode { 
	TestOrder: number;
	TestPurpose: EEnvTestPurpose;
	TestComment: string;
	MultipleContextFilterOp: EEnvTestFilterOperator;
	MultipleContextScoreOp: EEnvTestScoreOperator;
	FilterType: EEnvTestFilterType;
	BoolValue: AIDataProviderBoolValue;
	FloatValueMin: AIDataProviderFloatValue;
	FloatValueMax: AIDataProviderFloatValue;
	ScoringEquation: EEnvTestScoreEquation;
	ClampMinType: EEnvQueryTestClamping;
	ClampMaxType: EEnvQueryTestClamping;
	NormalizationType: NormalizationType;
	ScoreClampMin: AIDataProviderFloatValue;
	ScoreClampMax: AIDataProviderFloatValue;
	ScoringFactor: AIDataProviderFloatValue;
	ReferenceValue: AIDataProviderFloatValue;
	bDefineReferenceValue: boolean;
	bWorkOnFloatValues: boolean;
	static Load(ResourceName: string): EnvQueryTest;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest;
	static GetDefaultObject(): EnvQueryTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest;
	static C(Other: UObject | any): EnvQueryTest;
}

declare class EnvQueryOption extends UObject { 
	Generator: EnvQueryGenerator;
	Tests: EnvQueryTest[];
	static Load(ResourceName: string): EnvQueryOption;
	static Find(Outer: UObject, ResourceName: string): EnvQueryOption;
	static GetDefaultObject(): EnvQueryOption;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryOption;
	static C(Other: UObject | any): EnvQueryOption;
}

declare class EnvQuery extends DataAsset { 
	EdGraph: EdGraph;
	QueryName: string;
	Options: EnvQueryOption[];
	static Load(ResourceName: string): EnvQuery;
	static Find(Outer: UObject, ResourceName: string): EnvQuery;
	static GetDefaultObject(): EnvQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQuery;
	static C(Other: UObject | any): EnvQuery;
}

declare class EnvQueryInstanceCache { 
	Template: EnvQuery;
	clone() : EnvQueryInstanceCache;
	static C(Other: UObject | any): EnvQueryInstanceCache;
}

declare class EnvQueryContext extends UObject { 
	static Load(ResourceName: string): EnvQueryContext;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext;
	static GetDefaultObject(): EnvQueryContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext;
	static C(Other: UObject | any): EnvQueryContext;
}

declare type EEnvQueryStatus = 'Processing' | 'Success' | 'Failed' | 'Aborted' | 'OwnerLost' | 'MissingParam';
declare var EEnvQueryStatus : { Processing:'Processing',Success:'Success',Failed:'Failed',Aborted:'Aborted',OwnerLost:'OwnerLost',MissingParam:'MissingParam', };
declare class EnvQueryInstanceBlueprintWrapper extends UObject { 
	QueryID: number;
	ItemType: UnrealEngineClass;
	OptionIndex: number;
	OnQueryFinishedEvent: UnrealEngineMulticastDelegate<(QueryInstance: EnvQueryInstanceBlueprintWrapper, QueryStatus: EEnvQueryStatus) => void>;
	static Load(ResourceName: string): EnvQueryInstanceBlueprintWrapper;
	static Find(Outer: UObject, ResourceName: string): EnvQueryInstanceBlueprintWrapper;
	static GetDefaultObject(): EnvQueryInstanceBlueprintWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryInstanceBlueprintWrapper;
	SetNamedParam(ParamName: string,Value: number): void;
	GetResultsAsLocations(): Vector[];
	GetResultsAsActors(): Actor[];
	GetItemScore(ItemIndex: number): number;
	static C(Other: UObject | any): EnvQueryInstanceBlueprintWrapper;
}

declare type EEnvQueryRunMode = 'SingleResult' | 'RandomBest5Pct' | 'RandomBest25Pct' | 'AllMatching';
declare var EEnvQueryRunMode : { SingleResult:'SingleResult',RandomBest5Pct:'RandomBest5Pct',RandomBest25Pct:'RandomBest25Pct',AllMatching:'AllMatching', };
declare class EnvQueryManager extends UObject { 
	InstanceCache: EnvQueryInstanceCache[];
	LocalContexts: EnvQueryContext[];
	GCShieldedWrappers: EnvQueryInstanceBlueprintWrapper[];
	MaxAllowedTestingTime: number;
	bTestQueriesUsingBreadth: boolean;
	QueryCountWarningThreshold: number;
	QueryCountWarningInterval: any;
	static Load(ResourceName: string): EnvQueryManager;
	static Find(Outer: UObject, ResourceName: string): EnvQueryManager;
	static GetDefaultObject(): EnvQueryManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryManager;
	static RunEQSQuery(WorldContextObject: UObject,QueryTemplate: EnvQuery,Querier: UObject,RunMode: EEnvQueryRunMode,WrapperClass: UnrealEngineClass): EnvQueryInstanceBlueprintWrapper;
	static C(Other: UObject | any): EnvQueryManager;
}

declare class NavLocalGridManager extends UObject { 
	static Load(ResourceName: string): NavLocalGridManager;
	static Find(Outer: UObject, ResourceName: string): NavLocalGridManager;
	static GetDefaultObject(): NavLocalGridManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLocalGridManager;
	static SetLocalNavigationGridDensity(WorldContextObject: UObject,CellSize: number): boolean;
	static RemoveLocalNavigationGrid(WorldContextObject: UObject,GridId: number,bRebuildGrids: boolean): void;
	static FindLocalNavigationGridPath(WorldContextObject: UObject,Start: Vector,End: Vector,PathPoints?: Vector[]): {PathPoints: Vector[], $: boolean};
	static AddLocalNavigationGridForPoints(WorldContextObject: UObject,Locations: Vector[],Radius2D: number,Height: number,bRebuildGrids: boolean): number;
	static AddLocalNavigationGridForPoint(WorldContextObject: UObject,Location: Vector,Radius2D: number,Height: number,bRebuildGrids: boolean): number;
	static AddLocalNavigationGridForCapsule(WorldContextObject: UObject,Location: Vector,CapsuleRadius: number,CapsuleHalfHeight: number,Radius2D: number,Height: number,bRebuildGrids: boolean): number;
	static AddLocalNavigationGridForBox(WorldContextObject: UObject,Location: Vector,Extent: Vector,Rotation: Rotator,Radius2D: number,Height: number,bRebuildGrids: boolean): number;
	static C(Other: UObject | any): NavLocalGridManager;
}

declare class AISystem extends AISystemBase { 
	PerceptionSystemClassName: SoftClassPath;
	HotSpotManagerClassName: SoftClassPath;
	AcceptanceRadius: number;
	PathfollowingRegularPathPointAcceptanceRadius: number;
	PathfollowingNavLinkAcceptanceRadius: number;
	bFinishMoveOnGoalOverlap: boolean;
	bAcceptPartialPaths: boolean;
	bAllowStrafing: boolean;
	bEnableBTAITasks: boolean;
	bAllowControllersAsEQSQuerier: boolean;
	bEnableDebuggerPlugin: boolean;
	DefaultSightCollisionChannel: ECollisionChannel;
	BehaviorTreeManager: BehaviorTreeManager;
	EnvironmentQueryManager: EnvQueryManager;
	PerceptionSystem: AIPerceptionSystem;
	AllProxyObjects: AIAsyncTaskBlueprintProxy[];
	HotSpotManager: AIHotSpotManager;
	NavLocalGrids: NavLocalGridManager;
	static Load(ResourceName: string): AISystem;
	static Find(Outer: UObject, ResourceName: string): AISystem;
	static GetDefaultObject(): AISystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISystem;
	AILoggingVerbose(): void;
	AIIgnorePlayers(): void;
	static C(Other: UObject | any): AISystem;
}

declare class AITask extends GameplayTask { 
	OwnerController: AIController;
	static Load(ResourceName: string): AITask;
	static Find(Outer: UObject, ResourceName: string): AITask;
	static GetDefaultObject(): AITask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask;
	static C(Other: UObject | any): AITask;
}

declare class AITask_LockLogic extends AITask { 
	static Load(ResourceName: string): AITask_LockLogic;
	static Find(Outer: UObject, ResourceName: string): AITask_LockLogic;
	static GetDefaultObject(): AITask_LockLogic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_LockLogic;
	static C(Other: UObject | any): AITask_LockLogic;
}

declare class AIMoveRequest { 
	GoalActor: Actor;
	clone() : AIMoveRequest;
	static C(Other: UObject | any): AIMoveRequest;
}

declare type EAIOptionFlag = 'Default' | 'Enable' | 'Disable';
declare var EAIOptionFlag : { Default:'Default',Enable:'Enable',Disable:'Disable', };
declare class AITask_MoveTo extends AITask { 
	OnRequestFailed: UnrealEngineMulticastDelegate<() => void>;
	OnMoveFinished: UnrealEngineMulticastDelegate<(Result: EPathFollowingResult, AIController: AIController) => void>;
	MoveRequest: AIMoveRequest;
	static Load(ResourceName: string): AITask_MoveTo;
	static Find(Outer: UObject, ResourceName: string): AITask_MoveTo;
	static GetDefaultObject(): AITask_MoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_MoveTo;
	static AIMoveTo(Controller: AIController,GoalLocation: Vector,GoalActor: Actor,AcceptanceRadius: number,StopOnOverlap: EAIOptionFlag,AcceptPartialPath: EAIOptionFlag,bUsePathfinding: boolean,bLockAILogic: boolean,bUseContinuosGoalTracking: boolean): AITask_MoveTo;
	static C(Other: UObject | any): AITask_MoveTo;
}

declare class AITask_RunEQS extends AITask { 
	static Load(ResourceName: string): AITask_RunEQS;
	static Find(Outer: UObject, ResourceName: string): AITask_RunEQS;
	static GetDefaultObject(): AITask_RunEQS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_RunEQS;
	static RunEQS(Controller: AIController,QueryTemplate: EnvQuery): AITask_RunEQS;
	static C(Other: UObject | any): AITask_RunEQS;
}

declare class BehaviorTreeTypes extends UObject { 
	static Load(ResourceName: string): BehaviorTreeTypes;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeTypes;
	static GetDefaultObject(): BehaviorTreeTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeTypes;
	static C(Other: UObject | any): BehaviorTreeTypes;
}

declare class BlackboardKeyType_Bool extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Bool;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Bool;
	static GetDefaultObject(): BlackboardKeyType_Bool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Bool;
	static C(Other: UObject | any): BlackboardKeyType_Bool;
}

declare class BlackboardKeyType_Class extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	static Load(ResourceName: string): BlackboardKeyType_Class;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Class;
	static GetDefaultObject(): BlackboardKeyType_Class;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Class;
	static C(Other: UObject | any): BlackboardKeyType_Class;
}

declare class BlackboardKeyType_Enum extends BlackboardKeyType { 
	EnumType: Enum;
	EnumName: string;
	bIsEnumNameValid: boolean;
	static Load(ResourceName: string): BlackboardKeyType_Enum;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Enum;
	static GetDefaultObject(): BlackboardKeyType_Enum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Enum;
	static C(Other: UObject | any): BlackboardKeyType_Enum;
}

declare class BlackboardKeyType_Float extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Float;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Float;
	static GetDefaultObject(): BlackboardKeyType_Float;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Float;
	static C(Other: UObject | any): BlackboardKeyType_Float;
}

declare class BlackboardKeyType_Int extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Int;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Int;
	static GetDefaultObject(): BlackboardKeyType_Int;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Int;
	static C(Other: UObject | any): BlackboardKeyType_Int;
}

declare class BlackboardKeyType_Name extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Name;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Name;
	static GetDefaultObject(): BlackboardKeyType_Name;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Name;
	static C(Other: UObject | any): BlackboardKeyType_Name;
}

declare class BlackboardKeyType_NativeEnum extends BlackboardKeyType { 
	EnumName: string;
	EnumType: Enum;
	static Load(ResourceName: string): BlackboardKeyType_NativeEnum;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_NativeEnum;
	static GetDefaultObject(): BlackboardKeyType_NativeEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_NativeEnum;
	static C(Other: UObject | any): BlackboardKeyType_NativeEnum;
}

declare class BlackboardKeyType_Object extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	static Load(ResourceName: string): BlackboardKeyType_Object;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Object;
	static GetDefaultObject(): BlackboardKeyType_Object;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Object;
	static C(Other: UObject | any): BlackboardKeyType_Object;
}

declare class BlackboardKeyType_Rotator extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Rotator;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Rotator;
	static GetDefaultObject(): BlackboardKeyType_Rotator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Rotator;
	static C(Other: UObject | any): BlackboardKeyType_Rotator;
}

declare class BlackboardKeyType_String extends BlackboardKeyType { 
	StringValue: string;
	static Load(ResourceName: string): BlackboardKeyType_String;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_String;
	static GetDefaultObject(): BlackboardKeyType_String;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_String;
	static C(Other: UObject | any): BlackboardKeyType_String;
}

declare class BlackboardKeyType_Vector extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Vector;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Vector;
	static GetDefaultObject(): BlackboardKeyType_Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Vector;
	static C(Other: UObject | any): BlackboardKeyType_Vector;
}

declare class BTComposite_Selector extends BTCompositeNode { 
	static Load(ResourceName: string): BTComposite_Selector;
	static Find(Outer: UObject, ResourceName: string): BTComposite_Selector;
	static GetDefaultObject(): BTComposite_Selector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Selector;
	static C(Other: UObject | any): BTComposite_Selector;
}

declare class BTComposite_Sequence extends BTCompositeNode { 
	static Load(ResourceName: string): BTComposite_Sequence;
	static Find(Outer: UObject, ResourceName: string): BTComposite_Sequence;
	static GetDefaultObject(): BTComposite_Sequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Sequence;
	static C(Other: UObject | any): BTComposite_Sequence;
}

declare type EBTParallelMode = 'AbortBackground' | 'WaitForBackground';
declare var EBTParallelMode : { AbortBackground:'AbortBackground',WaitForBackground:'WaitForBackground', };
declare class BTComposite_SimpleParallel extends BTCompositeNode { 
	FinishMode: EBTParallelMode;
	static Load(ResourceName: string): BTComposite_SimpleParallel;
	static Find(Outer: UObject, ResourceName: string): BTComposite_SimpleParallel;
	static GetDefaultObject(): BTComposite_SimpleParallel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_SimpleParallel;
	static C(Other: UObject | any): BTComposite_SimpleParallel;
}

declare class BTDecorator_BlackboardBase extends BTDecorator { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_BlackboardBase;
	static GetDefaultObject(): BTDecorator_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlackboardBase;
	static C(Other: UObject | any): BTDecorator_BlackboardBase;
}

declare type EBTBlackboardRestart = 'ValueChange' | 'ResultChange';
declare var EBTBlackboardRestart : { ValueChange:'ValueChange',ResultChange:'ResultChange', };
declare type EBasicKeyOperation = 'Set' | 'NotSet';
declare var EBasicKeyOperation : { Set:'Set',NotSet:'NotSet', };
declare type EArithmeticKeyOperation = 'Equal' | 'NotEqual' | 'Less' | 'LessOrEqual' | 'Greater' | 'GreaterOrEqual';
declare var EArithmeticKeyOperation : { Equal:'Equal',NotEqual:'NotEqual',Less:'Less',LessOrEqual:'LessOrEqual',Greater:'Greater',GreaterOrEqual:'GreaterOrEqual', };
declare type ETextKeyOperation = 'Equal' | 'NotEqual' | 'Contain' | 'NotContain';
declare var ETextKeyOperation : { Equal:'Equal',NotEqual:'NotEqual',Contain:'Contain',NotContain:'NotContain', };
declare class BTDecorator_Blackboard extends BTDecorator_BlackboardBase { 
	IntValue: number;
	FloatValue: number;
	StringValue: string;
	CachedDescription: string;
	OperationType: number;
	NotifyObserver: EBTBlackboardRestart;
	BasicOperation: EBasicKeyOperation;
	ArithmeticOperation: EArithmeticKeyOperation;
	TextOperation: ETextKeyOperation;
	static Load(ResourceName: string): BTDecorator_Blackboard;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Blackboard;
	static GetDefaultObject(): BTDecorator_Blackboard;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Blackboard;
	static C(Other: UObject | any): BTDecorator_Blackboard;
}

declare type EBTNodeResult = 'Succeeded' | 'Failed' | 'Aborted' | 'InProgress';
declare var EBTNodeResult : { Succeeded:'Succeeded',Failed:'Failed',Aborted:'Aborted',InProgress:'InProgress', };
declare class BTDecorator_BlueprintBase extends BTDecorator { 
	AIOwner: AIController;
	ActorOwner: Actor;
	ObservedKeyNames: string[];
	bShowPropertyDetails: boolean;
	bCheckConditionOnlyBlackBoardChanges: boolean;
	bIsObservingBB: boolean;
	static Load(ResourceName: string): BTDecorator_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_BlueprintBase;
	static GetDefaultObject(): BTDecorator_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveObserverDeactivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverDeactivated(OwnerActor: Actor): void;
	ReceiveObserverActivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverActivated(OwnerActor: Actor): void;
	ReceiveExecutionStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecutionStart(OwnerActor: Actor): void;
	ReceiveExecutionFinishAI(OwnerController: AIController,ControlledPawn: Pawn,NodeResult: EBTNodeResult): void;
	ReceiveExecutionFinish(OwnerActor: Actor,NodeResult: EBTNodeResult): void;
	PerformConditionCheckAI(OwnerController: AIController,ControlledPawn: Pawn): boolean;
	PerformConditionCheck(OwnerActor: Actor): boolean;
	IsDecoratorObserverActive(): boolean;
	IsDecoratorExecutionActive(): boolean;
	static C(Other: UObject | any): BTDecorator_BlueprintBase;
}

declare type EGameplayContainerMatchType = 'Any' | 'All';
declare var EGameplayContainerMatchType : { Any:'Any',All:'All', };
declare class BTDecorator_CheckGameplayTagsOnActor extends BTDecorator { 
	ActorToCheck: BlackboardKeySelector;
	TagsToMatch: TagsToMatch;
	GameplayTags: GameplayTagContainer;
	CachedDescription: string;
	static Load(ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static GetDefaultObject(): BTDecorator_CheckGameplayTagsOnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CheckGameplayTagsOnActor;
	static C(Other: UObject | any): BTDecorator_CheckGameplayTagsOnActor;
}

declare type EBlackBoardEntryComparison = 'Equal' | 'NotEqual';
declare var EBlackBoardEntryComparison : { Equal:'Equal',NotEqual:'NotEqual', };
declare class BTDecorator_CompareBBEntries extends BTDecorator { 
	Operator: EBlackBoardEntryComparison;
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_CompareBBEntries;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_CompareBBEntries;
	static GetDefaultObject(): BTDecorator_CompareBBEntries;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CompareBBEntries;
	static C(Other: UObject | any): BTDecorator_CompareBBEntries;
}

declare class BTDecorator_ConditionalLoop extends BTDecorator_Blackboard { 
	static Load(ResourceName: string): BTDecorator_ConditionalLoop;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ConditionalLoop;
	static GetDefaultObject(): BTDecorator_ConditionalLoop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConditionalLoop;
	static C(Other: UObject | any): BTDecorator_ConditionalLoop;
}

declare class BTDecorator_ConeCheck extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	ConeDirection: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_ConeCheck;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ConeCheck;
	static GetDefaultObject(): BTDecorator_ConeCheck;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConeCheck;
	static C(Other: UObject | any): BTDecorator_ConeCheck;
}

declare class BTDecorator_Cooldown extends BTDecorator { 
	CoolDownTime: number;
	static Load(ResourceName: string): BTDecorator_Cooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Cooldown;
	static GetDefaultObject(): BTDecorator_Cooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Cooldown;
	static C(Other: UObject | any): BTDecorator_Cooldown;
}

declare type EPathExistanceQueryType = 'NavmeshRaycast2D' | 'HierarchicalQuery' | 'RegularPathFinding';
declare var EPathExistanceQueryType : { NavmeshRaycast2D:'NavmeshRaycast2D',HierarchicalQuery:'HierarchicalQuery',RegularPathFinding:'RegularPathFinding', };
declare class BTDecorator_DoesPathExist extends BTDecorator { 
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	bUseSelf: boolean;
	PathQueryType: EPathExistanceQueryType;
	FilterClass: UnrealEngineClass;
	static Load(ResourceName: string): BTDecorator_DoesPathExist;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_DoesPathExist;
	static GetDefaultObject(): BTDecorator_DoesPathExist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_DoesPathExist;
	static C(Other: UObject | any): BTDecorator_DoesPathExist;
}

declare class BTDecorator_ForceSuccess extends BTDecorator { 
	static Load(ResourceName: string): BTDecorator_ForceSuccess;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ForceSuccess;
	static GetDefaultObject(): BTDecorator_ForceSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ForceSuccess;
	static C(Other: UObject | any): BTDecorator_ForceSuccess;
}

declare type FAIDistanceType = 'Distance3D' | 'Distance2D' | 'DistanceZ';
declare var FAIDistanceType : { Distance3D:'Distance3D',Distance2D:'Distance2D',DistanceZ:'DistanceZ', };
declare class BTDecorator_IsAtLocation extends BTDecorator_BlackboardBase { 
	AcceptableRadius: number;
	ParametrizedAcceptableRadius: AIDataProviderFloatValue;
	GeometricDistanceType: GeometricDistanceType;
	bUseParametrizedRadius: boolean;
	bUseNavAgentGoalLocation: boolean;
	bPathFindingBasedTest: boolean;
	static Load(ResourceName: string): BTDecorator_IsAtLocation;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_IsAtLocation;
	static GetDefaultObject(): BTDecorator_IsAtLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsAtLocation;
	static C(Other: UObject | any): BTDecorator_IsAtLocation;
}

declare class BTDecorator_IsBBEntryOfClass extends BTDecorator_BlackboardBase { 
	TestClass: UnrealEngineClass;
	static Load(ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static GetDefaultObject(): BTDecorator_IsBBEntryOfClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsBBEntryOfClass;
	static C(Other: UObject | any): BTDecorator_IsBBEntryOfClass;
}

declare class BTDecorator_KeepInCone extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	bUseSelfAsOrigin: boolean;
	bUseSelfAsObserved: boolean;
	static Load(ResourceName: string): BTDecorator_KeepInCone;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_KeepInCone;
	static GetDefaultObject(): BTDecorator_KeepInCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_KeepInCone;
	static C(Other: UObject | any): BTDecorator_KeepInCone;
}

declare class BTDecorator_Loop extends BTDecorator { 
	NumLoops: number;
	bInfiniteLoop: boolean;
	InfiniteLoopTimeoutTime: number;
	static Load(ResourceName: string): BTDecorator_Loop;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Loop;
	static GetDefaultObject(): BTDecorator_Loop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Loop;
	static C(Other: UObject | any): BTDecorator_Loop;
}

declare class BTDecorator_ReachedMoveGoal extends BTDecorator { 
	static Load(ResourceName: string): BTDecorator_ReachedMoveGoal;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ReachedMoveGoal;
	static GetDefaultObject(): BTDecorator_ReachedMoveGoal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ReachedMoveGoal;
	static C(Other: UObject | any): BTDecorator_ReachedMoveGoal;
}

declare class BTDecorator_SetTagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	static Load(ResourceName: string): BTDecorator_SetTagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_SetTagCooldown;
	static GetDefaultObject(): BTDecorator_SetTagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_SetTagCooldown;
	static C(Other: UObject | any): BTDecorator_SetTagCooldown;
}

declare class BTDecorator_TagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	bActivatesCooldown: boolean;
	static Load(ResourceName: string): BTDecorator_TagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_TagCooldown;
	static GetDefaultObject(): BTDecorator_TagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TagCooldown;
	static C(Other: UObject | any): BTDecorator_TagCooldown;
}

declare class BTDecorator_TimeLimit extends BTDecorator { 
	TimeLimit: number;
	static Load(ResourceName: string): BTDecorator_TimeLimit;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_TimeLimit;
	static GetDefaultObject(): BTDecorator_TimeLimit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TimeLimit;
	static C(Other: UObject | any): BTDecorator_TimeLimit;
}

declare class BTFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BTFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BTFunctionLibrary;
	static GetDefaultObject(): BTFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTFunctionLibrary;
	static StopUsingExternalEvent(NodeOwner: BTNode): void;
	static StartUsingExternalEvent(NodeOwner: BTNode,OwningActor: Actor): void;
	static SetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Vector): void;
	static SetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Rotator): void;
	static SetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UObject): void;
	static SetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	static SetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: boolean): void;
	static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
	static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
	static GetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): Vector;
	static GetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector): Rotator;
	static GetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector): UObject;
	static GetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector): UnrealEngineClass;
	static GetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector): boolean;
	static GetBlackboardValueAsActor(NodeOwner: BTNode,Key: BlackboardKeySelector): Actor;
	static ClearBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static ClearBlackboardValue(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static C(Other: UObject | any): BTFunctionLibrary;
}

declare class BTService_BlackboardBase extends BTService { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTService_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTService_BlackboardBase;
	static GetDefaultObject(): BTService_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlackboardBase;
	static C(Other: UObject | any): BTService_BlackboardBase;
}

declare class BTService_BlueprintBase extends BTService { 
	AIOwner: AIController;
	ActorOwner: Actor;
	bShowPropertyDetails: boolean;
	bShowEventDetails: boolean;
	static Load(ResourceName: string): BTService_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTService_BlueprintBase;
	static GetDefaultObject(): BTService_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveSearchStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveSearchStart(OwnerActor: Actor): void;
	ReceiveDeactivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveDeactivation(OwnerActor: Actor): void;
	ReceiveActivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveActivation(OwnerActor: Actor): void;
	IsServiceActive(): boolean;
	static C(Other: UObject | any): BTService_BlueprintBase;
}

declare class BTService_DefaultFocus extends BTService_BlackboardBase { 
	FocusPriority: number;
	static Load(ResourceName: string): BTService_DefaultFocus;
	static Find(Outer: UObject, ResourceName: string): BTService_DefaultFocus;
	static GetDefaultObject(): BTService_DefaultFocus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_DefaultFocus;
	static C(Other: UObject | any): BTService_DefaultFocus;
}

declare type EAIParamType = 'Float' | 'Int' | 'Bool';
declare var EAIParamType : { Float:'Float',Int:'Int',Bool:'Bool', };
declare class AIDynamicParam { 
	ParamName: string;
	ParamType: ParamType;
	Value: number;
	BBKey: BlackboardKeySelector;
	clone() : AIDynamicParam;
	static C(Other: UObject | any): AIDynamicParam;
}

declare class EQSParametrizedQueryExecutionRequest { 
	QueryTemplate: EnvQuery;
	QueryConfig: AIDynamicParam[];
	EQSQueryBlackboardKey: BlackboardKeySelector;
	RunMode: EEnvQueryRunMode;
	bUseBBKeyForQueryTemplate: boolean;
	clone() : EQSParametrizedQueryExecutionRequest;
	static C(Other: UObject | any): EQSParametrizedQueryExecutionRequest;
}

declare class BTService_RunEQS extends BTService_BlackboardBase { 
	EQSRequest: EQSParametrizedQueryExecutionRequest;
	static Load(ResourceName: string): BTService_RunEQS;
	static Find(Outer: UObject, ResourceName: string): BTService_RunEQS;
	static GetDefaultObject(): BTService_RunEQS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_RunEQS;
	static C(Other: UObject | any): BTService_RunEQS;
}

declare class BTTask_BlackboardBase extends BTTaskNode { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTTask_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_BlackboardBase;
	static GetDefaultObject(): BTTask_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlackboardBase;
	static C(Other: UObject | any): BTTask_BlackboardBase;
}

declare class BTTask_BlueprintBase extends BTTaskNode { 
	AIOwner: AIController;
	ActorOwner: Actor;
	bShowPropertyDetails: boolean;
	static Load(ResourceName: string): BTTask_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_BlueprintBase;
	static GetDefaultObject(): BTTask_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlueprintBase;
	SetFinishOnMessageWithId(MessageName: string,RequestID: number): void;
	SetFinishOnMessage(MessageName: string): void;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveExecuteAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecute(OwnerActor: Actor): void;
	ReceiveAbortAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveAbort(OwnerActor: Actor): void;
	IsTaskExecuting(): boolean;
	IsTaskAborting(): boolean;
	FinishExecute(bSuccess: boolean): void;
	FinishAbort(): void;
	static C(Other: UObject | any): BTTask_BlueprintBase;
}

declare class BTTask_GameplayTaskBase extends BTTaskNode { 
	bWaitForGameplayTask: boolean;
	static Load(ResourceName: string): BTTask_GameplayTaskBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_GameplayTaskBase;
	static GetDefaultObject(): BTTask_GameplayTaskBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_GameplayTaskBase;
	static C(Other: UObject | any): BTTask_GameplayTaskBase;
}

declare class BTTask_MakeNoise extends BTTaskNode { 
	Loudnes: number;
	static Load(ResourceName: string): BTTask_MakeNoise;
	static Find(Outer: UObject, ResourceName: string): BTTask_MakeNoise;
	static GetDefaultObject(): BTTask_MakeNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MakeNoise;
	static C(Other: UObject | any): BTTask_MakeNoise;
}

declare class BTTask_MoveTo extends BTTask_BlackboardBase { 
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	ObservedBlackboardValueTolerance: number;
	bObserveBlackboardValue: boolean;
	bAllowStrafe: boolean;
	bAllowPartialPath: boolean;
	bTrackMovingGoal: boolean;
	bProjectGoalLocation: boolean;
	bReachTestIncludesAgentRadius: boolean;
	bReachTestIncludesGoalRadius: boolean;
	bStopOnOverlap: boolean;
	bStopOnOverlapNeedsUpdate: boolean;
	static Load(ResourceName: string): BTTask_MoveTo;
	static Find(Outer: UObject, ResourceName: string): BTTask_MoveTo;
	static GetDefaultObject(): BTTask_MoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveTo;
	static C(Other: UObject | any): BTTask_MoveTo;
}

declare class BTTask_MoveDirectlyToward extends BTTask_MoveTo { 
	bDisablePathUpdateOnGoalLocationChange: boolean;
	bProjectVectorGoalToNavigation: boolean;
	bUpdatedDeprecatedProperties: boolean;
	static Load(ResourceName: string): BTTask_MoveDirectlyToward;
	static Find(Outer: UObject, ResourceName: string): BTTask_MoveDirectlyToward;
	static GetDefaultObject(): BTTask_MoveDirectlyToward;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveDirectlyToward;
	static C(Other: UObject | any): BTTask_MoveDirectlyToward;
}

declare class BTTask_PawnActionBase extends BTTaskNode { 
	static Load(ResourceName: string): BTTask_PawnActionBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_PawnActionBase;
	static GetDefaultObject(): BTTask_PawnActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PawnActionBase;
	static C(Other: UObject | any): BTTask_PawnActionBase;
}

declare class BTTask_PlayAnimation extends BTTaskNode { 
	AnimationToPlay: AnimationAsset;
	bLooping: boolean;
	bNonBlocking: boolean;
	MyOwnerComp: BehaviorTreeComponent;
	CachedSkelMesh: SkeletalMeshComponent;
	static Load(ResourceName: string): BTTask_PlayAnimation;
	static Find(Outer: UObject, ResourceName: string): BTTask_PlayAnimation;
	static GetDefaultObject(): BTTask_PlayAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlayAnimation;
	static C(Other: UObject | any): BTTask_PlayAnimation;
}

declare class SoundNode extends UObject { 
	ChildNodes: SoundNode[];
	GraphNode: EdGraphNode;
	static Load(ResourceName: string): SoundNode;
	static Find(Outer: UObject, ResourceName: string): SoundNode;
	static GetDefaultObject(): SoundNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNode;
	static C(Other: UObject | any): SoundNode;
}

declare class SoundCue extends SoundBase { 
	bOverrideAttenuation: boolean;
	FirstNode: SoundNode;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	AttenuationOverrides: SoundAttenuationSettings;
	AllNodes: SoundNode[];
	SoundCueGraph: EdGraph;
	SubtitlePriority: number;
	static Load(ResourceName: string): SoundCue;
	static Find(Outer: UObject, ResourceName: string): SoundCue;
	static GetDefaultObject(): SoundCue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCue;
	static C(Other: UObject | any): SoundCue;
}

declare class BTTask_PlaySound extends BTTaskNode { 
	SoundToPlay: SoundCue;
	static Load(ResourceName: string): BTTask_PlaySound;
	static Find(Outer: UObject, ResourceName: string): BTTask_PlaySound;
	static GetDefaultObject(): BTTask_PlaySound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlaySound;
	static C(Other: UObject | any): BTTask_PlaySound;
}

declare class BTTask_PushPawnAction extends BTTask_PawnActionBase { 
	Action: PawnAction;
	static Load(ResourceName: string): BTTask_PushPawnAction;
	static Find(Outer: UObject, ResourceName: string): BTTask_PushPawnAction;
	static GetDefaultObject(): BTTask_PushPawnAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PushPawnAction;
	static C(Other: UObject | any): BTTask_PushPawnAction;
}

declare class BTTask_RotateToFaceBBEntry extends BTTask_BlackboardBase { 
	Precision: number;
	static Load(ResourceName: string): BTTask_RotateToFaceBBEntry;
	static Find(Outer: UObject, ResourceName: string): BTTask_RotateToFaceBBEntry;
	static GetDefaultObject(): BTTask_RotateToFaceBBEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RotateToFaceBBEntry;
	static C(Other: UObject | any): BTTask_RotateToFaceBBEntry;
}

declare class BTTask_RunBehavior extends BTTaskNode { 
	BehaviorAsset: BehaviorTree;
	static Load(ResourceName: string): BTTask_RunBehavior;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunBehavior;
	static GetDefaultObject(): BTTask_RunBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehavior;
	static C(Other: UObject | any): BTTask_RunBehavior;
}

declare class BTTask_RunBehaviorDynamic extends BTTaskNode { 
	InjectionTag: GameplayTag;
	DefaultBehaviorAsset: BehaviorTree;
	BehaviorAsset: BehaviorTree;
	static Load(ResourceName: string): BTTask_RunBehaviorDynamic;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunBehaviorDynamic;
	static GetDefaultObject(): BTTask_RunBehaviorDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehaviorDynamic;
	static C(Other: UObject | any): BTTask_RunBehaviorDynamic;
}

declare class EnvNamedValue { 
	ParamName: string;
	ParamType: ParamType;
	Value: number;
	clone() : EnvNamedValue;
	static C(Other: UObject | any): EnvNamedValue;
}

declare class BTTask_RunEQSQuery extends BTTask_BlackboardBase { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	QueryConfig: AIDynamicParam[];
	RunMode: EEnvQueryRunMode;
	EQSQueryBlackboardKey: BlackboardKeySelector;
	bUseBBKey: boolean;
	EQSRequest: EQSParametrizedQueryExecutionRequest;
	static Load(ResourceName: string): BTTask_RunEQSQuery;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunEQSQuery;
	static GetDefaultObject(): BTTask_RunEQSQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunEQSQuery;
	static C(Other: UObject | any): BTTask_RunEQSQuery;
}

declare class BTTask_SetTagCooldown extends BTTaskNode { 
	CooldownTag: GameplayTag;
	bAddToExistingDuration: boolean;
	CooldownDuration: number;
	static Load(ResourceName: string): BTTask_SetTagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTTask_SetTagCooldown;
	static GetDefaultObject(): BTTask_SetTagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_SetTagCooldown;
	static C(Other: UObject | any): BTTask_SetTagCooldown;
}

declare class BTTask_Wait extends BTTaskNode { 
	WaitTime: number;
	RandomDeviation: number;
	static Load(ResourceName: string): BTTask_Wait;
	static Find(Outer: UObject, ResourceName: string): BTTask_Wait;
	static GetDefaultObject(): BTTask_Wait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_Wait;
	static C(Other: UObject | any): BTTask_Wait;
}

declare class BTTask_WaitBlackboardTime extends BTTask_Wait { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTTask_WaitBlackboardTime;
	static Find(Outer: UObject, ResourceName: string): BTTask_WaitBlackboardTime;
	static GetDefaultObject(): BTTask_WaitBlackboardTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_WaitBlackboardTime;
	static C(Other: UObject | any): BTTask_WaitBlackboardTime;
}

declare class CrowdAgentInterface extends Interface { 
	static Load(ResourceName: string): CrowdAgentInterface;
	static Find(Outer: UObject, ResourceName: string): CrowdAgentInterface;
	static GetDefaultObject(): CrowdAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdAgentInterface;
	static C(Other: UObject | any): CrowdAgentInterface;
}

declare class CrowdFollowingComponent extends PathFollowingComponent { 
	CrowdAgentMoveDirection: Vector;
	CharacterMovement: CharacterMovementComponent;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	static Load(ResourceName: string): CrowdFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): CrowdFollowingComponent;
	static GetDefaultObject(): CrowdFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdFollowingComponent;
	SuspendCrowdSteering(bSuspend: boolean): void;
	static C(Other: UObject | any): CrowdFollowingComponent;
}

declare class CrowdAvoidanceConfig { 
	VelocityBias: number;
	DesiredVelocityWeight: number;
	CurrentVelocityWeight: number;
	SideBiasWeight: number;
	ImpactTimeWeight: number;
	ImpactTimeRange: number;
	CustomPatternIdx: number;
	AdaptiveDivisions: number;
	AdaptiveRings: number;
	AdaptiveDepth: number;
	clone() : CrowdAvoidanceConfig;
	static C(Other: UObject | any): CrowdAvoidanceConfig;
}

declare class CrowdAvoidanceSamplingPattern { 
	Angles: number[];
	Radii: number[];
	clone() : CrowdAvoidanceSamplingPattern;
	static C(Other: UObject | any): CrowdAvoidanceSamplingPattern;
}

declare class CrowdManager extends CrowdManagerBase { 
	MyNavData: NavigationData;
	AvoidanceConfig: CrowdAvoidanceConfig[];
	SamplingPatterns: CrowdAvoidanceSamplingPattern[];
	MaxAgents: number;
	MaxAgentRadius: number;
	MaxAvoidedAgents: number;
	MaxAvoidedWalls: number;
	NavmeshCheckInterval: number;
	PathOptimizationInterval: number;
	SeparationDirClamp: number;
	PathOffsetRadiusMultiplier: number;
	bResolveCollisions: boolean;
	static Load(ResourceName: string): CrowdManager;
	static Find(Outer: UObject, ResourceName: string): CrowdManager;
	static GetDefaultObject(): CrowdManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManager;
	static C(Other: UObject | any): CrowdManager;
}

declare class DetourCrowdAIController extends AIController { 
	static GetDefaultObject(): DetourCrowdAIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetourCrowdAIController;
	static C(Other: UObject | any): DetourCrowdAIController;
}

declare class EnvQueryContext_BlueprintBase extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_BlueprintBase;
	static GetDefaultObject(): EnvQueryContext_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_BlueprintBase;
	ProvideSingleLocation(QuerierObject: UObject,QuerierActor: Actor,ResultingLocation?: Vector): {ResultingLocation: Vector};
	ProvideSingleActor(QuerierObject: UObject,QuerierActor: Actor,ResultingActor?: Actor): {ResultingActor: Actor};
	ProvideLocationsSet(QuerierObject: UObject,QuerierActor: Actor,ResultingLocationSet?: Vector[]): {ResultingLocationSet: Vector[]};
	ProvideActorsSet(QuerierObject: UObject,QuerierActor: Actor,ResultingActorsSet?: Actor[]): {ResultingActorsSet: Actor[]};
	static C(Other: UObject | any): EnvQueryContext_BlueprintBase;
}

declare class EnvQueryContext_Item extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_Item;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_Item;
	static GetDefaultObject(): EnvQueryContext_Item;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Item;
	static C(Other: UObject | any): EnvQueryContext_Item;
}

declare class EnvQueryContext_Querier extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_Querier;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_Querier;
	static GetDefaultObject(): EnvQueryContext_Querier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Querier;
	static C(Other: UObject | any): EnvQueryContext_Querier;
}

declare class EnvQueryDebugHelpers extends UObject { 
	static Load(ResourceName: string): EnvQueryDebugHelpers;
	static Find(Outer: UObject, ResourceName: string): EnvQueryDebugHelpers;
	static GetDefaultObject(): EnvQueryDebugHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryDebugHelpers;
	static C(Other: UObject | any): EnvQueryDebugHelpers;
}

declare class EnvQueryGenerator_ActorsOfClass extends EnvQueryGenerator { 
	SearchedActorClass: UnrealEngineClass;
	GenerateOnlyActorsInRadius: AIDataProviderBoolValue;
	SearchRadius: AIDataProviderFloatValue;
	SearchCenter: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static GetDefaultObject(): EnvQueryGenerator_ActorsOfClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ActorsOfClass;
	static C(Other: UObject | any): EnvQueryGenerator_ActorsOfClass;
}

declare class EnvQueryGenerator_BlueprintBase extends EnvQueryGenerator { 
	GeneratorsActionDescription: string;
	Context: UnrealEngineClass;
	GeneratedItemType: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static GetDefaultObject(): EnvQueryGenerator_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_BlueprintBase;
	GetQuerier(): UObject;
	DoItemGeneration(ContextLocations: Vector[]): void;
	AddGeneratedVector(GeneratedVector: Vector): void;
	AddGeneratedActor(GeneratedActor: Actor): void;
	static C(Other: UObject | any): EnvQueryGenerator_BlueprintBase;
}

declare class EnvQueryGenerator_Composite extends EnvQueryGenerator { 
	Generators: EnvQueryGenerator[];
	bAllowDifferentItemTypes: boolean;
	bHasMatchingItemType: boolean;
	ForcedItemType: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_Composite;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Composite;
	static GetDefaultObject(): EnvQueryGenerator_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Composite;
	static C(Other: UObject | any): EnvQueryGenerator_Composite;
}

declare type EEnvTraceShape = 'Line' | 'Box' | 'Sphere' | 'Capsule';
declare var EEnvTraceShape : { Line:'Line',Box:'Box',Sphere:'Sphere',Capsule:'Capsule', };
declare type EEnvQueryTrace = 'None' | 'Navigation' | 'Geometry' | 'NavigationOverLedges';
declare var EEnvQueryTrace : { None:'None',Navigation:'Navigation',Geometry:'Geometry',NavigationOverLedges:'NavigationOverLedges', };
declare class EnvTraceData { 
	VersionNum: number;
	NavigationFilter: UnrealEngineClass;
	ProjectDown: number;
	ProjectUp: number;
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	PostProjectionVerticalOffset: number;
	TraceChannel: ETraceTypeQuery;
	SerializedChannel: ECollisionChannel;
	TraceShape: EEnvTraceShape;
	TraceMode: EEnvQueryTrace;
	bTraceComplex: boolean;
	bOnlyBlockingHits: boolean;
	bCanTraceOnNavMesh: boolean;
	bCanTraceOnGeometry: boolean;
	bCanDisableTrace: boolean;
	bCanProjectDown: boolean;
	clone() : EnvTraceData;
	static C(Other: UObject | any): EnvTraceData;
}

declare class EnvQueryGenerator_ProjectedPoints extends EnvQueryGenerator { 
	ProjectionData: EnvTraceData;
	static Load(ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static GetDefaultObject(): EnvQueryGenerator_ProjectedPoints;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ProjectedPoints;
	static C(Other: UObject | any): EnvQueryGenerator_ProjectedPoints;
}

declare class EnvQueryGenerator_Cone extends EnvQueryGenerator_ProjectedPoints { 
	AlignedPointsDistance: AIDataProviderFloatValue;
	ConeDegrees: AIDataProviderFloatValue;
	AngleStep: AIDataProviderFloatValue;
	Range: AIDataProviderFloatValue;
	CenterActor: UnrealEngineClass;
	bIncludeContextLocation: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_Cone;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Cone;
	static GetDefaultObject(): EnvQueryGenerator_Cone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Cone;
	static C(Other: UObject | any): EnvQueryGenerator_Cone;
}

declare class EnvQueryGenerator_CurrentLocation extends EnvQueryGenerator { 
	QueryContext: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_CurrentLocation;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_CurrentLocation;
	static GetDefaultObject(): EnvQueryGenerator_CurrentLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_CurrentLocation;
	static C(Other: UObject | any): EnvQueryGenerator_CurrentLocation;
}

declare class AIDataProviderIntValue extends AIDataProviderTypedValue { 
	DefaultValue: number;
	clone() : AIDataProviderIntValue;
	static C(Other: UObject | any): AIDataProviderIntValue;
}

declare type EEnvDirection = 'TwoPoints' | 'Rotation';
declare var EEnvDirection : { TwoPoints:'TwoPoints',Rotation:'Rotation', };
declare class EnvDirection { 
	LineFrom: UnrealEngineClass;
	LineTo: UnrealEngineClass;
	Rotation: UnrealEngineClass;
	DirMode: EEnvDirection;
	clone() : EnvDirection;
	static C(Other: UObject | any): EnvDirection;
}

declare class EnvQueryGenerator_Donut extends EnvQueryGenerator_ProjectedPoints { 
	InnerRadius: AIDataProviderFloatValue;
	OuterRadius: AIDataProviderFloatValue;
	NumberOfRings: AIDataProviderIntValue;
	PointsPerRing: AIDataProviderIntValue;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	bUseSpiralPattern: boolean;
	Center: UnrealEngineClass;
	bDefineArc: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_Donut;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Donut;
	static GetDefaultObject(): EnvQueryGenerator_Donut;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Donut;
	static C(Other: UObject | any): EnvQueryGenerator_Donut;
}

declare type EPointOnCircleSpacingMethod = 'BySpaceBetween' | 'ByNumberOfPoints';
declare var EPointOnCircleSpacingMethod : { BySpaceBetween:'BySpaceBetween',ByNumberOfPoints:'ByNumberOfPoints', };
declare class EnvQueryGenerator_OnCircle extends EnvQueryGenerator_ProjectedPoints { 
	CircleRadius: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	NumberOfPoints: AIDataProviderIntValue;
	PointOnCircleSpacingMethod: PointOnCircleSpacingMethod;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	AngleRadians: number;
	CircleCenter: UnrealEngineClass;
	bIgnoreAnyContextActorsWhenGeneratingCircle: boolean;
	CircleCenterZOffset: AIDataProviderFloatValue;
	TraceData: EnvTraceData;
	bDefineArc: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_OnCircle;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_OnCircle;
	static GetDefaultObject(): EnvQueryGenerator_OnCircle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_OnCircle;
	static C(Other: UObject | any): EnvQueryGenerator_OnCircle;
}

declare class EnvQueryGenerator_SimpleGrid extends EnvQueryGenerator_ProjectedPoints { 
	GridSize: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	GenerateAround: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static GetDefaultObject(): EnvQueryGenerator_SimpleGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_SimpleGrid;
	static C(Other: UObject | any): EnvQueryGenerator_SimpleGrid;
}

declare class EnvQueryGenerator_PathingGrid extends EnvQueryGenerator_SimpleGrid { 
	PathToItem: AIDataProviderBoolValue;
	NavigationFilter: UnrealEngineClass;
	ScanRangeMultiplier: AIDataProviderFloatValue;
	static Load(ResourceName: string): EnvQueryGenerator_PathingGrid;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_PathingGrid;
	static GetDefaultObject(): EnvQueryGenerator_PathingGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_PathingGrid;
	static C(Other: UObject | any): EnvQueryGenerator_PathingGrid;
}

declare class EnvQueryItemType_VectorBase extends EnvQueryItemType { 
	static Load(ResourceName: string): EnvQueryItemType_VectorBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_VectorBase;
	static GetDefaultObject(): EnvQueryItemType_VectorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_VectorBase;
	static C(Other: UObject | any): EnvQueryItemType_VectorBase;
}

declare class EnvQueryItemType_ActorBase extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_ActorBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_ActorBase;
	static GetDefaultObject(): EnvQueryItemType_ActorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_ActorBase;
	static C(Other: UObject | any): EnvQueryItemType_ActorBase;
}

declare class EnvQueryItemType_Actor extends EnvQueryItemType_ActorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Actor;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Actor;
	static GetDefaultObject(): EnvQueryItemType_Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Actor;
	static C(Other: UObject | any): EnvQueryItemType_Actor;
}

declare class EnvQueryItemType_Direction extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Direction;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Direction;
	static GetDefaultObject(): EnvQueryItemType_Direction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Direction;
	static C(Other: UObject | any): EnvQueryItemType_Direction;
}

declare class EnvQueryItemType_Point extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Point;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Point;
	static GetDefaultObject(): EnvQueryItemType_Point;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Point;
	static C(Other: UObject | any): EnvQueryItemType_Point;
}

declare type EEnvTestDistance = 'Distance3D' | 'Distance2D' | 'DistanceZ' | 'DistanceAbsoluteZ';
declare var EEnvTestDistance : { Distance3D:'Distance3D',Distance2D:'Distance2D',DistanceZ:'DistanceZ',DistanceAbsoluteZ:'DistanceAbsoluteZ', };
declare class EnvQueryTest_Distance extends EnvQueryTest { 
	TestMode: EEnvTestDistance;
	DistanceTo: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Distance;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Distance;
	static GetDefaultObject(): EnvQueryTest_Distance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Distance;
	static C(Other: UObject | any): EnvQueryTest_Distance;
}

declare type EEnvTestDot = 'Dot3D' | 'Dot2D';
declare var EEnvTestDot : { Dot3D:'Dot3D',Dot2D:'Dot2D', };
declare class EnvQueryTest_Dot extends EnvQueryTest { 
	LineA: EnvDirection;
	LineB: EnvDirection;
	TestMode: TestMode;
	bAbsoluteValue: boolean;
	static Load(ResourceName: string): EnvQueryTest_Dot;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Dot;
	static GetDefaultObject(): EnvQueryTest_Dot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Dot;
	static C(Other: UObject | any): EnvQueryTest_Dot;
}

declare class EnvQueryTest_GameplayTags extends EnvQueryTest { 
	TagQueryToMatch: GameplayTagQuery;
	bUpdatedToUseQuery: boolean;
	TagsToMatch: TagsToMatch;
	GameplayTags: GameplayTagContainer;
	static Load(ResourceName: string): EnvQueryTest_GameplayTags;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_GameplayTags;
	static GetDefaultObject(): EnvQueryTest_GameplayTags;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_GameplayTags;
	static C(Other: UObject | any): EnvQueryTest_GameplayTags;
}

declare type EEnvOverlapShape = 'Box' | 'Sphere' | 'Capsule';
declare var EEnvOverlapShape : { Box:'Box',Sphere:'Sphere',Capsule:'Capsule', };
declare class EnvOverlapData { 
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	ShapeOffset: Vector;
	OverlapChannel: ECollisionChannel;
	OverlapShape: EEnvOverlapShape;
	bOnlyBlockingHits: boolean;
	bOverlapComplex: boolean;
	clone() : EnvOverlapData;
	static C(Other: UObject | any): EnvOverlapData;
}

declare class EnvQueryTest_Overlap extends EnvQueryTest { 
	OverlapData: EnvOverlapData;
	static Load(ResourceName: string): EnvQueryTest_Overlap;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Overlap;
	static GetDefaultObject(): EnvQueryTest_Overlap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Overlap;
	static C(Other: UObject | any): EnvQueryTest_Overlap;
}

declare type EEnvTestPathfinding = 'PathExist' | 'PathCost' | 'PathLength';
declare var EEnvTestPathfinding : { PathExist:'PathExist',PathCost:'PathCost',PathLength:'PathLength', };
declare class EnvQueryTest_Pathfinding extends EnvQueryTest { 
	TestMode: EEnvTestPathfinding;
	Context: UnrealEngineClass;
	PathFromContext: AIDataProviderBoolValue;
	SkipUnreachable: AIDataProviderBoolValue;
	FilterClass: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Pathfinding;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Pathfinding;
	static GetDefaultObject(): EnvQueryTest_Pathfinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Pathfinding;
	static C(Other: UObject | any): EnvQueryTest_Pathfinding;
}

declare class EnvQueryTest_PathfindingBatch extends EnvQueryTest_Pathfinding { 
	ScanRangeMultiplier: AIDataProviderFloatValue;
	static Load(ResourceName: string): EnvQueryTest_PathfindingBatch;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_PathfindingBatch;
	static GetDefaultObject(): EnvQueryTest_PathfindingBatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_PathfindingBatch;
	static C(Other: UObject | any): EnvQueryTest_PathfindingBatch;
}

declare class EnvQueryTest_Project extends EnvQueryTest { 
	ProjectionData: EnvTraceData;
	static Load(ResourceName: string): EnvQueryTest_Project;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Project;
	static GetDefaultObject(): EnvQueryTest_Project;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Project;
	static C(Other: UObject | any): EnvQueryTest_Project;
}

declare class EnvQueryTest_Random extends EnvQueryTest { 
	static Load(ResourceName: string): EnvQueryTest_Random;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Random;
	static GetDefaultObject(): EnvQueryTest_Random;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Random;
	static C(Other: UObject | any): EnvQueryTest_Random;
}

declare class EnvQueryTest_Trace extends EnvQueryTest { 
	TraceData: EnvTraceData;
	TraceFromContext: AIDataProviderBoolValue;
	ItemHeightOffset: AIDataProviderFloatValue;
	ContextHeightOffset: AIDataProviderFloatValue;
	Context: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Trace;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Trace;
	static GetDefaultObject(): EnvQueryTest_Trace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Trace;
	static C(Other: UObject | any): EnvQueryTest_Trace;
}

declare class EnvQueryTypes extends UObject { 
	static Load(ResourceName: string): EnvQueryTypes;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTypes;
	static GetDefaultObject(): EnvQueryTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTypes;
	static C(Other: UObject | any): EnvQueryTypes;
}

declare class EQSQueryResultSourceInterface extends Interface { 
	static Load(ResourceName: string): EQSQueryResultSourceInterface;
	static Find(Outer: UObject, ResourceName: string): EQSQueryResultSourceInterface;
	static GetDefaultObject(): EQSQueryResultSourceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSQueryResultSourceInterface;
	static C(Other: UObject | any): EQSQueryResultSourceInterface;
}

declare class EQSRenderingComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): EQSRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): EQSRenderingComponent;
	static GetDefaultObject(): EQSRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSRenderingComponent;
	static C(Other: UObject | any): EQSRenderingComponent;
}

declare type EEnvQueryHightlightMode = 'All' | 'Best5Pct' | 'Best25Pct';
declare var EEnvQueryHightlightMode : { All:'All',Best5Pct:'Best5Pct',Best25Pct:'Best25Pct', };
declare class EQSTestingPawn extends Character { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	QueryConfig: AIDynamicParam[];
	TimeLimitPerStep: number;
	StepToDebugDraw: number;
	HighlightMode: HighlightMode;
	bDrawLabels: boolean;
	bDrawFailedItems: boolean;
	bReRunQueryOnlyOnFinishedMove: boolean;
	bShouldBeVisibleInGame: boolean;
	bTickDuringGame: boolean;
	QueryingMode: EEnvQueryRunMode;
	EdRenderComp: EQSRenderingComponent;
	static GetDefaultObject(): EQSTestingPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSTestingPawn;
	static C(Other: UObject | any): EQSTestingPawn;
}

declare class GenericTeamAgentInterface extends Interface { 
	static Load(ResourceName: string): GenericTeamAgentInterface;
	static Find(Outer: UObject, ResourceName: string): GenericTeamAgentInterface;
	static GetDefaultObject(): GenericTeamAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenericTeamAgentInterface;
	static C(Other: UObject | any): GenericTeamAgentInterface;
}

declare class GridPathAIController extends AIController { 
	static GetDefaultObject(): GridPathAIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPathAIController;
	static C(Other: UObject | any): GridPathAIController;
}

declare class GridPathFollowingComponent extends PathFollowingComponent { 
	GridManager: NavLocalGridManager;
	static Load(ResourceName: string): GridPathFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): GridPathFollowingComponent;
	static GetDefaultObject(): GridPathFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPathFollowingComponent;
	static C(Other: UObject | any): GridPathFollowingComponent;
}

declare class NavFilter_AIControllerDefault extends NavigationQueryFilter { 
	static Load(ResourceName: string): NavFilter_AIControllerDefault;
	static Find(Outer: UObject, ResourceName: string): NavFilter_AIControllerDefault;
	static GetDefaultObject(): NavFilter_AIControllerDefault;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavFilter_AIControllerDefault;
	static C(Other: UObject | any): NavFilter_AIControllerDefault;
}

declare class PawnAction_BlueprintBase extends PawnAction { 
	static Load(ResourceName: string): PawnAction_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): PawnAction_BlueprintBase;
	static GetDefaultObject(): PawnAction_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_BlueprintBase;
	ActionTick(ControlledPawn: Pawn,DeltaSeconds: number): void;
	ActionStart(ControlledPawn: Pawn): void;
	ActionResume(ControlledPawn: Pawn): void;
	ActionPause(ControlledPawn: Pawn): void;
	ActionFinished(ControlledPawn: Pawn,WithResult: EPawnActionResult): void;
	static C(Other: UObject | any): PawnAction_BlueprintBase;
}

declare class PawnAction_Move extends PawnAction { 
	GoalActor: Actor;
	GoalLocation: Vector;
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	bAllowStrafe: boolean;
	bFinishOnOverlap: boolean;
	bUsePathfinding: boolean;
	bAllowPartialPath: boolean;
	bProjectGoalToNavigation: boolean;
	bUpdatePathToGoal: boolean;
	bAbortChildActionOnPathChange: boolean;
	static Load(ResourceName: string): PawnAction_Move;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Move;
	static GetDefaultObject(): PawnAction_Move;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Move;
	static C(Other: UObject | any): PawnAction_Move;
}

declare type EPawnActionFailHandling = 'RequireSuccess' | 'IgnoreFailure';
declare var EPawnActionFailHandling : { RequireSuccess:'RequireSuccess',IgnoreFailure:'IgnoreFailure', };
declare class PawnAction_Repeat extends PawnAction { 
	ActionToRepeat: PawnAction;
	RecentActionCopy: PawnAction;
	ChildFailureHandlingMode: EPawnActionFailHandling;
	static Load(ResourceName: string): PawnAction_Repeat;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Repeat;
	static GetDefaultObject(): PawnAction_Repeat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Repeat;
	static C(Other: UObject | any): PawnAction_Repeat;
}

declare class PawnAction_Sequence extends PawnAction { 
	ActionSequence: PawnAction[];
	ChildFailureHandlingMode: EPawnActionFailHandling;
	RecentActionCopy: PawnAction;
	static Load(ResourceName: string): PawnAction_Sequence;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Sequence;
	static GetDefaultObject(): PawnAction_Sequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Sequence;
	static C(Other: UObject | any): PawnAction_Sequence;
}

declare class PawnAction_Wait extends PawnAction { 
	TimeToWait: number;
	static Load(ResourceName: string): PawnAction_Wait;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Wait;
	static GetDefaultObject(): PawnAction_Wait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Wait;
	static C(Other: UObject | any): PawnAction_Wait;
}

declare class PawnSensingComponent extends ActorComponent { 
	HearingThreshold: number;
	LOSHearingThreshold: number;
	SightRadius: number;
	SensingInterval: number;
	HearingMaxSoundAge: number;
	bEnableSensingUpdates: boolean;
	bOnlySensePlayers: boolean;
	bSeePawns: boolean;
	bHearNoises: boolean;
	OnSeePawn: UnrealEngineMulticastDelegate<(Pawn: Pawn) => void>;
	OnHearNoise: UnrealEngineMulticastDelegate<(Instigator: Pawn, Location: Vector, Volume: number) => void>;
	PeripheralVisionAngle: number;
	PeripheralVisionCosine: number;
	static Load(ResourceName: string): PawnSensingComponent;
	static Find(Outer: UObject, ResourceName: string): PawnSensingComponent;
	static GetDefaultObject(): PawnSensingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnSensingComponent;
	SetSensingUpdatesEnabled(bEnabled: boolean): void;
	SetSensingInterval(NewSensingInterval: number): void;
	SetPeripheralVisionAngle(NewPeripheralVisionAngle: number): void;
	GetPeripheralVisionCosine(): number;
	GetPeripheralVisionAngle(): number;
	static C(Other: UObject | any): PawnSensingComponent;
}

declare class VisualLoggerExtension extends UObject { 
	static Load(ResourceName: string): VisualLoggerExtension;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerExtension;
	static GetDefaultObject(): VisualLoggerExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerExtension;
	static C(Other: UObject | any): VisualLoggerExtension;
}

declare type ETimezoneSetting = 'InternationalDateLineWest' | 'CoordinatedUniversalTimeNeg11' | 'Samoa' | 'Hawaii' | 'Alaska' | 'PacificTime_USCAN' | 'BajaCalifornia' | 'MountainTime_USCAN' | 'Chihuahua_LaPaz_Mazatlan' | 'Arizona' | 'Saskatchewan' | 'CentralAmerica' | 'CentralTime_USCAN' | 'Guadalajara_MexicoCity_Monterrey' | 'EasternTime_USCAN' | 'Bogota_Lima_Quito' | 'Indiana_US' | 'Caracas' | 'AtlanticTime_Canada' | 'Cuiaba' | 'Santiago' | 'Georgetown_LaPaz_Manaus_SanJuan' | 'Asuncion' | 'Newfoundland' | 'Brasilia' | 'Greenland' | 'Montevideo' | 'Cayenne_Fortaleza' | 'BuenosAires' | 'MidAtlantic' | 'CoordinatedUniversalTimeNeg02' | 'Azores' | 'CaboVerdeIs' | 'Dublin_Edinburgh_Lisbon_London' | 'Monrovia_Reykjavik' | 'Casablanca' | 'UTC' | 'Belgrade_Bratislava_Budapest_Ljubljana_Prague' | 'Sarajevo_Skopje_Warsaw_Zagreb' | 'Brussels_Copenhagen_Madrid_Paris' | 'WestCentralAfrica' | 'Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna' | 'Windhoek' | 'Minsk' | 'Cairo' | 'Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius' | 'Athens_Bucharest' | 'Jerusalem' | 'Amman' | 'Beirut' | 'Harare_Pretoria' | 'Damascus' | 'Istanbul' | 'Kuwait_Riyadh' | 'Baghdad' | 'Nairobi' | 'Kaliningrad' | 'Tehran' | 'Moscow_StPetersburg_Volgograd' | 'AbuDhabi_Muscat' | 'Baku' | 'Yerevan' | 'Tbilisi' | 'PortLouis' | 'Kabul' | 'Tashkent' | 'Islamabad_Karachi' | 'Chennai_Kolkata_Mumbai_NewDelhi' | 'SriJayawardenepura' | 'Kathmandu' | 'Ekaterinburg' | 'Astana' | 'Dhaka' | 'Yangon_Rangoon' | 'Novosibirsk' | 'Bangkok_Hanoi_Jakarta' | 'Krasnoyarsk' | 'Beijing_Chongqing_HongKong_Urumqi' | 'KualaLumpur_Singapore' | 'Taipei' | 'Perth' | 'Ulaanbaatar' | 'Irkutsk' | 'Seoul' | 'Osaka_Sapporo_Tokyo' | 'Darwin' | 'Adelaide' | 'Yakutsk' | 'Canberra_Melbourne_Sydney' | 'Brisbane' | 'Hobart' | 'Guam_PortMoresby' | 'Vladivostok' | 'SolomonIs_NewCaledonia' | 'Magadan' | 'Fiji' | 'Auckland_Wellington' | 'CoordinatedUniversalTime12' | 'Nukualofa' | 'LocalTime';
declare var ETimezoneSetting : { InternationalDateLineWest:'InternationalDateLineWest',CoordinatedUniversalTimeNeg11:'CoordinatedUniversalTimeNeg11',Samoa:'Samoa',Hawaii:'Hawaii',Alaska:'Alaska',PacificTime_USCAN:'PacificTime_USCAN',BajaCalifornia:'BajaCalifornia',MountainTime_USCAN:'MountainTime_USCAN',Chihuahua_LaPaz_Mazatlan:'Chihuahua_LaPaz_Mazatlan',Arizona:'Arizona',Saskatchewan:'Saskatchewan',CentralAmerica:'CentralAmerica',CentralTime_USCAN:'CentralTime_USCAN',Guadalajara_MexicoCity_Monterrey:'Guadalajara_MexicoCity_Monterrey',EasternTime_USCAN:'EasternTime_USCAN',Bogota_Lima_Quito:'Bogota_Lima_Quito',Indiana_US:'Indiana_US',Caracas:'Caracas',AtlanticTime_Canada:'AtlanticTime_Canada',Cuiaba:'Cuiaba',Santiago:'Santiago',Georgetown_LaPaz_Manaus_SanJuan:'Georgetown_LaPaz_Manaus_SanJuan',Asuncion:'Asuncion',Newfoundland:'Newfoundland',Brasilia:'Brasilia',Greenland:'Greenland',Montevideo:'Montevideo',Cayenne_Fortaleza:'Cayenne_Fortaleza',BuenosAires:'BuenosAires',MidAtlantic:'MidAtlantic',CoordinatedUniversalTimeNeg02:'CoordinatedUniversalTimeNeg02',Azores:'Azores',CaboVerdeIs:'CaboVerdeIs',Dublin_Edinburgh_Lisbon_London:'Dublin_Edinburgh_Lisbon_London',Monrovia_Reykjavik:'Monrovia_Reykjavik',Casablanca:'Casablanca',UTC:'UTC',Belgrade_Bratislava_Budapest_Ljubljana_Prague:'Belgrade_Bratislava_Budapest_Ljubljana_Prague',Sarajevo_Skopje_Warsaw_Zagreb:'Sarajevo_Skopje_Warsaw_Zagreb',Brussels_Copenhagen_Madrid_Paris:'Brussels_Copenhagen_Madrid_Paris',WestCentralAfrica:'WestCentralAfrica',Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna:'Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna',Windhoek:'Windhoek',Minsk:'Minsk',Cairo:'Cairo',Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius:'Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius',Athens_Bucharest:'Athens_Bucharest',Jerusalem:'Jerusalem',Amman:'Amman',Beirut:'Beirut',Harare_Pretoria:'Harare_Pretoria',Damascus:'Damascus',Istanbul:'Istanbul',Kuwait_Riyadh:'Kuwait_Riyadh',Baghdad:'Baghdad',Nairobi:'Nairobi',Kaliningrad:'Kaliningrad',Tehran:'Tehran',Moscow_StPetersburg_Volgograd:'Moscow_StPetersburg_Volgograd',AbuDhabi_Muscat:'AbuDhabi_Muscat',Baku:'Baku',Yerevan:'Yerevan',Tbilisi:'Tbilisi',PortLouis:'PortLouis',Kabul:'Kabul',Tashkent:'Tashkent',Islamabad_Karachi:'Islamabad_Karachi',Chennai_Kolkata_Mumbai_NewDelhi:'Chennai_Kolkata_Mumbai_NewDelhi',SriJayawardenepura:'SriJayawardenepura',Kathmandu:'Kathmandu',Ekaterinburg:'Ekaterinburg',Astana:'Astana',Dhaka:'Dhaka',Yangon_Rangoon:'Yangon_Rangoon',Novosibirsk:'Novosibirsk',Bangkok_Hanoi_Jakarta:'Bangkok_Hanoi_Jakarta',Krasnoyarsk:'Krasnoyarsk',Beijing_Chongqing_HongKong_Urumqi:'Beijing_Chongqing_HongKong_Urumqi',KualaLumpur_Singapore:'KualaLumpur_Singapore',Taipei:'Taipei',Perth:'Perth',Ulaanbaatar:'Ulaanbaatar',Irkutsk:'Irkutsk',Seoul:'Seoul',Osaka_Sapporo_Tokyo:'Osaka_Sapporo_Tokyo',Darwin:'Darwin',Adelaide:'Adelaide',Yakutsk:'Yakutsk',Canberra_Melbourne_Sydney:'Canberra_Melbourne_Sydney',Brisbane:'Brisbane',Hobart:'Hobart',Guam_PortMoresby:'Guam_PortMoresby',Vladivostok:'Vladivostok',SolomonIs_NewCaledonia:'SolomonIs_NewCaledonia',Magadan:'Magadan',Fiji:'Fiji',Auckland_Wellington:'Auckland_Wellington',CoordinatedUniversalTime12:'CoordinatedUniversalTime12',Nukualofa:'Nukualofa',LocalTime:'LocalTime', };
declare class InternationalizationSettingsModel extends UObject { 
	DisplayTimezone: DisplayTimezone;
	static Load(ResourceName: string): InternationalizationSettingsModel;
	static Find(Outer: UObject, ResourceName: string): InternationalizationSettingsModel;
	static GetDefaultObject(): InternationalizationSettingsModel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationSettingsModel;
	static C(Other: UObject | any): InternationalizationSettingsModel;
}

declare class EditorWorldExtension extends UObject { 
	ExtensionActors: Actor[];
	static Load(ResourceName: string): EditorWorldExtension;
	static Find(Outer: UObject, ResourceName: string): EditorWorldExtension;
	static GetDefaultObject(): EditorWorldExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorWorldExtension;
	static C(Other: UObject | any): EditorWorldExtension;
}

declare class ViewportInteractor extends UObject { 
	WorldInteraction: ViewportWorldInteraction;
	OtherInteractor: ViewportInteractor;
	static Load(ResourceName: string): ViewportInteractor;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractor;
	static GetDefaultObject(): ViewportInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractor;
	static C(Other: UObject | any): ViewportInteractor;
}

declare class GizmoHandle { 
	clone() : GizmoHandle;
	static C(Other: UObject | any): GizmoHandle;
}

declare class ViewportDragOperation extends UObject { 
	static Load(ResourceName: string): ViewportDragOperation;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperation;
	static GetDefaultObject(): ViewportDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperation;
	static C(Other: UObject | any): ViewportDragOperation;
}

declare class ViewportDragOperationComponent extends ActorComponent { 
	DragOperation: ViewportDragOperation;
	DragOperationSubclass: UnrealEngineClass;
	static Load(ResourceName: string): ViewportDragOperationComponent;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperationComponent;
	static GetDefaultObject(): ViewportDragOperationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperationComponent;
	static C(Other: UObject | any): ViewportDragOperationComponent;
}

declare class GizmoHandleGroup extends SceneComponent { 
	GizmoMaterial: MaterialInterface;
	TranslucentGizmoMaterial: MaterialInterface;
	Handles: GizmoHandle[];
	OwningTransformGizmoActor: BaseTransformGizmo;
	DragOperationComponent: ViewportDragOperationComponent;
	static Load(ResourceName: string): GizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleGroup;
	static GetDefaultObject(): GizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleGroup;
	static C(Other: UObject | any): GizmoHandleGroup;
}

declare class BaseTransformGizmo extends Actor { 
	SceneComponent: SceneComponent;
	AllHandleGroups: GizmoHandleGroup[];
	WorldInteraction: ViewportWorldInteraction;
	static GetDefaultObject(): BaseTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseTransformGizmo;
	static C(Other: UObject | any): BaseTransformGizmo;
}

declare class MouseCursorInteractor extends ViewportInteractor { 
	static Load(ResourceName: string): MouseCursorInteractor;
	static Find(Outer: UObject, ResourceName: string): MouseCursorInteractor;
	static GetDefaultObject(): MouseCursorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorInteractor;
	static C(Other: UObject | any): MouseCursorInteractor;
}

declare class ViewportInteractionAssetContainer extends DataAsset { 
	GizmoHandleSelectedSound: SoundBase;
	GizmoHandleDropSound: SoundBase;
	SelectionChangeSound: SoundBase;
	SelectionDropSound: SoundBase;
	SelectionStartDragSound: SoundBase;
	GridSnapSound: SoundBase;
	ActorSnapSound: SoundBase;
	UndoSound: SoundBase;
	RedoSound: SoundBase;
	GridMesh: StaticMesh;
	TranslationHandleMesh: StaticMesh;
	UniformScaleHandleMesh: StaticMesh;
	ScaleHandleMesh: StaticMesh;
	PlaneTranslationHandleMesh: StaticMesh;
	RotationHandleMesh: StaticMesh;
	RotationHandleSelectedMesh: StaticMesh;
	StartRotationIndicatorMesh: StaticMesh;
	CurrentRotationIndicatorMesh: StaticMesh;
	FreeRotationHandleMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	TransformGizmoMaterial: MaterialInterface;
	TranslucentTransformGizmoMaterial: MaterialInterface;
	static Load(ResourceName: string): ViewportInteractionAssetContainer;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractionAssetContainer;
	static GetDefaultObject(): ViewportInteractionAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractionAssetContainer;
	static C(Other: UObject | any): ViewportInteractionAssetContainer;
}

declare class ViewportWorldInteraction extends EditorWorldExtension { 
	Interactors: ViewportInteractor[];
	ViewportTransformer: ViewportTransformer;
	TransformGizmoActor: BaseTransformGizmo;
	SnapGridActor: Actor;
	SnapGridMeshComponent: StaticMeshComponent;
	SnapGridMID: MaterialInstanceDynamic;
	DefaultMouseCursorInteractor: MouseCursorInteractor;
	ActorsToExcludeFromHitTest: any[];
	AssetContainer: ViewportInteractionAssetContainer;
	static Load(ResourceName: string): ViewportWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteraction;
	static GetDefaultObject(): ViewportWorldInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteraction;
	static C(Other: UObject | any): ViewportWorldInteraction;
}

declare class ViewportTransformer extends UObject { 
	ViewportWorldInteraction: ViewportWorldInteraction;
	static Load(ResourceName: string): ViewportTransformer;
	static Find(Outer: UObject, ResourceName: string): ViewportTransformer;
	static GetDefaultObject(): ViewportTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportTransformer;
	Shutdown(): void;
	ShouldCenterTransformGizmoPivot(): boolean;
	OnStopDragging(Interactor: ViewportInteractor): void;
	OnStartDragging(Interactor: ViewportInteractor): void;
	Init(InitViewportWorldInteraction: ViewportWorldInteraction): void;
	CanAlignToActors(): boolean;
	static C(Other: UObject | any): ViewportTransformer;
}

declare class ActorTransformer extends ViewportTransformer { 
	static Load(ResourceName: string): ActorTransformer;
	static Find(Outer: UObject, ResourceName: string): ActorTransformer;
	static GetDefaultObject(): ActorTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorTransformer;
	static C(Other: UObject | any): ActorTransformer;
}

declare class ViewportInteractableInterface extends Interface { 
	static Load(ResourceName: string): ViewportInteractableInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractableInterface;
	static GetDefaultObject(): ViewportInteractableInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractableInterface;
	static C(Other: UObject | any): ViewportInteractableInterface;
}

declare class TranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): TranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): TranslationDragOperation;
	static GetDefaultObject(): TranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationDragOperation;
	static C(Other: UObject | any): TranslationDragOperation;
}

declare class PlaneTranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): PlaneTranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): PlaneTranslationDragOperation;
	static GetDefaultObject(): PlaneTranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneTranslationDragOperation;
	static C(Other: UObject | any): PlaneTranslationDragOperation;
}

declare class RotateOnAngleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): RotateOnAngleDragOperation;
	static Find(Outer: UObject, ResourceName: string): RotateOnAngleDragOperation;
	static GetDefaultObject(): RotateOnAngleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotateOnAngleDragOperation;
	static C(Other: UObject | any): RotateOnAngleDragOperation;
}

declare class ScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): ScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): ScaleDragOperation;
	static GetDefaultObject(): ScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleDragOperation;
	static C(Other: UObject | any): ScaleDragOperation;
}

declare class UniformScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): UniformScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): UniformScaleDragOperation;
	static GetDefaultObject(): UniformScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleDragOperation;
	static C(Other: UObject | any): UniformScaleDragOperation;
}

declare class AxisGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): AxisGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): AxisGizmoHandleGroup;
	static GetDefaultObject(): AxisGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisGizmoHandleGroup;
	static C(Other: UObject | any): AxisGizmoHandleGroup;
}

declare class GizmoHandleMeshComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): GizmoHandleMeshComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleMeshComponent;
	static GetDefaultObject(): GizmoHandleMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleMeshComponent;
	static C(Other: UObject | any): GizmoHandleMeshComponent;
}

declare class UniformScaleGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): UniformScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): UniformScaleGizmoHandleGroup;
	static GetDefaultObject(): UniformScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleGizmoHandleGroup;
	static C(Other: UObject | any): UniformScaleGizmoHandleGroup;
}

declare class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotTranslationGizmoHandleGroup;
}

declare class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotScaleGizmoHandleGroup;
	static GetDefaultObject(): PivotScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotScaleGizmoHandleGroup;
	static C(Other: UObject | any): PivotScaleGizmoHandleGroup;
}

declare class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotPlaneTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotPlaneTranslationGizmoHandleGroup;
}

declare class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	RootFullRotationHandleComponent: SceneComponent;
	FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
	StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootStartRotationIdicatorComponent: SceneComponent;
	DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootDeltaRotationIndicatorComponent: SceneComponent;
	static Load(ResourceName: string): PivotRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotRotationGizmoHandleGroup;
	static GetDefaultObject(): PivotRotationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotRotationGizmoHandleGroup;
	static C(Other: UObject | any): PivotRotationGizmoHandleGroup;
}

declare class StretchGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): StretchGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleGroup;
	static GetDefaultObject(): StretchGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleGroup;
	static C(Other: UObject | any): StretchGizmoHandleGroup;
}

declare class PivotTransformGizmo extends BaseTransformGizmo { 
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
	ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
	PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
	RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	LastDraggingHandle: ActorComponent;
	static GetDefaultObject(): PivotTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTransformGizmo;
	static C(Other: UObject | any): PivotTransformGizmo;
}

declare class StretchGizmoHandleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): StretchGizmoHandleDragOperation;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleDragOperation;
	static GetDefaultObject(): StretchGizmoHandleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleDragOperation;
	static C(Other: UObject | any): StretchGizmoHandleDragOperation;
}

declare type EMovieSceneCompletionMode = 'KeepState' | 'RestoreState';
declare var EMovieSceneCompletionMode : { KeepState:'KeepState',RestoreState:'RestoreState', };
declare class MovieSceneSectionEvalOptions { 
	bCanEditCompletionMode: boolean;
	CompletionMode: CompletionMode;
	clone() : MovieSceneSectionEvalOptions;
	static C(Other: UObject | any): MovieSceneSectionEvalOptions;
}

declare class MovieSceneEasingSettings { 
	AutoEaseInTime: number;
	AutoEaseOutTime: number;
	EaseIn: any;
	bManualEaseIn: boolean;
	ManualEaseInTime: number;
	EaseOut: any;
	bManualEaseOut: boolean;
	ManualEaseOutTime: number;
	clone() : MovieSceneEasingSettings;
	static C(Other: UObject | any): MovieSceneEasingSettings;
}

declare type EMovieSceneBlendType = 'Absolute' | 'Additive' | 'Relative' | 'EMovieSceneBlendType_MAX' | '';
declare var EMovieSceneBlendType : { Absolute:'Absolute',Additive:'Additive',Relative:'Relative',EMovieSceneBlendType_MAX:'EMovieSceneBlendType_MAX',:'', };
declare class OptionalMovieSceneBlendType { 
	BlendType: BlendType;
	bIsValid: boolean;
	clone() : OptionalMovieSceneBlendType;
	static C(Other: UObject | any): OptionalMovieSceneBlendType;
}

declare class MovieSceneSection extends MovieSceneSignedObject { 
	EvalOptions: MovieSceneSectionEvalOptions;
	Easing: MovieSceneEasingSettings;
	StartTime: number;
	EndTime: number;
	RowIndex: number;
	OverlapPriority: number;
	bIsActive: boolean;
	bIsLocked: boolean;
	bIsInfinite: boolean;
	PreRollTime: number;
	PostRollTime: number;
	BlendType: OptionalMovieSceneBlendType;
	static Load(ResourceName: string): MovieSceneSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSection;
	static GetDefaultObject(): MovieSceneSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSection;
	static C(Other: UObject | any): MovieSceneSection;
}

declare class MovieSceneTransformMask { 
	Mask: any;
	clone() : MovieSceneTransformMask;
	static C(Other: UObject | any): MovieSceneTransformMask;
}

declare type EShow3DTrajectory = 'EST_OnlyWhenSelected' | 'EST_Always' | 'EST_Never';
declare var EShow3DTrajectory : { EST_OnlyWhenSelected:'EST_OnlyWhenSelected',EST_Always:'EST_Always',EST_Never:'EST_Never', };
declare class MovieScene3DTransformSection extends MovieSceneSection { 
	TransformMask: MovieSceneTransformMask;
	Translation: RichCurve;
	Rotation: RichCurve;
	Scale: RichCurve;
	ManualWeight: RichCurve;
	Show3DTrajectory: Show3DTrajectory;
	static Load(ResourceName: string): MovieScene3DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSection;
	static GetDefaultObject(): MovieScene3DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSection;
	static C(Other: UObject | any): MovieScene3DTransformSection;
}

declare class SequencerKeyActor extends Actor { 
	KeyMeshComponent: StaticMeshComponent;
	AssociatedActor: Actor;
	TrackSection: MovieScene3DTransformSection;
	KeyTime: number;
	static GetDefaultObject(): SequencerKeyActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerKeyActor;
	static C(Other: UObject | any): SequencerKeyActor;
}

declare class SequencerMeshTrail extends Actor { 
	static GetDefaultObject(): SequencerMeshTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerMeshTrail;
	static C(Other: UObject | any): SequencerMeshTrail;
}

declare class SequencerSettingsContainer extends UObject { 
	static Load(ResourceName: string): SequencerSettingsContainer;
	static Find(Outer: UObject, ResourceName: string): SequencerSettingsContainer;
	static GetDefaultObject(): SequencerSettingsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettingsContainer;
	static C(Other: UObject | any): SequencerSettingsContainer;
}

declare type EAutoChangeMode = 'AutoKey' | 'AutoTrack' | 'All' | 'None';
declare var EAutoChangeMode : { AutoKey:'AutoKey',AutoTrack:'AutoTrack',All:'All',None:'None', };
declare type EAllowEditsMode = 'AllEdits' | 'AllowSequencerEditsOnly' | 'AllowLevelEditsOnly';
declare var EAllowEditsMode : { AllEdits:'AllEdits',AllowSequencerEditsOnly:'AllowSequencerEditsOnly',AllowLevelEditsOnly:'AllowLevelEditsOnly', };
declare type EMovieSceneKeyInterpolation = 'Auto' | 'User' | 'Break' | 'Linear' | 'Constant';
declare var EMovieSceneKeyInterpolation : { Auto:'Auto',User:'User',Break:'Break',Linear:'Linear',Constant:'Constant', };
declare type ESequencerSpawnPosition = 'SSP_Origin' | 'SSP_PlaceInFrontOfCamera';
declare var ESequencerSpawnPosition : { SSP_Origin:'SSP_Origin',SSP_PlaceInFrontOfCamera:'SSP_PlaceInFrontOfCamera', };
declare type ESequencerTimeSnapInterval = 'STSI_0_001' | 'STSI_0_01' | 'STSI_0_1' | 'STSI_1' | 'STSI_10' | 'STSI_100' | 'STSI_15Fps' | 'STSI_24Fps' | 'STSI_25Fps' | 'STSI_29_97Fps' | 'STSI_30Fps' | 'STSI_48Fps' | 'STSI_50Fps' | 'STSI_59_94Fps' | 'STSI_60Fps' | 'STSI_120Fps' | 'STSI_Custom';
declare var ESequencerTimeSnapInterval : { STSI_0_001:'STSI_0_001',STSI_0_01:'STSI_0_01',STSI_0_1:'STSI_0_1',STSI_1:'STSI_1',STSI_10:'STSI_10',STSI_100:'STSI_100',STSI_15Fps:'STSI_15Fps',STSI_24Fps:'STSI_24Fps',STSI_25Fps:'STSI_25Fps',STSI_29_97Fps:'STSI_29_97Fps',STSI_30Fps:'STSI_30Fps',STSI_48Fps:'STSI_48Fps',STSI_50Fps:'STSI_50Fps',STSI_59_94Fps:'STSI_59_94Fps',STSI_60Fps:'STSI_60Fps',STSI_120Fps:'STSI_120Fps',STSI_Custom:'STSI_Custom', };
declare type ESequencerZoomPosition = 'SZP_CurrentTime' | 'SZP_MousePosition';
declare var ESequencerZoomPosition : { SZP_CurrentTime:'SZP_CurrentTime',SZP_MousePosition:'SZP_MousePosition', };
declare type ESequencerLoopMode = 'SLM_NoLoop' | 'SLM_Loop' | 'SLM_LoopSelectionRange';
declare var ESequencerLoopMode : { SLM_NoLoop:'SLM_NoLoop',SLM_Loop:'SLM_Loop',SLM_LoopSelectionRange:'SLM_LoopSelectionRange', };
declare class SequencerSettings extends UObject { 
	AutoChangeMode: AutoChangeMode;
	AllowEditsMode: AllowEditsMode;
	bKeyAllEnabled: boolean;
	bKeyInterpPropertiesOnly: boolean;
	KeyInterpolation: KeyInterpolation;
	bAutoSetTrackDefaults: boolean;
	SpawnPosition: ESequencerSpawnPosition;
	bCreateSpawnableCameras: boolean;
	bShowFrameNumbers: boolean;
	bShowRangeSlider: boolean;
	bIsSnapEnabled: boolean;
	TimeSnapIntervalMode: ESequencerTimeSnapInterval;
	CustomTimeSnapInterval: number;
	bSnapKeyTimesToInterval: boolean;
	bSnapKeyTimesToKeys: boolean;
	bSnapSectionTimesToInterval: boolean;
	bSnapSectionTimesToSections: boolean;
	bSnapPlayTimeToKeys: boolean;
	bSnapPlayTimeToInterval: boolean;
	bSnapPlayTimeToPressedKey: boolean;
	bSnapPlayTimeToDraggedKey: boolean;
	bSnapCurveValueToInterval: boolean;
	bLabelBrowserVisible: boolean;
	bRewindOnRecord: boolean;
	ZoomPosition: ESequencerZoomPosition;
	bAutoScrollEnabled: boolean;
	bShowCurveEditorCurveToolTips: boolean;
	bLinkCurveEditorTimeRange: boolean;
	LoopMode: ESequencerLoopMode;
	bKeepCursorInPlayRangeWhileScrubbing: boolean;
	bKeepCursorInPlayRange: boolean;
	bKeepPlayRangeInSectionBounds: boolean;
	ZeroPadFrames: number;
	bShowCombinedKeyframes: boolean;
	bInfiniteKeyAreas: boolean;
	bShowChannelColors: boolean;
	bShowViewportTransportControls: boolean;
	bLockPlaybackToAudioClock: boolean;
	bAllowPossessionOfPIEViewports: boolean;
	bActivateRealtimeViewports: boolean;
	bEvaluateSubSequencesInIsolation: boolean;
	bRerunConstructionScripts: boolean;
	bShowDebugVisualization: boolean;
	bVisualizePreAndPostRoll: boolean;
	TrajectoryPathCap: any;
	static Load(ResourceName: string): SequencerSettings;
	static Find(Outer: UObject, ResourceName: string): SequencerSettings;
	static GetDefaultObject(): SequencerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettings;
	static C(Other: UObject | any): SequencerSettings;
}

declare class ActorRecordingSettings { 
	Settings: UObject[];
	clone() : ActorRecordingSettings;
	static C(Other: UObject | any): ActorRecordingSettings;
}

declare class AnimationRecordingSettings { 
	bRecordInWorldSpace: boolean;
	bRemoveRootAnimation: boolean;
	bAutoSaveAsset: boolean;
	SampleRate: number;
	Length: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	clone() : AnimationRecordingSettings;
	static C(Other: UObject | any): AnimationRecordingSettings;
}

declare class ActorRecording extends UObject { 
	ActorSettings: ActorRecordingSettings;
	bSpecifyTargetAnimation: boolean;
	TargetAnimation: any;
	AnimationSettings: AnimationRecordingSettings;
	bRecordToPossessable: boolean;
	ActorToRecord: any;
	static Load(ResourceName: string): ActorRecording;
	static Find(Outer: UObject, ResourceName: string): ActorRecording;
	static GetDefaultObject(): ActorRecording;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorRecording;
	static C(Other: UObject | any): ActorRecording;
}

declare class MovieScene3DTransformSectionRecorderSettings extends UObject { 
	bRecordTransforms: boolean;
	static Load(ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static GetDefaultObject(): MovieScene3DTransformSectionRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionRecorderSettings;
	static C(Other: UObject | any): MovieScene3DTransformSectionRecorderSettings;
}

declare class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceRecorderBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderBlueprintLibrary;
	static GetDefaultObject(): SequenceRecorderBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderBlueprintLibrary;
	static StopRecordingSequence(): void;
	static StartRecordingSequence(ActorsToRecord: Actor[]): void;
	static IsRecordingSequence(): boolean;
	static C(Other: UObject | any): SequenceRecorderBlueprintLibrary;
}

declare type EAudioRecordingMode = 'None' | 'AudioTrack';
declare var EAudioRecordingMode : { None:'None',AudioTrack:'AudioTrack', };
declare class SequenceRecorderActorFilter { 
	ActorClassesToRecord: UnrealEngineClass[];
	clone() : SequenceRecorderActorFilter;
	static C(Other: UObject | any): SequenceRecorderActorFilter;
}

declare class PropertiesToRecordForClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForClass;
	static C(Other: UObject | any): PropertiesToRecordForClass;
}

declare class SettingsForActorClass { 
	Class: UnrealEngineClass;
	bRecordToPossessable: boolean;
	clone() : SettingsForActorClass;
	static C(Other: UObject | any): SettingsForActorClass;
}

declare class SequenceRecorderSettings extends UObject { 
	bCreateLevelSequence: boolean;
	bImmersiveMode: boolean;
	SequenceLength: number;
	RecordingDelay: number;
	SequenceName: string;
	SequenceRecordingBasePath: DirectoryPath;
	AnimationSubDirectory: string;
	AudioSubDirectory: string;
	RecordAudio: RecordAudio;
	AudioGain: number;
	AudioInputBufferSize: number;
	bRecordNearbySpawnedActors: boolean;
	NearbyActorRecordingProximity: number;
	bRecordWorldSettingsActor: boolean;
	bReduceKeys: boolean;
	ActorFilter: SequenceRecorderActorFilter;
	LevelSequenceActorsToTrigger: any[];
	DefaultAnimationSettings: AnimationRecordingSettings;
	bRecordSequencerSpawnedActors: boolean;
	ClassesAndPropertiesToRecord: PropertiesToRecordForClass[];
	PerActorSettings: SettingsForActorClass[];
	static Load(ResourceName: string): SequenceRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderSettings;
	static GetDefaultObject(): SequenceRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderSettings;
	static C(Other: UObject | any): SequenceRecorderSettings;
}

declare class CaptureProtocolID { 
	Identifier: string;
	clone() : CaptureProtocolID;
	static C(Other: UObject | any): CaptureProtocolID;
}

declare class MovieSceneCaptureProtocolSettings extends UObject { 
	static Load(ResourceName: string): MovieSceneCaptureProtocolSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureProtocolSettings;
	static GetDefaultObject(): MovieSceneCaptureProtocolSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureProtocolSettings;
	static C(Other: UObject | any): MovieSceneCaptureProtocolSettings;
}

declare class CaptureResolution { 
	ResX: any;
	ResY: any;
	clone() : CaptureResolution;
	static C(Other: UObject | any): CaptureResolution;
}

declare class MovieSceneCaptureSettings { 
	OutputDirectory: DirectoryPath;
	GameModeOverride: UnrealEngineClass;
	OutputFormat: string;
	bOverwriteExisting: boolean;
	bUseRelativeFrameNumbers: boolean;
	HandleFrames: number;
	ZeroPadFrameNumbers: number;
	FrameRate: number;
	Resolution: CaptureResolution;
	bEnableTextureStreaming: boolean;
	bCinematicEngineScalability: boolean;
	bCinematicMode: boolean;
	bAllowMovement: boolean;
	bAllowTurning: boolean;
	bShowPlayer: boolean;
	bShowHUD: boolean;
	clone() : MovieSceneCaptureSettings;
	static C(Other: UObject | any): MovieSceneCaptureSettings;
}

declare class MovieSceneCapture extends UObject { 
	CaptureType: CaptureProtocolID;
	ProtocolSettings: MovieSceneCaptureProtocolSettings;
	Settings: MovieSceneCaptureSettings;
	bUseSeparateProcess: boolean;
	bCloseEditorWhenCaptureStarts: boolean;
	AdditionalCommandLineArguments: string;
	InheritedCommandLineArguments: string;
	static Load(ResourceName: string): MovieSceneCapture;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCapture;
	static GetDefaultObject(): MovieSceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCapture;
	static C(Other: UObject | any): MovieSceneCapture;
}

declare class LevelSequenceBurnInInitSettings extends UObject { 
	static Load(ResourceName: string): LevelSequenceBurnInInitSettings;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInInitSettings;
	static GetDefaultObject(): LevelSequenceBurnInInitSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInInitSettings;
	static C(Other: UObject | any): LevelSequenceBurnInInitSettings;
}

declare class LevelSequenceBurnInOptions extends UObject { 
	bUseBurnIn: boolean;
	BurnInClass: SoftClassPath;
	Settings: LevelSequenceBurnInInitSettings;
	static Load(ResourceName: string): LevelSequenceBurnInOptions;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInOptions;
	static GetDefaultObject(): LevelSequenceBurnInOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInOptions;
	static C(Other: UObject | any): LevelSequenceBurnInOptions;
}

declare class AutomatedLevelSequenceCapture extends MovieSceneCapture { 
	bUseCustomStartFrame: boolean;
	StartFrame: number;
	bUseCustomEndFrame: boolean;
	EndFrame: number;
	WarmUpFrameCount: number;
	DelayBeforeWarmUp: number;
	BurnInOptions: LevelSequenceBurnInOptions;
	bWriteEditDecisionList: boolean;
	LevelSequenceAsset: SoftObjectPath;
	LevelSequenceActor: any;
	static Load(ResourceName: string): AutomatedLevelSequenceCapture;
	static Find(Outer: UObject, ResourceName: string): AutomatedLevelSequenceCapture;
	static GetDefaultObject(): AutomatedLevelSequenceCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedLevelSequenceCapture;
	static C(Other: UObject | any): AutomatedLevelSequenceCapture;
}

declare class CompositionGraphCapturePasses { 
	Value: string[];
	clone() : CompositionGraphCapturePasses;
	static C(Other: UObject | any): CompositionGraphCapturePasses;
}

declare type EHDRCaptureGamut = 'HCGM_Rec709' | 'HCGM_P3DCI' | 'HCGM_Rec2020' | 'HCGM_ACES' | 'HCGM_ACEScg';
declare var EHDRCaptureGamut : { HCGM_Rec709:'HCGM_Rec709',HCGM_P3DCI:'HCGM_P3DCI',HCGM_Rec2020:'HCGM_Rec2020',HCGM_ACES:'HCGM_ACES',HCGM_ACEScg:'HCGM_ACEScg', };
declare class CompositionGraphCaptureSettings extends MovieSceneCaptureProtocolSettings { 
	IncludeRenderPasses: CompositionGraphCapturePasses;
	bCaptureFramesInHDR: boolean;
	HDRCompressionQuality: number;
	CaptureGamut: EHDRCaptureGamut;
	PostProcessingMaterial: SoftObjectPath;
	static Load(ResourceName: string): CompositionGraphCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): CompositionGraphCaptureSettings;
	static GetDefaultObject(): CompositionGraphCaptureSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositionGraphCaptureSettings;
	static C(Other: UObject | any): CompositionGraphCaptureSettings;
}

declare class FrameGrabberProtocolSettings extends MovieSceneCaptureProtocolSettings { 
	static Load(ResourceName: string): FrameGrabberProtocolSettings;
	static Find(Outer: UObject, ResourceName: string): FrameGrabberProtocolSettings;
	static GetDefaultObject(): FrameGrabberProtocolSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FrameGrabberProtocolSettings;
	static C(Other: UObject | any): FrameGrabberProtocolSettings;
}

declare class BmpImageCaptureSettings extends MovieSceneCaptureProtocolSettings { 
	static Load(ResourceName: string): BmpImageCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): BmpImageCaptureSettings;
	static GetDefaultObject(): BmpImageCaptureSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BmpImageCaptureSettings;
	static C(Other: UObject | any): BmpImageCaptureSettings;
}

declare class ImageCaptureSettings extends FrameGrabberProtocolSettings { 
	CompressionQuality: number;
	static Load(ResourceName: string): ImageCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): ImageCaptureSettings;
	static GetDefaultObject(): ImageCaptureSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageCaptureSettings;
	static C(Other: UObject | any): ImageCaptureSettings;
}

declare class MovieSceneCaptureInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneCaptureInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureInterface;
	static GetDefaultObject(): MovieSceneCaptureInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureInterface;
	static C(Other: UObject | any): MovieSceneCaptureInterface;
}

declare class LevelCapture extends MovieSceneCapture { 
	bAutoStartCapture: boolean;
	PrerequisiteActorId: Guid;
	static Load(ResourceName: string): LevelCapture;
	static Find(Outer: UObject, ResourceName: string): LevelCapture;
	static GetDefaultObject(): LevelCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelCapture;
	static C(Other: UObject | any): LevelCapture;
}

declare class MovieSceneCaptureEnvironment extends UObject { 
	static Load(ResourceName: string): MovieSceneCaptureEnvironment;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureEnvironment;
	static GetDefaultObject(): MovieSceneCaptureEnvironment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureEnvironment;
	static GetCaptureFrameNumber(): number;
	static GetCaptureElapsedTime(): number;
	static C(Other: UObject | any): MovieSceneCaptureEnvironment;
}

declare class VideoCaptureSettings extends FrameGrabberProtocolSettings { 
	bUseCompression: boolean;
	CompressionQuality: number;
	VideoCodec: string;
	static Load(ResourceName: string): VideoCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): VideoCaptureSettings;
	static GetDefaultObject(): VideoCaptureSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VideoCaptureSettings;
	static C(Other: UObject | any): VideoCaptureSettings;
}

declare class CameraRig_Crane extends Actor { 
	CranePitch: number;
	CraneYaw: number;
	CraneArmLength: number;
	bLockMountPitch: boolean;
	bLockMountYaw: boolean;
	TransformComponent: SceneComponent;
	CraneYawControl: SceneComponent;
	CranePitchControl: SceneComponent;
	CraneCameraMount: SceneComponent;
	PreviewMesh_CraneArm: StaticMeshComponent;
	PreviewMesh_CraneBase: StaticMeshComponent;
	PreviewMesh_CraneMount: StaticMeshComponent;
	PreviewMesh_CraneCounterWeight: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Crane;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Crane;
	static C(Other: UObject | any): CameraRig_Crane;
}

declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointQuat;
	static C(Other: UObject | any): InterpCurvePointQuat;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveQuat;
	static C(Other: UObject | any): InterpCurveQuat;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointFloat;
	static C(Other: UObject | any): InterpCurvePointFloat;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveFloat;
	static C(Other: UObject | any): InterpCurveFloat;
}

declare class SplineCurves { 
	Position: InterpCurveVector;
	Rotation: InterpCurveQuat;
	Scale: InterpCurveVector;
	ReparamTable: InterpCurveFloat;
	clone() : SplineCurves;
	static C(Other: UObject | any): SplineCurves;
}

declare type ESplineCoordinateSpace = 'Local' | 'World';
declare var ESplineCoordinateSpace : { Local:'Local',World:'World', };
declare type ESplinePointType = 'Linear' | 'Curve' | 'Constant' | 'CurveClamped' | 'CurveCustomTangent';
declare var ESplinePointType : { Linear:'Linear',Curve:'Curve',Constant:'Constant',CurveClamped:'CurveClamped',CurveCustomTangent:'CurveCustomTangent', };
declare class SplinePoint { 
	InputKey: number;
	Position: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	Rotation: Rotator;
	Scale: Vector;
	Type: ESplinePointType;
	clone() : SplinePoint;
	static C(Other: UObject | any): SplinePoint;
}

declare class SplineComponent extends PrimitiveComponent { 
	SplineCurves: SplineCurves;
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bModifiedByConstructionScript: boolean;
	bInputSplinePointsToConstructionScript: boolean;
	bDrawDebug: boolean;
	bClosedLoop: boolean;
	bLoopPositionOverride: boolean;
	LoopPosition: number;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	bAllowDiscontinuousSpline: boolean;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	static Load(ResourceName: string): SplineComponent;
	static Find(Outer: UObject, ResourceName: string): SplineComponent;
	static GetDefaultObject(): SplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	UpdateSpline(): void;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUpVectorAtSplinePoint(PointIndex: number,InUpVector: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentsAtSplinePoint(PointIndex: number,InArriveTangent: Vector,InLeaveTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType,bUpdateSpline: boolean): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetDrawDebug(bShow: boolean): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoopAtPosition(bInClosedLoop: boolean,Key: number,bUpdateSpline: boolean): void;
	SetClosedLoop(bInClosedLoop: boolean,bUpdateSpline: boolean): void;
	RemoveSplinePoint(Index: number,bUpdateSpline: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetLeaveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetArriveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindUpVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindTransformClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	FindTangentClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
	FindRotationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	FindRollClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): number;
	FindRightVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindLocationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
	FindDirectionClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	ClearSplinePoints(bUpdateSpline: boolean): void;
	AddSplineWorldPoint(Position: Vector): void;
	AddSplinePointAtIndex(Position: Vector,Index: number,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplinePoint(Position: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplineLocalPoint(Position: Vector): void;
	AddPoints(Points: SplinePoint[],bUpdateSpline: boolean): void;
	AddPoint(Point: SplinePoint,bUpdateSpline: boolean): void;
	static C(Other: UObject | any): SplineComponent;
}

declare class SplineMeshParams { 
	StartPos: Vector;
	StartTangent: Vector;
	StartScale: Vector2D;
	StartRoll: number;
	StartOffset: Vector2D;
	EndPos: Vector;
	EndTangent: Vector;
	EndScale: Vector2D;
	EndRoll: number;
	EndOffset: Vector2D;
	clone() : SplineMeshParams;
	static C(Other: UObject | any): SplineMeshParams;
}

declare type ESplineMeshAxis = 'X' | 'Y' | 'Z';
declare var ESplineMeshAxis : { X:'X',Y:'Y',Z:'Z', };
declare class SplineMeshComponent extends StaticMeshComponent { 
	SplineParams: SplineMeshParams;
	SplineUpDir: Vector;
	bAllowSplineEditingPerInstance: boolean;
	bSmoothInterpRollScale: boolean;
	ForwardAxis: ESplineMeshAxis;
	SplineBoundaryMin: number;
	SplineBoundaryMax: number;
	BodySetup: BodySetup;
	CachedMeshBodySetupGuid: Guid;
	bSelected: boolean;
	bMeshDirty: boolean;
	static Load(ResourceName: string): SplineMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SplineMeshComponent;
	static GetDefaultObject(): SplineMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshComponent;
	UpdateMesh(): void;
	SetStartTangent(StartTangent: Vector,bUpdateMesh: boolean): void;
	SetStartScale(StartScale: Vector2D,bUpdateMesh: boolean): void;
	SetStartRoll(StartRoll: number,bUpdateMesh: boolean): void;
	SetStartPosition(StartPos: Vector,bUpdateMesh: boolean): void;
	SetStartOffset(StartOffset: Vector2D,bUpdateMesh: boolean): void;
	SetStartAndEnd(StartPos: Vector,StartTangent: Vector,EndPos: Vector,EndTangent: Vector,bUpdateMesh: boolean): void;
	SetSplineUpDir(InSplineUpDir: Vector,bUpdateMesh: boolean): void;
	SetForwardAxis(InForwardAxis: ESplineMeshAxis,bUpdateMesh: boolean): void;
	SetEndTangent(EndTangent: Vector,bUpdateMesh: boolean): void;
	SetEndScale(EndScale: Vector2D,bUpdateMesh: boolean): void;
	SetEndRoll(EndRoll: number,bUpdateMesh: boolean): void;
	SetEndPosition(EndPos: Vector,bUpdateMesh: boolean): void;
	SetEndOffset(EndOffset: Vector2D,bUpdateMesh: boolean): void;
	SetBoundaryMin(InBoundaryMin: number,bUpdateMesh: boolean): void;
	SetBoundaryMax(InBoundaryMax: number,bUpdateMesh: boolean): void;
	GetStartTangent(): Vector;
	GetStartScale(): Vector2D;
	GetStartRoll(): number;
	GetStartPosition(): Vector;
	GetStartOffset(): Vector2D;
	GetSplineUpDir(): Vector;
	GetForwardAxis(): ESplineMeshAxis;
	GetEndTangent(): Vector;
	GetEndScale(): Vector2D;
	GetEndRoll(): number;
	GetEndPosition(): Vector;
	GetEndOffset(): Vector2D;
	GetBoundaryMin(): number;
	GetBoundaryMax(): number;
	static C(Other: UObject | any): SplineMeshComponent;
}

declare class CameraRig_Rail extends Actor { 
	CurrentPositionOnRail: number;
	TransformComponent: SceneComponent;
	RailSplineComponent: SplineComponent;
	RailCameraMount: SceneComponent;
	PreviewMesh_Rail: SplineMeshComponent;
	PreviewRailMeshSegments: SplineMeshComponent[];
	PreviewRailStaticMesh: StaticMesh;
	PreviewMesh_Mount: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Rail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Rail;
	static C(Other: UObject | any): CameraRig_Rail;
}

declare class CameraLookatTrackingSettings { 
	bEnableLookAtTracking: boolean;
	bDrawDebugLookAtTrackingPosition: boolean;
	LookAtTrackingInterpSpeed: number;
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bAllowRoll: boolean;
	clone() : CameraLookatTrackingSettings;
	static C(Other: UObject | any): CameraLookatTrackingSettings;
}

declare class CameraFilmbackSettings { 
	SensorWidth: number;
	SensorHeight: number;
	SensorAspectRatio: number;
	clone() : CameraFilmbackSettings;
	static C(Other: UObject | any): CameraFilmbackSettings;
}

declare class CameraLensSettings { 
	MinFocalLength: number;
	MaxFocalLength: number;
	MinFStop: number;
	MaxFStop: number;
	MinimumFocusDistance: number;
	clone() : CameraLensSettings;
	static C(Other: UObject | any): CameraLensSettings;
}

declare type ECameraFocusMethod = 'None' | 'Manual' | 'Tracking';
declare var ECameraFocusMethod : { None:'None',Manual:'Manual',Tracking:'Tracking', };
declare class CameraTrackingFocusSettings { 
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bDrawDebugTrackingFocusPoint: boolean;
	clone() : CameraTrackingFocusSettings;
	static C(Other: UObject | any): CameraTrackingFocusSettings;
}

declare class CameraFocusSettings { 
	FocusMethod: FocusMethod;
	ManualFocusDistance: number;
	TrackingFocusSettings: CameraTrackingFocusSettings;
	bDrawDebugFocusPlane: boolean;
	DebugFocusPlaneColor: Color;
	bSmoothFocusChanges: boolean;
	FocusSmoothingInterpSpeed: number;
	FocusOffset: number;
	clone() : CameraFocusSettings;
	static C(Other: UObject | any): CameraFocusSettings;
}

declare class NamedFilmbackPreset { 
	Name: string;
	FilmbackSettings: CameraFilmbackSettings;
	clone() : NamedFilmbackPreset;
	static C(Other: UObject | any): NamedFilmbackPreset;
}

declare class NamedLensPreset { 
	Name: string;
	LensSettings: CameraLensSettings;
	clone() : NamedLensPreset;
	static C(Other: UObject | any): NamedLensPreset;
}

declare class CineCameraComponent extends CameraComponent { 
	FilmbackSettings: CameraFilmbackSettings;
	LensSettings: CameraLensSettings;
	FocusSettings: CameraFocusSettings;
	CurrentFocalLength: number;
	CurrentAperture: number;
	CurrentFocusDistance: number;
	CurrentHorizontalFOV: number;
	DebugFocusPlaneMesh: StaticMesh;
	DebugFocusPlaneMaterial: Material;
	DebugFocusPlaneComponent: StaticMeshComponent;
	DebugFocusPlaneMID: MaterialInstanceDynamic;
	FilmbackPresets: NamedFilmbackPreset[];
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPresetName: string;
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	static Load(ResourceName: string): CineCameraComponent;
	static Find(Outer: UObject, ResourceName: string): CineCameraComponent;
	static GetDefaultObject(): CineCameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraComponent;
	SetLensPresetByName(InPresetName: string): void;
	SetFilmbackPresetByName(InPresetName: string): void;
	GetVerticalFieldOfView(): number;
	GetLensPresetName(): string;
	GetHorizontalFieldOfView(): number;
	GetFilmbackPresetName(): string;
	static C(Other: UObject | any): CineCameraComponent;
}

declare class CineCameraActor extends CameraActor { 
	LookatTrackingSettings: CameraLookatTrackingSettings;
	static GetDefaultObject(): CineCameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraActor;
	GetCineCameraComponent(): CineCameraComponent;
	static C(Other: UObject | any): CineCameraActor;
}

declare class K2Node extends EdGraphNode { 
	static Load(ResourceName: string): K2Node;
	static Find(Outer: UObject, ResourceName: string): K2Node;
	static GetDefaultObject(): K2Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node;
	static C(Other: UObject | any): K2Node;
}

declare type EMovieSceneObjectBindingSpace = 'Local' | 'Root';
declare var EMovieSceneObjectBindingSpace : { Local:'Local',Root:'Root', };
declare class MovieSceneObjectBindingID { 
	SequenceID: number;
	Space: Space;
	Guid: Guid;
	clone() : MovieSceneObjectBindingID;
	static C(Other: UObject | any): MovieSceneObjectBindingID;
}

declare class K2Node_GetSequenceBinding extends K2Node { 
	SourceSequence: SoftObjectPath;
	Binding: MovieSceneObjectBindingID;
	static Load(ResourceName: string): K2Node_GetSequenceBinding;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSequenceBinding;
	static GetDefaultObject(): K2Node_GetSequenceBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSequenceBinding;
	static C(Other: UObject | any): K2Node_GetSequenceBinding;
}

declare class GetSequenceBindingGuidMapping { 
	PinName: string;
	Guid: Guid;
	clone() : GetSequenceBindingGuidMapping;
	static C(Other: UObject | any): GetSequenceBindingGuidMapping;
}

declare class K2Node_GetSequenceBindings extends K2Node { 
	BindingGuids: GetSequenceBindingGuidMapping[];
	Sequence: MovieSceneSequence;
	static Load(ResourceName: string): K2Node_GetSequenceBindings;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSequenceBindings;
	static GetDefaultObject(): K2Node_GetSequenceBindings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSequenceBindings;
	static C(Other: UObject | any): K2Node_GetSequenceBindings;
}

declare class MovieSceneToolsPropertyTrackSettings { 
	ComponentName: string;
	PropertyName: string;
	clone() : MovieSceneToolsPropertyTrackSettings;
	static C(Other: UObject | any): MovieSceneToolsPropertyTrackSettings;
}

declare class MovieSceneToolsFbxSettings { 
	FbxPropertyName: string;
	PropertyPath: MovieSceneToolsPropertyTrackSettings;
	clone() : MovieSceneToolsFbxSettings;
	static C(Other: UObject | any): MovieSceneToolsFbxSettings;
}

declare class MovieSceneToolsProjectSettings extends UObject { 
	DefaultStartTime: number;
	DefaultDuration: number;
	ShotDirectory: string;
	ShotPrefix: string;
	FirstShotNumber: any;
	ShotIncrement: any;
	ShotNumDigits: any;
	TakeNumDigits: any;
	FirstTakeNumber: any;
	TakeSeparator: string;
	SubSequenceSeparator: string;
	FbxSettings: MovieSceneToolsFbxSettings[];
	static Load(ResourceName: string): MovieSceneToolsProjectSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneToolsProjectSettings;
	static GetDefaultObject(): MovieSceneToolsProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneToolsProjectSettings;
	static C(Other: UObject | any): MovieSceneToolsProjectSettings;
}

declare type EThumbnailQuality = 'Draft' | 'Normal' | 'Best';
declare var EThumbnailQuality : { Draft:'Draft',Normal:'Normal',Best:'Best', };
declare class MovieSceneUserThumbnailSettings extends UObject { 
	bDrawThumbnails: boolean;
	bDrawSingleThumbnails: boolean;
	ThumbnailSize: IntPoint;
	Quality: Quality;
	static Load(ResourceName: string): MovieSceneUserThumbnailSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserThumbnailSettings;
	static GetDefaultObject(): MovieSceneUserThumbnailSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserThumbnailSettings;
	static C(Other: UObject | any): MovieSceneUserThumbnailSettings;
}

declare class MovieSceneUserImportFBXSettings extends UObject { 
	bForceFrontXAxis: boolean;
	bCreateCameras: boolean;
	static Load(ResourceName: string): MovieSceneUserImportFBXSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserImportFBXSettings;
	static GetDefaultObject(): MovieSceneUserImportFBXSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserImportFBXSettings;
	static C(Other: UObject | any): MovieSceneUserImportFBXSettings;
}

declare class K2Node_ConstructObjectFromClass extends K2Node { 
	static Load(ResourceName: string): K2Node_ConstructObjectFromClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_ConstructObjectFromClass;
	static GetDefaultObject(): K2Node_ConstructObjectFromClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConstructObjectFromClass;
	static C(Other: UObject | any): K2Node_ConstructObjectFromClass;
}

declare class K2Node_CreateDragDropOperation extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_CreateDragDropOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDragDropOperation;
	static GetDefaultObject(): K2Node_CreateDragDropOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDragDropOperation;
	static C(Other: UObject | any): K2Node_CreateDragDropOperation;
}

declare class K2Node_CreateWidget extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_CreateWidget;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateWidget;
	static GetDefaultObject(): K2Node_CreateWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateWidget;
	static C(Other: UObject | any): K2Node_CreateWidget;
}

declare class AutomatedAssetImportData extends UObject { 
	GroupName: string;
	Filenames: string[];
	DestinationPath: string;
	FactoryName: string;
	bReplaceExisting: boolean;
	bSkipReadOnly: boolean;
	Factory: Factory;
	LevelToLoad: string;
	static Load(ResourceName: string): AutomatedAssetImportData;
	static Find(Outer: UObject, ResourceName: string): AutomatedAssetImportData;
	static GetDefaultObject(): AutomatedAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedAssetImportData;
	static C(Other: UObject | any): AutomatedAssetImportData;
}

declare class Factory extends UObject { 
	bCreateNew: boolean;
	SupportedClass: UnrealEngineClass;
	ContextClass: UnrealEngineClass;
	Formats: string[];
	bEditAfterNew: boolean;
	bEditorImport: boolean;
	bText: boolean;
	ImportPriority: number;
	AutomatedImportData: AutomatedAssetImportData;
	OverwriteYesOrNoToAllState: number;
	static Load(ResourceName: string): Factory;
	static Find(Outer: UObject, ResourceName: string): Factory;
	static GetDefaultObject(): Factory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Factory;
	static C(Other: UObject | any): Factory;
}

declare class SlateVectorArtDataFactory extends Factory { 
	static Load(ResourceName: string): SlateVectorArtDataFactory;
	static Find(Outer: UObject, ResourceName: string): SlateVectorArtDataFactory;
	static GetDefaultObject(): SlateVectorArtDataFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateVectorArtDataFactory;
	static C(Other: UObject | any): SlateVectorArtDataFactory;
}

declare class DeveloperSettings extends UObject { 
	static Load(ResourceName: string): DeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettings;
	static GetDefaultObject(): DeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettings;
	static C(Other: UObject | any): DeveloperSettings;
}

declare class DebugResolution { 
	Width: number;
	Height: number;
	Description: string;
	Color: LinearColor;
	clone() : DebugResolution;
	static C(Other: UObject | any): DebugResolution;
}

declare class UMGEditorProjectSettings extends DeveloperSettings { 
	bCookSlowConstructionWidgetTree: boolean;
	DebugResolutions: DebugResolution[];
	bShowWidgetsFromEngineContent: boolean;
	bShowWidgetsFromDeveloperContent: boolean;
	CategoriesToHide: string[];
	WidgetClassesToHide: SoftClassPath[];
	static Load(ResourceName: string): UMGEditorProjectSettings;
	static Find(Outer: UObject, ResourceName: string): UMGEditorProjectSettings;
	static GetDefaultObject(): UMGEditorProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGEditorProjectSettings;
	static C(Other: UObject | any): UMGEditorProjectSettings;
}

declare class EditorPropertyPathSegment { 
	Struct: Struct;
	MemberName: string;
	MemberGuid: Guid;
	IsProperty: boolean;
	clone() : EditorPropertyPathSegment;
	static C(Other: UObject | any): EditorPropertyPathSegment;
}

declare class EditorPropertyPath { 
	Segments: EditorPropertyPathSegment[];
	clone() : EditorPropertyPath;
	static C(Other: UObject | any): EditorPropertyPath;
}

declare type EBindingKind = 'Function' | 'Property';
declare var EBindingKind : { Function:'Function',Property:'Property', };
declare class DelegateEditorBinding { 
	ObjectName: string;
	PropertyName: string;
	FunctionName: string;
	SourceProperty: string;
	SourcePath: EditorPropertyPath;
	MemberGuid: Guid;
	Kind: Kind;
	clone() : DelegateEditorBinding;
	static C(Other: UObject | any): DelegateEditorBinding;
}

declare class WidgetAnimation_DEPRECATED { 
	MovieScene: MovieScene;
	AnimationBindings: WidgetAnimationBinding[];
	clone() : WidgetAnimation_DEPRECATED;
	static C(Other: UObject | any): WidgetAnimation_DEPRECATED;
}

declare class WidgetBlueprint extends Blueprint { 
	WidgetTree: WidgetTree;
	Bindings: DelegateEditorBinding[];
	AnimationData: WidgetAnimation_DEPRECATED[];
	Animations: WidgetAnimation[];
	PaletteCategory: string;
	bForceSlowConstructionPath: boolean;
	static Load(ResourceName: string): WidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprint;
	static GetDefaultObject(): WidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprint;
	static C(Other: UObject | any): WidgetBlueprint;
}

declare class WidgetBlueprintFactory extends Factory { 
	BlueprintType: EBlueprintType;
	ParentClass: UnrealEngineClass;
	static Load(ResourceName: string): WidgetBlueprintFactory;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintFactory;
	static GetDefaultObject(): WidgetBlueprintFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintFactory;
	static C(Other: UObject | any): WidgetBlueprintFactory;
}

declare class WidgetDesignerSettings extends DeveloperSettings { 
	GridSnapEnabled: boolean;
	GridSnapSize: number;
	bLockToPanelOnDragByDefault: boolean;
	bShowOutlines: boolean;
	bExecutePreConstructEvent: boolean;
	bRespectLocks: boolean;
	static Load(ResourceName: string): WidgetDesignerSettings;
	static Find(Outer: UObject, ResourceName: string): WidgetDesignerSettings;
	static GetDefaultObject(): WidgetDesignerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetDesignerSettings;
	static C(Other: UObject | any): WidgetDesignerSettings;
}

declare class BlueprintCallableFunctionRedirect { 
	ClassName: string;
	OldFunctionName: string;
	NewFunctionName: string;
	BlueprintParamName: string;
	ClassParamName: string;
	clone() : BlueprintCallableFunctionRedirect;
	static C(Other: UObject | any): BlueprintCallableFunctionRedirect;
}

declare class EdGraphSchema_K2 extends EdGraphSchema { 
	EditoronlyBPFunctionRedirects: BlueprintCallableFunctionRedirect[];
	static Load(ResourceName: string): EdGraphSchema_K2;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_K2;
	static GetDefaultObject(): EdGraphSchema_K2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_K2;
	static C(Other: UObject | any): EdGraphSchema_K2;
}

declare class WidgetGraphSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): WidgetGraphSchema;
	static Find(Outer: UObject, ResourceName: string): WidgetGraphSchema;
	static GetDefaultObject(): WidgetGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetGraphSchema;
	static C(Other: UObject | any): WidgetGraphSchema;
}

declare class WidgetSlotPair extends UObject { 
	WidgetName: string;
	SlotPropertyNames: string[];
	SlotPropertyValues: string[];
	static Load(ResourceName: string): WidgetSlotPair;
	static Find(Outer: UObject, ResourceName: string): WidgetSlotPair;
	static GetDefaultObject(): WidgetSlotPair;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSlotPair;
	static C(Other: UObject | any): WidgetSlotPair;
}

declare class AudioMixerBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AudioMixerBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AudioMixerBlueprintLibrary;
	static GetDefaultObject(): AudioMixerBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioMixerBlueprintLibrary;
	static SetBypassSourceEffectChainEntry(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number,bBypassed: boolean): void;
	static RemoveSourceEffectFromPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,EntryIndex: number): void;
	static RemoveMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain): number;
	static ClearMasterSubmixEffects(WorldContextObject: UObject): void;
	static AddSourceEffectToPresetChain(WorldContextObject: UObject,PresetChain: SoundEffectSourcePresetChain,Entry: SourceEffectChainEntry): void;
	static AddMasterSubmixEffect(WorldContextObject: UObject,SubmixEffectPreset: SoundEffectSubmixPreset): void;
	static C(Other: UObject | any): AudioMixerBlueprintLibrary;
}

declare type ESubmixEffectDynamicsProcessorType = 'Compressor' | 'Limiter' | 'Expander' | 'Gate' | 'Count';
declare var ESubmixEffectDynamicsProcessorType : { Compressor:'Compressor',Limiter:'Limiter',Expander:'Expander',Gate:'Gate',Count:'Count', };
declare type ESubmixEffectDynamicsPeakMode = 'MeanSquared' | 'RootMeanSquared' | 'Peak' | 'Count';
declare var ESubmixEffectDynamicsPeakMode : { MeanSquared:'MeanSquared',RootMeanSquared:'RootMeanSquared',Peak:'Peak',Count:'Count', };
declare class SubmixEffectDynamicsProcessorSettings { 
	DynamicsProcessorType: DynamicsProcessorType;
	PeakMode: PeakMode;
	LookAheadMsec: number;
	AttackTimeMsec: number;
	ReleaseTimeMsec: number;
	ThresholdDb: number;
	Ratio: number;
	KneeBandwidthDb: number;
	InputGainDb: number;
	OutputGainDb: number;
	bChannelLinked: boolean;
	bAnalogMode: boolean;
	clone() : SubmixEffectDynamicsProcessorSettings;
	static C(Other: UObject | any): SubmixEffectDynamicsProcessorSettings;
}

declare class SubmixEffectDynamicsProcessorPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectDynamicsProcessorSettings;
	static Load(ResourceName: string): SubmixEffectDynamicsProcessorPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectDynamicsProcessorPreset;
	static GetDefaultObject(): SubmixEffectDynamicsProcessorPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectDynamicsProcessorPreset;
	SetSettings(InSettings: SubmixEffectDynamicsProcessorSettings): void;
	static C(Other: UObject | any): SubmixEffectDynamicsProcessorPreset;
}

declare class SubmixEffectEQBand { 
	Frequency: number;
	Bandwidth: number;
	GainDb: number;
	bEnabled: boolean;
	clone() : SubmixEffectEQBand;
	static C(Other: UObject | any): SubmixEffectEQBand;
}

declare class SubmixEffectSubmixEQSettings { 
	EQBands: SubmixEffectEQBand[];
	clone() : SubmixEffectSubmixEQSettings;
	static C(Other: UObject | any): SubmixEffectSubmixEQSettings;
}

declare class SubmixEffectSubmixEQPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectSubmixEQSettings;
	static Load(ResourceName: string): SubmixEffectSubmixEQPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectSubmixEQPreset;
	static GetDefaultObject(): SubmixEffectSubmixEQPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectSubmixEQPreset;
	SetSettings(InSettings: SubmixEffectSubmixEQSettings): void;
	static C(Other: UObject | any): SubmixEffectSubmixEQPreset;
}

declare class SubmixEffectReverbSettings { 
	Density: number;
	Diffusion: number;
	Gain: number;
	GainHF: number;
	DecayTime: number;
	DecayHFRatio: number;
	ReflectionsGain: number;
	ReflectionsDelay: number;
	LateGain: number;
	LateDelay: number;
	AirAbsorptionGainHF: number;
	WetLevel: number;
	clone() : SubmixEffectReverbSettings;
	static C(Other: UObject | any): SubmixEffectReverbSettings;
}

declare class SubmixEffectReverbPreset extends SoundEffectSubmixPreset { 
	Settings: SubmixEffectReverbSettings;
	static Load(ResourceName: string): SubmixEffectReverbPreset;
	static Find(Outer: UObject, ResourceName: string): SubmixEffectReverbPreset;
	static GetDefaultObject(): SubmixEffectReverbPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubmixEffectReverbPreset;
	SetSettingsWithReverbEffect(InReverbEffect: ReverbEffect,WetLevel: number): void;
	SetSettings(InSettings: SubmixEffectReverbSettings): void;
	static C(Other: UObject | any): SubmixEffectReverbPreset;
}

declare class SoundWaveProcedural extends SoundWave { 
	static Load(ResourceName: string): SoundWaveProcedural;
	static Find(Outer: UObject, ResourceName: string): SoundWaveProcedural;
	static GetDefaultObject(): SoundWaveProcedural;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWaveProcedural;
	static C(Other: UObject | any): SoundWaveProcedural;
}

declare class SynthSound extends SoundWaveProcedural { 
	static Load(ResourceName: string): SynthSound;
	static Find(Outer: UObject, ResourceName: string): SynthSound;
	static GetDefaultObject(): SynthSound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthSound;
	static C(Other: UObject | any): SynthSound;
}

declare class SynthComponent extends SceneComponent { 
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bAllowSpatialization: boolean;
	bOverrideAttenuation: boolean;
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	ConcurrencySettings: SoundConcurrency;
	SoundClass: SoundClass;
	SourceEffectChain: SoundEffectSourcePresetChain;
	SoundSubmix: SoundSubmix;
	SoundSubmixSends: SoundSubmixSendInfo[];
	bIsUISound: boolean;
	Synth: SynthSound;
	AudioComponent: AudioComponent;
	static Load(ResourceName: string): SynthComponent;
	static Find(Outer: UObject, ResourceName: string): SynthComponent;
	static GetDefaultObject(): SynthComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthComponent;
	Stop(): void;
	Start(): void;
	SetSubmixSend(Submix: SoundSubmix,SendLevel: number): void;
	IsPlaying(): boolean;
	static C(Other: UObject | any): SynthComponent;
}

declare type EHardwareClass = 'Unspecified' | 'Desktop' | 'Mobile';
declare var EHardwareClass : { Unspecified:'Unspecified',Desktop:'Desktop',Mobile:'Mobile', };
declare type EGraphicsPreset = 'Unspecified' | 'Maximum' | 'Scalable';
declare var EGraphicsPreset : { Unspecified:'Unspecified',Maximum:'Maximum',Scalable:'Scalable', };
declare class HardwareTargetingSettings extends UObject { 
	TargetedHardwareClass: EHardwareClass;
	AppliedTargetedHardwareClass: EHardwareClass;
	DefaultGraphicsPerformance: EGraphicsPreset;
	AppliedDefaultGraphicsPerformance: EGraphicsPreset;
	static Load(ResourceName: string): HardwareTargetingSettings;
	static Find(Outer: UObject, ResourceName: string): HardwareTargetingSettings;
	static GetDefaultObject(): HardwareTargetingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HardwareTargetingSettings;
	static C(Other: UObject | any): HardwareTargetingSettings;
}

declare class ClassViewerProjectSettings extends UObject { 
	InternalOnlyPaths: DirectoryPath[];
	InternalOnlyClasses: SoftClassPath[];
	static Load(ResourceName: string): ClassViewerProjectSettings;
	static Find(Outer: UObject, ResourceName: string): ClassViewerProjectSettings;
	static GetDefaultObject(): ClassViewerProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassViewerProjectSettings;
	static C(Other: UObject | any): ClassViewerProjectSettings;
}

declare class LocalizedTemplateString { 
	Language: string;
	Text: string;
	clone() : LocalizedTemplateString;
	static C(Other: UObject | any): LocalizedTemplateString;
}

declare class TemplateFolderRename { 
	From: string;
	To: string;
	clone() : TemplateFolderRename;
	static C(Other: UObject | any): TemplateFolderRename;
}

declare class TemplateReplacement { 
	Extensions: string[];
	From: string;
	To: string;
	bCaseSensitive: boolean;
	clone() : TemplateReplacement;
	static C(Other: UObject | any): TemplateReplacement;
}

declare type EFeaturePackDetailLevel = 'Standard' | 'High';
declare var EFeaturePackDetailLevel : { Standard:'Standard',High:'High', };
declare class FeaturePackLevelSet { 
	DetailLevels: DetailLevels[];
	MountName: string;
	clone() : FeaturePackLevelSet;
	static C(Other: UObject | any): FeaturePackLevelSet;
}

declare class TemplateProjectDefs extends UObject { 
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	FoldersToIgnore: string[];
	FilesToIgnore: string[];
	FolderRenames: TemplateFolderRename[];
	FilenameReplacements: TemplateReplacement[];
	ReplacementsInFiles: TemplateReplacement[];
	SortKey: string;
	Category: string;
	ClassTypes: string;
	AssetTypes: string;
	bAllowProjectCreation: boolean;
	PacksToInclude: string[];
	EditDetailLevelPreference: EditDetailLevelPreference;
	SharedContentPacks: FeaturePackLevelSet[];
	static Load(ResourceName: string): TemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): TemplateProjectDefs;
	static GetDefaultObject(): TemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateProjectDefs;
	static C(Other: UObject | any): TemplateProjectDefs;
}

declare class DefaultTemplateProjectDefs extends TemplateProjectDefs { 
	static Load(ResourceName: string): DefaultTemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): DefaultTemplateProjectDefs;
	static GetDefaultObject(): DefaultTemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultTemplateProjectDefs;
	static C(Other: UObject | any): DefaultTemplateProjectDefs;
}

declare class SourceControlHelpers extends UObject { 
	static Load(ResourceName: string): SourceControlHelpers;
	static Find(Outer: UObject, ResourceName: string): SourceControlHelpers;
	static GetDefaultObject(): SourceControlHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlHelpers;
	static PackageFilenames(InPackageNames: string[]): string[];
	static PackageFilename(InPackageName: string): string;
	static MarkFileForAdd(InFile: string): boolean;
	static CopyFileUnderSourceControl(InDestFile: string,InSourceFile: string,InFileDescription: string,OutFailReason?: string): {OutFailReason: string, $: boolean};
	static CheckOutFile(InFile: string): boolean;
	static AbsoluteFilenames(InFileNames: string[]): string[];
	static C(Other: UObject | any): SourceControlHelpers;
}

declare class FavoritedBlueprintPaletteItem { 
	clone() : FavoritedBlueprintPaletteItem;
	static C(Other: UObject | any): FavoritedBlueprintPaletteItem;
}

declare class BlueprintPaletteFavorites extends UObject { 
	CustomFavorites: string[];
	CurrentFavorites: FavoritedBlueprintPaletteItem[];
	CurrentProfile: string;
	static Load(ResourceName: string): BlueprintPaletteFavorites;
	static Find(Outer: UObject, ResourceName: string): BlueprintPaletteFavorites;
	static GetDefaultObject(): BlueprintPaletteFavorites;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintPaletteFavorites;
	static C(Other: UObject | any): BlueprintPaletteFavorites;
}

declare class K2Node_BaseAsyncTask extends K2Node { 
	ProxyFactoryFunctionName: string;
	ProxyFactoryClass: UnrealEngineClass;
	ProxyClass: UnrealEngineClass;
	ProxyActivateFunctionName: string;
	static Load(ResourceName: string): K2Node_BaseAsyncTask;
	static Find(Outer: UObject, ResourceName: string): K2Node_BaseAsyncTask;
	static GetDefaultObject(): K2Node_BaseAsyncTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseAsyncTask;
	static C(Other: UObject | any): K2Node_BaseAsyncTask;
}

declare class K2Node_AsyncAction extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_AsyncAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_AsyncAction;
	static GetDefaultObject(): K2Node_AsyncAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AsyncAction;
	static C(Other: UObject | any): K2Node_AsyncAction;
}

declare class BlueprintNodeSpawner extends UObject { 
	NodeClass: UnrealEngineClass;
	static Load(ResourceName: string): BlueprintNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintNodeSpawner;
	static GetDefaultObject(): BlueprintNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintNodeSpawner;
	static C(Other: UObject | any): BlueprintNodeSpawner;
}

declare class BlueprintEventNodeSpawner extends BlueprintNodeSpawner { 
	EventFunc: UFunction;
	CustomEventName: string;
	static Load(ResourceName: string): BlueprintEventNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintEventNodeSpawner;
	static GetDefaultObject(): BlueprintEventNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEventNodeSpawner;
	static C(Other: UObject | any): BlueprintEventNodeSpawner;
}

declare class BlueprintBoundEventNodeSpawner extends BlueprintEventNodeSpawner { 
	EventDelegate: MulticastDelegateProperty;
	static Load(ResourceName: string): BlueprintBoundEventNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintBoundEventNodeSpawner;
	static GetDefaultObject(): BlueprintBoundEventNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundEventNodeSpawner;
	static C(Other: UObject | any): BlueprintBoundEventNodeSpawner;
}

declare class BlueprintBoundNodeSpawner extends BlueprintNodeSpawner { 
	static Load(ResourceName: string): BlueprintBoundNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintBoundNodeSpawner;
	static GetDefaultObject(): BlueprintBoundNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundNodeSpawner;
	static C(Other: UObject | any): BlueprintBoundNodeSpawner;
}

declare class BlueprintComponentNodeSpawner extends BlueprintNodeSpawner { 
	ComponentClass: UnrealEngineClass;
	ComponentName: string;
	ComponentAssetName: string;
	static Load(ResourceName: string): BlueprintComponentNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintComponentNodeSpawner;
	static GetDefaultObject(): BlueprintComponentNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintComponentNodeSpawner;
	static C(Other: UObject | any): BlueprintComponentNodeSpawner;
}

declare class BlueprintFieldNodeSpawner extends BlueprintNodeSpawner { 
	Field: Field;
	static Load(ResourceName: string): BlueprintFieldNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintFieldNodeSpawner;
	static GetDefaultObject(): BlueprintFieldNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFieldNodeSpawner;
	static C(Other: UObject | any): BlueprintFieldNodeSpawner;
}

declare class BlueprintDelegateNodeSpawner extends BlueprintFieldNodeSpawner { 
	static Load(ResourceName: string): BlueprintDelegateNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintDelegateNodeSpawner;
	static GetDefaultObject(): BlueprintDelegateNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintDelegateNodeSpawner;
	static C(Other: UObject | any): BlueprintDelegateNodeSpawner;
}

declare type ESaveOnCompile = 'SoC_Never' | 'SoC_SuccessOnly' | 'SoC_Always';
declare var ESaveOnCompile : { SoC_Never:'SoC_Never',SoC_SuccessOnly:'SoC_SuccessOnly',SoC_Always:'SoC_Always', };
declare class BlueprintEditorSettings extends UObject { 
	bDrawMidpointArrowsInBlueprints: boolean;
	bShowGraphInstructionText: boolean;
	bSplitContextTargetSettings: boolean;
	bExposeAllMemberComponentFunctions: boolean;
	bShowContextualFavorites: boolean;
	bCompactCallOnMemberNodes: boolean;
	bFlattenFavoritesMenus: boolean;
	bFavorPureCastNodes: boolean;
	bAutoCastObjectConnections: boolean;
	bShowViewportOnSimulate: boolean;
	bShowInheritedVariables: boolean;
	bShowEmptySections: boolean;
	bSpawnDefaultBlueprintNodes: boolean;
	bHideConstructionScriptComponentsInDetailsView: boolean;
	bHostFindInBlueprintsInGlobalTab: boolean;
	SaveOnCompile: ESaveOnCompile;
	bJumpToNodeErrors: boolean;
	bAllowExplicitImpureNodeDisabling: boolean;
	bShowActionMenuItemSignatures: boolean;
	bBlueprintNodeUniqueNames: boolean;
	bShowDetailedCompileResults: boolean;
	CompileEventDisplayThresholdMs: number;
	NodeTemplateCacheCapMB: number;
	static Load(ResourceName: string): BlueprintEditorSettings;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorSettings;
	static GetDefaultObject(): BlueprintEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorSettings;
	static C(Other: UObject | any): BlueprintEditorSettings;
}

declare class BlueprintFunctionNodeSpawner extends BlueprintFieldNodeSpawner { 
	static Load(ResourceName: string): BlueprintFunctionNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionNodeSpawner;
	static GetDefaultObject(): BlueprintFunctionNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionNodeSpawner;
	static C(Other: UObject | any): BlueprintFunctionNodeSpawner;
}

declare class BlueprintVariableNodeSpawner extends BlueprintFieldNodeSpawner { 
	LocalVarOuter: EdGraph;
	LocalVarDesc: BPVariableDescription;
	static Load(ResourceName: string): BlueprintVariableNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintVariableNodeSpawner;
	static GetDefaultObject(): BlueprintVariableNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintVariableNodeSpawner;
	static C(Other: UObject | any): BlueprintVariableNodeSpawner;
}

declare class K2Node_EditablePinBase extends K2Node { 
	bIsEditable: boolean;
	static Load(ResourceName: string): K2Node_EditablePinBase;
	static Find(Outer: UObject, ResourceName: string): K2Node_EditablePinBase;
	static GetDefaultObject(): K2Node_EditablePinBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EditablePinBase;
	static C(Other: UObject | any): K2Node_EditablePinBase;
}

declare class MemberReference { 
	MemberParent: UObject;
	MemberScope: string;
	MemberName: string;
	MemberGuid: Guid;
	bSelfContext: boolean;
	bWasDeprecated: boolean;
	clone() : MemberReference;
	static C(Other: UObject | any): MemberReference;
}

declare class K2Node_Event extends K2Node_EditablePinBase { 
	EventSignatureName: string;
	EventSignatureClass: UnrealEngineClass;
	EventReference: MemberReference;
	bOverrideFunction: boolean;
	bInternalEvent: boolean;
	CustomFunctionName: string;
	FunctionFlags: any;
	static Load(ResourceName: string): K2Node_Event;
	static Find(Outer: UObject, ResourceName: string): K2Node_Event;
	static GetDefaultObject(): K2Node_Event;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Event;
	static C(Other: UObject | any): K2Node_Event;
}

declare class K2Node_ActorBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	EventOwner: Actor;
	static Load(ResourceName: string): K2Node_ActorBoundEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_ActorBoundEvent;
	static GetDefaultObject(): K2Node_ActorBoundEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ActorBoundEvent;
	static C(Other: UObject | any): K2Node_ActorBoundEvent;
}

declare class K2Node_CallFunction extends K2Node { 
	bIsPureFunc: boolean;
	bIsConstFunc: boolean;
	bWantsEnumToExecExpansion: boolean;
	bIsInterfaceCall: boolean;
	bIsFinalFunction: boolean;
	bIsBeadFunction: boolean;
	FunctionReference: MemberReference;
	CallFunctionName: string;
	CallFunctionClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_CallFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallFunction;
	static GetDefaultObject(): K2Node_CallFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunction;
	static C(Other: UObject | any): K2Node_CallFunction;
}

declare class K2Node_AddComponent extends K2Node_CallFunction { 
	bHasExposedVariable: boolean;
	TemplateBlueprint: string;
	TemplateType: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_AddComponent;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddComponent;
	static GetDefaultObject(): K2Node_AddComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddComponent;
	static C(Other: UObject | any): K2Node_AddComponent;
}

declare class K2Node_BaseMCDelegate extends K2Node { 
	DelegateReference: MemberReference;
	static Load(ResourceName: string): K2Node_BaseMCDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_BaseMCDelegate;
	static GetDefaultObject(): K2Node_BaseMCDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseMCDelegate;
	static C(Other: UObject | any): K2Node_BaseMCDelegate;
}

declare class K2Node_AddDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_AddDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddDelegate;
	static GetDefaultObject(): K2Node_AddDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddDelegate;
	static C(Other: UObject | any): K2Node_AddDelegate;
}

declare class K2Node_AddPinInterface extends Interface { 
	static Load(ResourceName: string): K2Node_AddPinInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddPinInterface;
	static GetDefaultObject(): K2Node_AddPinInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddPinInterface;
	static C(Other: UObject | any): K2Node_AddPinInterface;
}

declare class K2Node_AssignDelegate extends K2Node_AddDelegate { 
	static Load(ResourceName: string): K2Node_AssignDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_AssignDelegate;
	static GetDefaultObject(): K2Node_AssignDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignDelegate;
	static C(Other: UObject | any): K2Node_AssignDelegate;
}

declare class K2Node_AssignmentStatement extends K2Node { 
	static Load(ResourceName: string): K2Node_AssignmentStatement;
	static Find(Outer: UObject, ResourceName: string): K2Node_AssignmentStatement;
	static GetDefaultObject(): K2Node_AssignmentStatement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignmentStatement;
	static C(Other: UObject | any): K2Node_AssignmentStatement;
}

declare class K2Node_BitmaskLiteral extends K2Node { 
	BitflagsEnum: Enum;
	static Load(ResourceName: string): K2Node_BitmaskLiteral;
	static Find(Outer: UObject, ResourceName: string): K2Node_BitmaskLiteral;
	static GetDefaultObject(): K2Node_BitmaskLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BitmaskLiteral;
	static C(Other: UObject | any): K2Node_BitmaskLiteral;
}

declare type ESelfContextInfo = 'Unspecified' | 'NotSelfContext';
declare var ESelfContextInfo : { Unspecified:'Unspecified',NotSelfContext:'NotSelfContext', };
declare class K2Node_Variable extends K2Node { 
	VariableReference: MemberReference;
	SelfContextInfo: ESelfContextInfo;
	VariableSourceClass: UnrealEngineClass;
	VariableName: string;
	bSelfContext: boolean;
	static Load(ResourceName: string): K2Node_Variable;
	static Find(Outer: UObject, ResourceName: string): K2Node_Variable;
	static GetDefaultObject(): K2Node_Variable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Variable;
	static C(Other: UObject | any): K2Node_Variable;
}

declare class K2Node_StructOperation extends K2Node_Variable { 
	StructType: ScriptStruct;
	static Load(ResourceName: string): K2Node_StructOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructOperation;
	static GetDefaultObject(): K2Node_StructOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructOperation;
	static C(Other: UObject | any): K2Node_StructOperation;
}

declare class OptionalPinFromProperty { 
	PropertyName: string;
	PropertyFriendlyName: string;
	PropertyTooltip: string;
	CategoryName: string;
	bShowPin: boolean;
	bCanToggleVisibility: boolean;
	bPropertyIsCustomized: boolean;
	bHasOverridePin: boolean;
	bIsMarkedForAdvancedDisplay: boolean;
	bIsOverrideEnabled: boolean;
	bIsSetValuePinVisible: boolean;
	bIsOverridePinVisible: boolean;
	clone() : OptionalPinFromProperty;
	static C(Other: UObject | any): OptionalPinFromProperty;
}

declare class K2Node_StructMemberGet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): K2Node_StructMemberGet;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructMemberGet;
	static GetDefaultObject(): K2Node_StructMemberGet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberGet;
	static C(Other: UObject | any): K2Node_StructMemberGet;
}

declare class K2Node_BreakStruct extends K2Node_StructMemberGet { 
	bMadeAfterOverridePinRemoval: boolean;
	static Load(ResourceName: string): K2Node_BreakStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_BreakStruct;
	static GetDefaultObject(): K2Node_BreakStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BreakStruct;
	static C(Other: UObject | any): K2Node_BreakStruct;
}

declare class K2Node_CallArrayFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallArrayFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallArrayFunction;
	static GetDefaultObject(): K2Node_CallArrayFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallArrayFunction;
	static C(Other: UObject | any): K2Node_CallArrayFunction;
}

declare class K2Node_CallDataTableFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallDataTableFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallDataTableFunction;
	static GetDefaultObject(): K2Node_CallDataTableFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDataTableFunction;
	static C(Other: UObject | any): K2Node_CallDataTableFunction;
}

declare class K2Node_CallDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_CallDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallDelegate;
	static GetDefaultObject(): K2Node_CallDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDelegate;
	static C(Other: UObject | any): K2Node_CallDelegate;
}

declare class K2Node_CallFunctionOnMember extends K2Node_CallFunction { 
	MemberVariableToCallOn: MemberReference;
	static Load(ResourceName: string): K2Node_CallFunctionOnMember;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallFunctionOnMember;
	static GetDefaultObject(): K2Node_CallFunctionOnMember;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunctionOnMember;
	static C(Other: UObject | any): K2Node_CallFunctionOnMember;
}

declare class K2Node_CallMaterialParameterCollectionFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static GetDefaultObject(): K2Node_CallMaterialParameterCollectionFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallMaterialParameterCollectionFunction;
	static C(Other: UObject | any): K2Node_CallMaterialParameterCollectionFunction;
}

declare class K2Node_CallParentFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallParentFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallParentFunction;
	static GetDefaultObject(): K2Node_CallParentFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallParentFunction;
	static C(Other: UObject | any): K2Node_CallParentFunction;
}

declare class K2Node_CastByteToEnum extends K2Node { 
	Enum: Enum;
	bSafe: boolean;
	static Load(ResourceName: string): K2Node_CastByteToEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_CastByteToEnum;
	static GetDefaultObject(): K2Node_CastByteToEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CastByteToEnum;
	static C(Other: UObject | any): K2Node_CastByteToEnum;
}

declare class K2Node_DynamicCast extends K2Node { 
	TargetType: UnrealEngineClass;
	bIsPureCast: boolean;
	static Load(ResourceName: string): K2Node_DynamicCast;
	static Find(Outer: UObject, ResourceName: string): K2Node_DynamicCast;
	static GetDefaultObject(): K2Node_DynamicCast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DynamicCast;
	static C(Other: UObject | any): K2Node_DynamicCast;
}

declare class K2Node_ClassDynamicCast extends K2Node_DynamicCast { 
	static Load(ResourceName: string): K2Node_ClassDynamicCast;
	static Find(Outer: UObject, ResourceName: string): K2Node_ClassDynamicCast;
	static GetDefaultObject(): K2Node_ClassDynamicCast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClassDynamicCast;
	static C(Other: UObject | any): K2Node_ClassDynamicCast;
}

declare class K2Node_ClearDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_ClearDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_ClearDelegate;
	static GetDefaultObject(): K2Node_ClearDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClearDelegate;
	static C(Other: UObject | any): K2Node_ClearDelegate;
}

declare class K2Node_CommutativeAssociativeBinaryOperator extends K2Node_CallFunction { 
	NumAdditionalInputs: number;
	static Load(ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static Find(Outer: UObject, ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static GetDefaultObject(): K2Node_CommutativeAssociativeBinaryOperator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CommutativeAssociativeBinaryOperator;
	static C(Other: UObject | any): K2Node_CommutativeAssociativeBinaryOperator;
}

declare class K2Node_ComponentBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	ComponentPropertyName: string;
	DelegatePropertyDisplayName: string;
	static Load(ResourceName: string): K2Node_ComponentBoundEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_ComponentBoundEvent;
	static GetDefaultObject(): K2Node_ComponentBoundEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ComponentBoundEvent;
	static C(Other: UObject | any): K2Node_ComponentBoundEvent;
}

declare class KismetUserDeclaredFunctionMetadata { 
	ToolTip: string;
	Category: string;
	Keywords: string;
	CompactNodeTitle: string;
	InstanceTitleColor: LinearColor;
	bCallInEditor: boolean;
	HasLatentFunctions: any;
	clone() : KismetUserDeclaredFunctionMetadata;
	static C(Other: UObject | any): KismetUserDeclaredFunctionMetadata;
}

declare class K2Node_Tunnel extends K2Node_EditablePinBase { 
	OutputSourceNode: K2Node_Tunnel;
	InputSinkNode: K2Node_Tunnel;
	bCanHaveInputs: boolean;
	bCanHaveOutputs: boolean;
	MetaData: KismetUserDeclaredFunctionMetadata;
	static Load(ResourceName: string): K2Node_Tunnel;
	static Find(Outer: UObject, ResourceName: string): K2Node_Tunnel;
	static GetDefaultObject(): K2Node_Tunnel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Tunnel;
	static C(Other: UObject | any): K2Node_Tunnel;
}

declare class K2Node_Composite extends K2Node_Tunnel { 
	BoundGraph: EdGraph;
	static Load(ResourceName: string): K2Node_Composite;
	static Find(Outer: UObject, ResourceName: string): K2Node_Composite;
	static GetDefaultObject(): K2Node_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Composite;
	static C(Other: UObject | any): K2Node_Composite;
}

declare class K2Node_ConvertAsset extends K2Node { 
	static Load(ResourceName: string): K2Node_ConvertAsset;
	static Find(Outer: UObject, ResourceName: string): K2Node_ConvertAsset;
	static GetDefaultObject(): K2Node_ConvertAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConvertAsset;
	static C(Other: UObject | any): K2Node_ConvertAsset;
}

declare class K2Node_Copy extends K2Node { 
	static Load(ResourceName: string): K2Node_Copy;
	static Find(Outer: UObject, ResourceName: string): K2Node_Copy;
	static GetDefaultObject(): K2Node_Copy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Copy;
	static C(Other: UObject | any): K2Node_Copy;
}

declare class K2Node_CreateDelegate extends K2Node { 
	SelectedFunctionName: string;
	SelectedFunctionGuid: Guid;
	static Load(ResourceName: string): K2Node_CreateDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDelegate;
	static GetDefaultObject(): K2Node_CreateDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDelegate;
	static C(Other: UObject | any): K2Node_CreateDelegate;
}

declare class K2Node_CustomEvent extends K2Node_Event { 
	bCallInEditor: boolean;
	static Load(ResourceName: string): K2Node_CustomEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_CustomEvent;
	static GetDefaultObject(): K2Node_CustomEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CustomEvent;
	static C(Other: UObject | any): K2Node_CustomEvent;
}

declare class K2Node_DeadClass extends K2Node { 
	static Load(ResourceName: string): K2Node_DeadClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_DeadClass;
	static GetDefaultObject(): K2Node_DeadClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DeadClass;
	static C(Other: UObject | any): K2Node_DeadClass;
}

declare class K2Node_DelegateSet extends K2Node { 
	DelegatePropertyName: string;
	DelegatePropertyClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_DelegateSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_DelegateSet;
	static GetDefaultObject(): K2Node_DelegateSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DelegateSet;
	static C(Other: UObject | any): K2Node_DelegateSet;
}

declare class K2Node_TemporaryVariable extends K2Node { 
	VariableType: EdGraphPinType;
	bIsPersistent: boolean;
	static Load(ResourceName: string): K2Node_TemporaryVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_TemporaryVariable;
	static GetDefaultObject(): K2Node_TemporaryVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TemporaryVariable;
	static C(Other: UObject | any): K2Node_TemporaryVariable;
}

declare class K2Node_DoOnceMultiInput extends K2Node { 
	NumAdditionalInputs: number;
	DataNode: K2Node_TemporaryVariable;
	static Load(ResourceName: string): K2Node_DoOnceMultiInput;
	static Find(Outer: UObject, ResourceName: string): K2Node_DoOnceMultiInput;
	static GetDefaultObject(): K2Node_DoOnceMultiInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DoOnceMultiInput;
	static C(Other: UObject | any): K2Node_DoOnceMultiInput;
}

declare class K2Node_EaseFunction extends K2Node { 
	EaseFunctionName: string;
	static Load(ResourceName: string): K2Node_EaseFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_EaseFunction;
	static GetDefaultObject(): K2Node_EaseFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EaseFunction;
	static C(Other: UObject | any): K2Node_EaseFunction;
}

declare class K2Node_EnumEquality extends K2Node { 
	static Load(ResourceName: string): K2Node_EnumEquality;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumEquality;
	static GetDefaultObject(): K2Node_EnumEquality;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumEquality;
	static C(Other: UObject | any): K2Node_EnumEquality;
}

declare class K2Node_EnumInequality extends K2Node_EnumEquality { 
	static Load(ResourceName: string): K2Node_EnumInequality;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumInequality;
	static GetDefaultObject(): K2Node_EnumInequality;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumInequality;
	static C(Other: UObject | any): K2Node_EnumInequality;
}

declare class K2Node_EnumLiteral extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_EnumLiteral;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumLiteral;
	static GetDefaultObject(): K2Node_EnumLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumLiteral;
	static C(Other: UObject | any): K2Node_EnumLiteral;
}

declare class K2Node_ExecutionSequence extends K2Node { 
	static Load(ResourceName: string): K2Node_ExecutionSequence;
	static Find(Outer: UObject, ResourceName: string): K2Node_ExecutionSequence;
	static GetDefaultObject(): K2Node_ExecutionSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ExecutionSequence;
	static C(Other: UObject | any): K2Node_ExecutionSequence;
}

declare class K2Node_ForEachElementInEnum extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_ForEachElementInEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_ForEachElementInEnum;
	static GetDefaultObject(): K2Node_ForEachElementInEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ForEachElementInEnum;
	static C(Other: UObject | any): K2Node_ForEachElementInEnum;
}

declare class K2Node_FormatText extends K2Node { 
	PinNames: string[];
	static Load(ResourceName: string): K2Node_FormatText;
	static Find(Outer: UObject, ResourceName: string): K2Node_FormatText;
	static GetDefaultObject(): K2Node_FormatText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FormatText;
	static C(Other: UObject | any): K2Node_FormatText;
}

declare class K2Node_FunctionTerminator extends K2Node_EditablePinBase { 
	SignatureClass: UnrealEngineClass;
	SignatureName: string;
	static Load(ResourceName: string): K2Node_FunctionTerminator;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionTerminator;
	static GetDefaultObject(): K2Node_FunctionTerminator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionTerminator;
	static C(Other: UObject | any): K2Node_FunctionTerminator;
}

declare class K2Node_FunctionEntry extends K2Node_FunctionTerminator { 
	CustomGeneratedFunctionName: string;
	MetaData: KismetUserDeclaredFunctionMetadata;
	LocalVariables: BPVariableDescription[];
	bEnforceConstCorrectness: boolean;
	ExtraFlags: number;
	static Load(ResourceName: string): K2Node_FunctionEntry;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionEntry;
	static GetDefaultObject(): K2Node_FunctionEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionEntry;
	static C(Other: UObject | any): K2Node_FunctionEntry;
}

declare class K2Node_FunctionResult extends K2Node_FunctionTerminator { 
	static Load(ResourceName: string): K2Node_FunctionResult;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionResult;
	static GetDefaultObject(): K2Node_FunctionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionResult;
	static C(Other: UObject | any): K2Node_FunctionResult;
}

declare class K2Node_GenericCreateObject extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_GenericCreateObject;
	static Find(Outer: UObject, ResourceName: string): K2Node_GenericCreateObject;
	static GetDefaultObject(): K2Node_GenericCreateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GenericCreateObject;
	static C(Other: UObject | any): K2Node_GenericCreateObject;
}

declare class K2Node_GetArrayItem extends K2Node { 
	bReturnByRefDesired: boolean;
	static Load(ResourceName: string): K2Node_GetArrayItem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetArrayItem;
	static GetDefaultObject(): K2Node_GetArrayItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetArrayItem;
	static C(Other: UObject | any): K2Node_GetArrayItem;
}

declare class K2Node_GetClassDefaults extends K2Node { 
	BlueprintSubscribedTo: Blueprint;
	ShowPinForProperties: OptionalPinFromProperty[];
	bExcludeObjectContainers: boolean;
	bExcludeObjectArrays: boolean;
	static Load(ResourceName: string): K2Node_GetClassDefaults;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetClassDefaults;
	static GetDefaultObject(): K2Node_GetClassDefaults;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetClassDefaults;
	static C(Other: UObject | any): K2Node_GetClassDefaults;
}

declare class K2Node_GetDataTableRow extends K2Node { 
	static Load(ResourceName: string): K2Node_GetDataTableRow;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetDataTableRow;
	static GetDefaultObject(): K2Node_GetDataTableRow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetDataTableRow;
	static C(Other: UObject | any): K2Node_GetDataTableRow;
}

declare class K2Node_GetEnumeratorName extends K2Node { 
	static Load(ResourceName: string): K2Node_GetEnumeratorName;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEnumeratorName;
	static GetDefaultObject(): K2Node_GetEnumeratorName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorName;
	static C(Other: UObject | any): K2Node_GetEnumeratorName;
}

declare class K2Node_GetEnumeratorNameAsString extends K2Node_GetEnumeratorName { 
	static Load(ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static GetDefaultObject(): K2Node_GetEnumeratorNameAsString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorNameAsString;
	static C(Other: UObject | any): K2Node_GetEnumeratorNameAsString;
}

declare class K2Node_GetInputAxisKeyValue extends K2Node_CallFunction { 
	InputAxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_GetInputAxisKeyValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputAxisKeyValue;
	static GetDefaultObject(): K2Node_GetInputAxisKeyValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisKeyValue;
	static C(Other: UObject | any): K2Node_GetInputAxisKeyValue;
}

declare class K2Node_GetInputAxisValue extends K2Node_CallFunction { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_GetInputAxisValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputAxisValue;
	static GetDefaultObject(): K2Node_GetInputAxisValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisValue;
	static C(Other: UObject | any): K2Node_GetInputAxisValue;
}

declare class K2Node_GetInputVectorAxisValue extends K2Node_GetInputAxisKeyValue { 
	static Load(ResourceName: string): K2Node_GetInputVectorAxisValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputVectorAxisValue;
	static GetDefaultObject(): K2Node_GetInputVectorAxisValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputVectorAxisValue;
	static C(Other: UObject | any): K2Node_GetInputVectorAxisValue;
}

declare class K2Node_GetNumEnumEntries extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_GetNumEnumEntries;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetNumEnumEntries;
	static GetDefaultObject(): K2Node_GetNumEnumEntries;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetNumEnumEntries;
	static C(Other: UObject | any): K2Node_GetNumEnumEntries;
}

declare class K2Node_IfThenElse extends K2Node { 
	static Load(ResourceName: string): K2Node_IfThenElse;
	static Find(Outer: UObject, ResourceName: string): K2Node_IfThenElse;
	static GetDefaultObject(): K2Node_IfThenElse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_IfThenElse;
	static C(Other: UObject | any): K2Node_IfThenElse;
}

declare class K2Node_InputAction extends K2Node { 
	InputActionName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAction;
	static GetDefaultObject(): K2Node_InputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAction;
	static C(Other: UObject | any): K2Node_InputAction;
}

declare class K2Node_InputActionEvent extends K2Node_Event { 
	InputActionName: string;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputActionEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputActionEvent;
	static GetDefaultObject(): K2Node_InputActionEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputActionEvent;
	static C(Other: UObject | any): K2Node_InputActionEvent;
}

declare class K2Node_InputAxisEvent extends K2Node_Event { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAxisEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAxisEvent;
	static GetDefaultObject(): K2Node_InputAxisEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisEvent;
	static C(Other: UObject | any): K2Node_InputAxisEvent;
}

declare class K2Node_InputAxisKeyEvent extends K2Node_Event { 
	AxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAxisKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAxisKeyEvent;
	static GetDefaultObject(): K2Node_InputAxisKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisKeyEvent;
	static C(Other: UObject | any): K2Node_InputAxisKeyEvent;
}

declare class K2Node_InputKey extends K2Node { 
	InputKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	bControl: boolean;
	bAlt: boolean;
	bShift: boolean;
	bCommand: boolean;
	static Load(ResourceName: string): K2Node_InputKey;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputKey;
	static GetDefaultObject(): K2Node_InputKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKey;
	static C(Other: UObject | any): K2Node_InputKey;
}

declare class InputChord { 
	Key: Key;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
	clone() : InputChord;
	static C(Other: UObject | any): InputChord;
	EqualEqual_InputChordInputChord(B: InputChord): boolean;
	static EqualEqual_InputChordInputChord(A: InputChord,B: InputChord): boolean;
}

declare class K2Node_InputKeyEvent extends K2Node_Event { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputKeyEvent;
	static GetDefaultObject(): K2Node_InputKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKeyEvent;
	static C(Other: UObject | any): K2Node_InputKeyEvent;
}

declare class K2Node_InputTouch extends K2Node { 
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputTouch;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputTouch;
	static GetDefaultObject(): K2Node_InputTouch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouch;
	static C(Other: UObject | any): K2Node_InputTouch;
}

declare class K2Node_InputTouchEvent extends K2Node_Event { 
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputTouchEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputTouchEvent;
	static GetDefaultObject(): K2Node_InputTouchEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouchEvent;
	static C(Other: UObject | any): K2Node_InputTouchEvent;
}

declare class K2Node_InputVectorAxisEvent extends K2Node_InputAxisKeyEvent { 
	static Load(ResourceName: string): K2Node_InputVectorAxisEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputVectorAxisEvent;
	static GetDefaultObject(): K2Node_InputVectorAxisEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputVectorAxisEvent;
	static C(Other: UObject | any): K2Node_InputVectorAxisEvent;
}

declare class K2Node_Knot extends K2Node { 
	static Load(ResourceName: string): K2Node_Knot;
	static Find(Outer: UObject, ResourceName: string): K2Node_Knot;
	static GetDefaultObject(): K2Node_Knot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Knot;
	static C(Other: UObject | any): K2Node_Knot;
}

declare class K2Node_Literal extends K2Node { 
	ObjectRef: UObject;
	static Load(ResourceName: string): K2Node_Literal;
	static Find(Outer: UObject, ResourceName: string): K2Node_Literal;
	static GetDefaultObject(): K2Node_Literal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Literal;
	static C(Other: UObject | any): K2Node_Literal;
}

declare class K2Node_LoadAsset extends K2Node { 
	static Load(ResourceName: string): K2Node_LoadAsset;
	static Find(Outer: UObject, ResourceName: string): K2Node_LoadAsset;
	static GetDefaultObject(): K2Node_LoadAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAsset;
	static C(Other: UObject | any): K2Node_LoadAsset;
}

declare class K2Node_LoadAssetClass extends K2Node_LoadAsset { 
	static Load(ResourceName: string): K2Node_LoadAssetClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_LoadAssetClass;
	static GetDefaultObject(): K2Node_LoadAssetClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAssetClass;
	static C(Other: UObject | any): K2Node_LoadAssetClass;
}

declare class K2Node_LocalVariable extends K2Node_TemporaryVariable { 
	CustomVariableName: string;
	VariableTooltip: string;
	static Load(ResourceName: string): K2Node_LocalVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_LocalVariable;
	static GetDefaultObject(): K2Node_LocalVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LocalVariable;
	static C(Other: UObject | any): K2Node_LocalVariable;
}

declare class GraphReference { 
	MacroGraph: EdGraph;
	GraphBlueprint: Blueprint;
	GraphGuid: Guid;
	clone() : GraphReference;
	static C(Other: UObject | any): GraphReference;
}

declare class K2Node_MacroInstance extends K2Node_Tunnel { 
	MacroGraph: EdGraph;
	MacroGraphReference: GraphReference;
	ResolvedWildcardType: EdGraphPinType;
	static Load(ResourceName: string): K2Node_MacroInstance;
	static Find(Outer: UObject, ResourceName: string): K2Node_MacroInstance;
	static GetDefaultObject(): K2Node_MacroInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MacroInstance;
	static C(Other: UObject | any): K2Node_MacroInstance;
}

declare class K2Node_MakeContainer extends K2Node { 
	NumInputs: number;
	static Load(ResourceName: string): K2Node_MakeContainer;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeContainer;
	static GetDefaultObject(): K2Node_MakeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeContainer;
	static C(Other: UObject | any): K2Node_MakeContainer;
}

declare class K2Node_MakeArray extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeArray;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeArray;
	static GetDefaultObject(): K2Node_MakeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeArray;
	static C(Other: UObject | any): K2Node_MakeArray;
}

declare class K2Node_MakeMap extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeMap;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeMap;
	static GetDefaultObject(): K2Node_MakeMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeMap;
	static C(Other: UObject | any): K2Node_MakeMap;
}

declare class K2Node_MakeSet extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeSet;
	static GetDefaultObject(): K2Node_MakeSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeSet;
	static C(Other: UObject | any): K2Node_MakeSet;
}

declare class K2Node_StructMemberSet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): K2Node_StructMemberSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructMemberSet;
	static GetDefaultObject(): K2Node_StructMemberSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberSet;
	static C(Other: UObject | any): K2Node_StructMemberSet;
}

declare class K2Node_MakeStruct extends K2Node_StructMemberSet { 
	bMadeAfterOverridePinRemoval: boolean;
	static Load(ResourceName: string): K2Node_MakeStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeStruct;
	static GetDefaultObject(): K2Node_MakeStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeStruct;
	static C(Other: UObject | any): K2Node_MakeStruct;
}

declare class K2Node_MakeVariable extends K2Node { 
	VariableType: BPVariableDescription;
	static Load(ResourceName: string): K2Node_MakeVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeVariable;
	static GetDefaultObject(): K2Node_MakeVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeVariable;
	static C(Other: UObject | any): K2Node_MakeVariable;
}

declare class K2Node_MathExpression extends K2Node_Composite { 
	Expression: string;
	bMadeAfterRotChange: boolean;
	static Load(ResourceName: string): K2Node_MathExpression;
	static Find(Outer: UObject, ResourceName: string): K2Node_MathExpression;
	static GetDefaultObject(): K2Node_MathExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MathExpression;
	static C(Other: UObject | any): K2Node_MathExpression;
}

declare class K2Node_MatineeController extends K2Node { 
	MatineeActor: MatineeActor;
	static Load(ResourceName: string): K2Node_MatineeController;
	static Find(Outer: UObject, ResourceName: string): K2Node_MatineeController;
	static GetDefaultObject(): K2Node_MatineeController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MatineeController;
	static C(Other: UObject | any): K2Node_MatineeController;
}

declare class K2Node_Message extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_Message;
	static Find(Outer: UObject, ResourceName: string): K2Node_Message;
	static GetDefaultObject(): K2Node_Message;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Message;
	static C(Other: UObject | any): K2Node_Message;
}

declare class K2Node_MultiGate extends K2Node_ExecutionSequence { 
	DataNode: K2Node_TemporaryVariable;
	static Load(ResourceName: string): K2Node_MultiGate;
	static Find(Outer: UObject, ResourceName: string): K2Node_MultiGate;
	static GetDefaultObject(): K2Node_MultiGate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MultiGate;
	static C(Other: UObject | any): K2Node_MultiGate;
}

declare class K2Node_PureAssignmentStatement extends K2Node { 
	static Load(ResourceName: string): K2Node_PureAssignmentStatement;
	static Find(Outer: UObject, ResourceName: string): K2Node_PureAssignmentStatement;
	static GetDefaultObject(): K2Node_PureAssignmentStatement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PureAssignmentStatement;
	static C(Other: UObject | any): K2Node_PureAssignmentStatement;
}

declare class K2Node_RemoveDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_RemoveDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_RemoveDelegate;
	static GetDefaultObject(): K2Node_RemoveDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_RemoveDelegate;
	static C(Other: UObject | any): K2Node_RemoveDelegate;
}

declare class K2Node_Select extends K2Node { 
	NumOptionPins: number;
	IndexPinType: EdGraphPinType;
	Enum: Enum;
	EnumEntries: string[];
	EnumEntryFriendlyNames: string[];
	bReconstructNode: boolean;
	static Load(ResourceName: string): K2Node_Select;
	static Find(Outer: UObject, ResourceName: string): K2Node_Select;
	static GetDefaultObject(): K2Node_Select;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Select;
	static C(Other: UObject | any): K2Node_Select;
}

declare class K2Node_Self extends K2Node { 
	static Load(ResourceName: string): K2Node_Self;
	static Find(Outer: UObject, ResourceName: string): K2Node_Self;
	static GetDefaultObject(): K2Node_Self;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Self;
	static C(Other: UObject | any): K2Node_Self;
}

declare class K2Node_SetFieldsInStruct extends K2Node_MakeStruct { 
	static Load(ResourceName: string): K2Node_SetFieldsInStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetFieldsInStruct;
	static GetDefaultObject(): K2Node_SetFieldsInStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetFieldsInStruct;
	static C(Other: UObject | any): K2Node_SetFieldsInStruct;
}

declare class K2Node_SetVariableOnPersistentFrame extends K2Node { 
	static Load(ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static GetDefaultObject(): K2Node_SetVariableOnPersistentFrame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetVariableOnPersistentFrame;
	static C(Other: UObject | any): K2Node_SetVariableOnPersistentFrame;
}

declare class K2Node_SpawnActor extends K2Node { 
	static Load(ResourceName: string): K2Node_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): K2Node_SpawnActor;
	static GetDefaultObject(): K2Node_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActor;
	static C(Other: UObject | any): K2Node_SpawnActor;
}

declare class K2Node_SpawnActorFromClass extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_SpawnActorFromClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_SpawnActorFromClass;
	static GetDefaultObject(): K2Node_SpawnActorFromClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActorFromClass;
	static C(Other: UObject | any): K2Node_SpawnActorFromClass;
}

declare class K2Node_Switch extends K2Node { 
	bHasDefaultPin: boolean;
	FunctionName: string;
	FunctionClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_Switch;
	static Find(Outer: UObject, ResourceName: string): K2Node_Switch;
	static GetDefaultObject(): K2Node_Switch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Switch;
	static C(Other: UObject | any): K2Node_Switch;
}

declare class K2Node_SwitchEnum extends K2Node_Switch { 
	Enum: Enum;
	EnumEntries: string[];
	EnumFriendlyNames: string[];
	static Load(ResourceName: string): K2Node_SwitchEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchEnum;
	static GetDefaultObject(): K2Node_SwitchEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchEnum;
	static C(Other: UObject | any): K2Node_SwitchEnum;
}

declare class K2Node_SwitchInteger extends K2Node_Switch { 
	StartIndex: number;
	static Load(ResourceName: string): K2Node_SwitchInteger;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchInteger;
	static GetDefaultObject(): K2Node_SwitchInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchInteger;
	static C(Other: UObject | any): K2Node_SwitchInteger;
}

declare class K2Node_SwitchName extends K2Node_Switch { 
	PinNames: string[];
	static Load(ResourceName: string): K2Node_SwitchName;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchName;
	static GetDefaultObject(): K2Node_SwitchName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchName;
	static C(Other: UObject | any): K2Node_SwitchName;
}

declare class K2Node_SwitchString extends K2Node_Switch { 
	PinNames: string[];
	bIsCaseSensitive: boolean;
	static Load(ResourceName: string): K2Node_SwitchString;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchString;
	static GetDefaultObject(): K2Node_SwitchString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchString;
	static C(Other: UObject | any): K2Node_SwitchString;
}

declare class K2Node_Timeline extends K2Node { 
	TimelineName: string;
	bAutoPlay: boolean;
	TimelineGuid: Guid;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): K2Node_Timeline;
	static Find(Outer: UObject, ResourceName: string): K2Node_Timeline;
	static GetDefaultObject(): K2Node_Timeline;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Timeline;
	static C(Other: UObject | any): K2Node_Timeline;
}

declare class K2Node_TunnelBoundary extends K2Node { 
	BaseName: string;
	FinalExitSite: EdGraphPinReference;
	static Load(ResourceName: string): K2Node_TunnelBoundary;
	static Find(Outer: UObject, ResourceName: string): K2Node_TunnelBoundary;
	static GetDefaultObject(): K2Node_TunnelBoundary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TunnelBoundary;
	static C(Other: UObject | any): K2Node_TunnelBoundary;
}

declare class K2Node_VariableGet extends K2Node_Variable { 
	bIsPureGet: boolean;
	static Load(ResourceName: string): K2Node_VariableGet;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableGet;
	static GetDefaultObject(): K2Node_VariableGet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableGet;
	static C(Other: UObject | any): K2Node_VariableGet;
}

declare class K2Node_VariableSet extends K2Node_Variable { 
	static Load(ResourceName: string): K2Node_VariableSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableSet;
	static GetDefaultObject(): K2Node_VariableSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSet;
	static C(Other: UObject | any): K2Node_VariableSet;
}

declare class K2Node_VariableSetRef extends K2Node { 
	static Load(ResourceName: string): K2Node_VariableSetRef;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableSetRef;
	static GetDefaultObject(): K2Node_VariableSetRef;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSetRef;
	static C(Other: UObject | any): K2Node_VariableSetRef;
}

declare class NodeDependingOnEnumInterface extends Interface { 
	static Load(ResourceName: string): NodeDependingOnEnumInterface;
	static Find(Outer: UObject, ResourceName: string): NodeDependingOnEnumInterface;
	static GetDefaultObject(): NodeDependingOnEnumInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeDependingOnEnumInterface;
	static C(Other: UObject | any): NodeDependingOnEnumInterface;
}

declare type EBlueprintPinStyleType = 'BPST_Original' | 'BPST_VariantA';
declare var EBlueprintPinStyleType : { BPST_Original:'BPST_Original',BPST_VariantA:'BPST_VariantA', };
declare type EGraphPanningMouseButton = 'Right' | 'Middle' | 'Both';
declare var EGraphPanningMouseButton : { Right:'Right',Middle:'Middle',Both:'Both', };
declare class GraphEditorSettings extends UObject { 
	DataPinStyle: EBlueprintPinStyleType;
	PanningMouseButton: PanningMouseButton;
	PaddingAbovePin: number;
	PaddingBelowPin: number;
	PaddingRightOfInput: number;
	PaddingLeftOfOutput: number;
	PaddingTowardsNodeEdge: number;
	bTreatSplinesLikePins: boolean;
	SplineHoverTolerance: number;
	ForwardSplineHorizontalDeltaRange: number;
	ForwardSplineVerticalDeltaRange: number;
	ForwardSplineTangentFromHorizontalDelta: Vector2D;
	ForwardSplineTangentFromVerticalDelta: Vector2D;
	BackwardSplineHorizontalDeltaRange: number;
	BackwardSplineVerticalDeltaRange: number;
	BackwardSplineTangentFromHorizontalDelta: Vector2D;
	BackwardSplineTangentFromVerticalDelta: Vector2D;
	DefaultPinTypeColor: LinearColor;
	ExecutionPinTypeColor: LinearColor;
	BooleanPinTypeColor: LinearColor;
	BytePinTypeColor: LinearColor;
	ClassPinTypeColor: LinearColor;
	IntPinTypeColor: LinearColor;
	FloatPinTypeColor: LinearColor;
	NamePinTypeColor: LinearColor;
	SoftObjectPinTypeColor: LinearColor;
	SoftClassPinTypeColor: LinearColor;
	DelegatePinTypeColor: LinearColor;
	ObjectPinTypeColor: LinearColor;
	InterfacePinTypeColor: LinearColor;
	StringPinTypeColor: LinearColor;
	TextPinTypeColor: LinearColor;
	StructPinTypeColor: LinearColor;
	WildcardPinTypeColor: LinearColor;
	VectorPinTypeColor: LinearColor;
	RotatorPinTypeColor: LinearColor;
	TransformPinTypeColor: LinearColor;
	IndexPinTypeColor: LinearColor;
	EventNodeTitleColor: LinearColor;
	FunctionCallNodeTitleColor: LinearColor;
	PureFunctionCallNodeTitleColor: LinearColor;
	ParentFunctionCallNodeTitleColor: LinearColor;
	FunctionTerminatorNodeTitleColor: LinearColor;
	ExecBranchNodeTitleColor: LinearColor;
	ExecSequenceNodeTitleColor: LinearColor;
	ResultNodeTitleColor: LinearColor;
	DefaultCommentNodeTitleColor: LinearColor;
	DefaultDataWireThickness: number;
	DefaultExecutionWireThickness: number;
	TraceAttackColor: LinearColor;
	TraceAttackWireThickness: number;
	TraceAttackHoldPeriod: number;
	TraceDecayPeriod: number;
	TraceDecayExponent: number;
	TraceSustainColor: LinearColor;
	TraceSustainWireThickness: number;
	TraceSustainHoldPeriod: number;
	TraceReleaseColor: LinearColor;
	TraceReleaseWireThickness: number;
	TraceReleasePeriod: number;
	TraceReleaseExponent: number;
	TracePositionBonusPeriod: number;
	TracePositionExponent: number;
	static Load(ResourceName: string): GraphEditorSettings;
	static Find(Outer: UObject, ResourceName: string): GraphEditorSettings;
	static GetDefaultObject(): GraphEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GraphEditorSettings;
	static C(Other: UObject | any): GraphEditorSettings;
}

declare class AnimationConduitGraphSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): AnimationConduitGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationConduitGraphSchema;
	static GetDefaultObject(): AnimationConduitGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationConduitGraphSchema;
	static C(Other: UObject | any): AnimationConduitGraphSchema;
}

declare class AnimationGraph extends EdGraph { 
	static Load(ResourceName: string): AnimationGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationGraph;
	static GetDefaultObject(): AnimationGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraph;
	static C(Other: UObject | any): AnimationGraph;
}

declare type EBlueprintUsage = 'NoProperties' | 'DoesNotUseBlueprint' | 'UsesBlueprint';
declare var EBlueprintUsage : { NoProperties:'NoProperties',DoesNotUseBlueprint:'DoesNotUseBlueprint',UsesBlueprint:'UsesBlueprint', };
declare class AnimGraphNode_Base extends K2Node { 
	ShowPinForProperties: OptionalPinFromProperty[];
	BlueprintUsage: BlueprintUsage;
	static Load(ResourceName: string): AnimGraphNode_Base;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Base;
	static GetDefaultObject(): AnimGraphNode_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Base;
	static C(Other: UObject | any): AnimGraphNode_Base;
}

declare type EPostCopyOperation = 'None' | 'LogicalNegateBool';
declare var EPostCopyOperation : { None:'None',LogicalNegateBool:'LogicalNegateBool', };
declare type ECopyType = 'MemCopy' | 'BoolProperty' | 'StructProperty' | 'ObjectProperty';
declare var ECopyType : { MemCopy:'MemCopy',BoolProperty:'BoolProperty',StructProperty:'StructProperty',ObjectProperty:'ObjectProperty', };
declare class ExposedValueCopyRecord { 
	SourceProperty: Property;
	SourcePropertyName: string;
	SourceSubPropertyName: string;
	SourceArrayIndex: number;
	DestProperty: Property;
	DestArrayIndex: number;
	Size: number;
	bInstanceIsTarget: boolean;
	PostCopyOperation: PostCopyOperation;
	CopyType: CopyType;
	CachedSourceProperty: Property;
	clone() : ExposedValueCopyRecord;
	static C(Other: UObject | any): ExposedValueCopyRecord;
}

declare class ExposedValueHandler { 
	BoundFunction: string;
	CopyRecords: ExposedValueCopyRecord[];
	clone() : ExposedValueHandler;
	static C(Other: UObject | any): ExposedValueHandler;
}

declare class AnimNode_Base { 
	EvaluateGraphExposedInputs: ExposedValueHandler;
	clone() : AnimNode_Base;
	static C(Other: UObject | any): AnimNode_Base;
}

declare class PoseLinkBase { 
	LinkID: number;
	SourceLinkID: number;
	clone() : PoseLinkBase;
	static C(Other: UObject | any): PoseLinkBase;
}

declare class PoseLink extends PoseLinkBase { 
	clone() : PoseLink;
	static C(Other: UObject | any): PoseLink;
}

declare class AnimNode_Root extends AnimNode_Base { 
	Result: PoseLink;
	clone() : AnimNode_Root;
	static C(Other: UObject | any): AnimNode_Root;
}

declare class AnimGraphNode_Root extends AnimGraphNode_Base { 
	UNode: AnimNode_Root;
	static Load(ResourceName: string): AnimGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Root;
	static GetDefaultObject(): AnimGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Root;
	static C(Other: UObject | any): AnimGraphNode_Root;
}

declare class AnimGraphNode_CustomTransitionResult extends AnimGraphNode_Root { 
	static Load(ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static GetDefaultObject(): AnimGraphNode_CustomTransitionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CustomTransitionResult;
	static C(Other: UObject | any): AnimGraphNode_CustomTransitionResult;
}

declare class AnimationCustomTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_CustomTransitionResult;
	static Load(ResourceName: string): AnimationCustomTransitionGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationCustomTransitionGraph;
	static GetDefaultObject(): AnimationCustomTransitionGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionGraph;
	static C(Other: UObject | any): AnimationCustomTransitionGraph;
}

declare class AnimationGraphSchema extends EdGraphSchema_K2 { 
	PN_SequenceName: string;
	NAME_NeverAsPin: string;
	NAME_PinHiddenByDefault: string;
	NAME_PinShownByDefault: string;
	NAME_AlwaysAsPin: string;
	NAME_CustomizeProperty: string;
	NAME_OnEvaluate: string;
	DefaultEvaluationHandlerName: string;
	static Load(ResourceName: string): AnimationGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationGraphSchema;
	static GetDefaultObject(): AnimationGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraphSchema;
	static C(Other: UObject | any): AnimationGraphSchema;
}

declare class AnimationCustomTransitionSchema extends AnimationGraphSchema { 
	static Load(ResourceName: string): AnimationCustomTransitionSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationCustomTransitionSchema;
	static GetDefaultObject(): AnimationCustomTransitionSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionSchema;
	static C(Other: UObject | any): AnimationCustomTransitionSchema;
}

declare class AnimGraphNode_StateResult extends AnimGraphNode_Root { 
	static Load(ResourceName: string): AnimGraphNode_StateResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateResult;
	static GetDefaultObject(): AnimGraphNode_StateResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateResult;
	static C(Other: UObject | any): AnimGraphNode_StateResult;
}

declare class AnimationStateGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_StateResult;
	static Load(ResourceName: string): AnimationStateGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationStateGraph;
	static GetDefaultObject(): AnimationStateGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraph;
	static C(Other: UObject | any): AnimationStateGraph;
}

declare class AnimationStateGraphSchema extends AnimationGraphSchema { 
	static Load(ResourceName: string): AnimationStateGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationStateGraphSchema;
	static GetDefaultObject(): AnimationStateGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraphSchema;
	static C(Other: UObject | any): AnimationStateGraphSchema;
}

declare class AnimStateEntryNode extends EdGraphNode { 
	static Load(ResourceName: string): AnimStateEntryNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateEntryNode;
	static GetDefaultObject(): AnimStateEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateEntryNode;
	static C(Other: UObject | any): AnimStateEntryNode;
}

declare class AnimGraphNode_StateMachineBase extends AnimGraphNode_Base { 
	EditorStateMachineGraph: AnimationStateMachineGraph;
	static Load(ResourceName: string): AnimGraphNode_StateMachineBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateMachineBase;
	static GetDefaultObject(): AnimGraphNode_StateMachineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateMachineBase;
	static C(Other: UObject | any): AnimGraphNode_StateMachineBase;
}

declare class AnimationStateMachineGraph extends EdGraph { 
	EntryNode: AnimStateEntryNode;
	OwnerAnimGraphNode: AnimGraphNode_StateMachineBase;
	static Load(ResourceName: string): AnimationStateMachineGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineGraph;
	static GetDefaultObject(): AnimationStateMachineGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineGraph;
	static C(Other: UObject | any): AnimationStateMachineGraph;
}

declare class AnimationStateMachineSchema extends EdGraphSchema { 
	PC_Exec: string;
	static Load(ResourceName: string): AnimationStateMachineSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineSchema;
	static GetDefaultObject(): AnimationStateMachineSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineSchema;
	static C(Other: UObject | any): AnimationStateMachineSchema;
}

declare class AnimNode_TransitionResult extends AnimNode_Base { 
	bCanEnterTransition: boolean;
	clone() : AnimNode_TransitionResult;
	static C(Other: UObject | any): AnimNode_TransitionResult;
}

declare class AnimGraphNode_TransitionResult extends AnimGraphNode_Base { 
	UNode: AnimNode_TransitionResult;
	static Load(ResourceName: string): AnimGraphNode_TransitionResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TransitionResult;
	static GetDefaultObject(): AnimGraphNode_TransitionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TransitionResult;
	static C(Other: UObject | any): AnimGraphNode_TransitionResult;
}

declare class AnimationTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_TransitionResult;
	static Load(ResourceName: string): AnimationTransitionGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationTransitionGraph;
	static GetDefaultObject(): AnimationTransitionGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionGraph;
	static C(Other: UObject | any): AnimationTransitionGraph;
}

declare class AnimationTransitionSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): AnimationTransitionSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationTransitionSchema;
	static GetDefaultObject(): AnimationTransitionSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionSchema;
	static C(Other: UObject | any): AnimationTransitionSchema;
}

declare class AnimBlueprintPostCompileValidation extends UObject { 
	static Load(ResourceName: string): AnimBlueprintPostCompileValidation;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintPostCompileValidation;
	static GetDefaultObject(): AnimBlueprintPostCompileValidation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintPostCompileValidation;
	static C(Other: UObject | any): AnimBlueprintPostCompileValidation;
}

declare type EAnimGroupRole = 'CanBeLeader' | 'AlwaysFollower' | 'AlwaysLeader' | 'TransitionLeader' | 'TransitionFollower';
declare var EAnimGroupRole : { CanBeLeader:'CanBeLeader',AlwaysFollower:'AlwaysFollower',AlwaysLeader:'AlwaysLeader',TransitionLeader:'TransitionLeader',TransitionFollower:'TransitionFollower', };
declare class AnimationGroupReference { 
	GroupName: string;
	GroupRole: EAnimGroupRole;
	clone() : AnimationGroupReference;
	static C(Other: UObject | any): AnimationGroupReference;
}

declare class AnimGraphNode_AssetPlayerBase extends AnimGraphNode_Base { 
	SyncGroup: AnimationGroupReference;
	static Load(ResourceName: string): AnimGraphNode_AssetPlayerBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_AssetPlayerBase;
	static GetDefaultObject(): AnimGraphNode_AssetPlayerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AssetPlayerBase;
	static C(Other: UObject | any): AnimGraphNode_AssetPlayerBase;
}

declare class AnimGraphNode_BlendSpaceBase extends AnimGraphNode_AssetPlayerBase { 
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceBase;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceBase;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceBase;
}

declare class AnimNode_AssetPlayerBase extends AnimNode_Base { 
	bIgnoreForRelevancyTest: boolean;
	GroupIndex: number;
	GroupRole: EAnimGroupRole;
	BlendWeight: number;
	InternalTimeAccumulator: number;
	clone() : AnimNode_AssetPlayerBase;
	static C(Other: UObject | any): AnimNode_AssetPlayerBase;
}

declare type EFilterInterpolationType = 'BSIT_Average' | 'BSIT_Linear' | 'BSIT_Cubic';
declare var EFilterInterpolationType : { BSIT_Average:'BSIT_Average',BSIT_Linear:'BSIT_Linear',BSIT_Cubic:'BSIT_Cubic', };
declare class InterpolationParameter { 
	InterpolationTime: number;
	InterpolationType: EFilterInterpolationType;
	clone() : InterpolationParameter;
	static C(Other: UObject | any): InterpolationParameter;
}

declare type ENotifyTriggerMode = 'AllAnimations' | 'HighestWeightedAnimation' | 'None';
declare var ENotifyTriggerMode : { AllAnimations:'AllAnimations',HighestWeightedAnimation:'HighestWeightedAnimation',None:'None', };
declare class PerBoneInterpolation { 
	BoneReference: BoneReference;
	InterpolationSpeedPerSec: number;
	clone() : PerBoneInterpolation;
	static C(Other: UObject | any): PerBoneInterpolation;
}

declare class BlendSample { 
	Animation: AnimSequence;
	SampleValue: Vector;
	RateScale: number;
	bIsValid: boolean;
	clone() : BlendSample;
	static C(Other: UObject | any): BlendSample;
}

declare class EditorElement { 
	Indices: number;
	Weights: number;
	clone() : EditorElement;
	static C(Other: UObject | any): EditorElement;
}

declare class BlendParameter { 
	DisplayName: string;
	Min: number;
	Max: number;
	GridNum: number;
	clone() : BlendParameter;
	static C(Other: UObject | any): BlendParameter;
}

declare class BlendSpaceBase extends AnimationAsset { 
	bRotationBlendInMeshSpace: boolean;
	PreviewBasePose: AnimSequence;
	AnimLength: number;
	InterpolationParam: InterpolationParameter;
	TargetWeightInterpolationSpeedPerSec: number;
	NotifyTriggerMode: ENotifyTriggerMode;
	PerBoneBlend: PerBoneInterpolation[];
	SampleIndexWithMarkers: number;
	SampleData: BlendSample[];
	GridSamples: EditorElement[];
	BlendParameters: BlendParameter;
	static Load(ResourceName: string): BlendSpaceBase;
	static Find(Outer: UObject, ResourceName: string): BlendSpaceBase;
	static GetDefaultObject(): BlendSpaceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpaceBase;
	static C(Other: UObject | any): BlendSpaceBase;
}

declare class BlendFilter { 
	clone() : BlendFilter;
	static C(Other: UObject | any): BlendFilter;
}

declare class BlendSampleData { 
	SampleDataIndex: number;
	Animation: AnimSequence;
	TotalWeight: number;
	Time: number;
	PreviousTime: number;
	SamplePlayRate: number;
	clone() : BlendSampleData;
	static C(Other: UObject | any): BlendSampleData;
}

declare class AnimNode_BlendSpacePlayer extends AnimNode_AssetPlayerBase { 
	X: number;
	Y: number;
	Z: number;
	PlayRate: number;
	bLoop: boolean;
	StartPosition: number;
	BlendSpace: BlendSpaceBase;
	bResetPlayTimeWhenBlendSpaceChanges: boolean;
	BlendFilter: BlendFilter;
	BlendSampleDataCache: BlendSampleData[];
	PreviousBlendSpace: BlendSpaceBase;
	clone() : AnimNode_BlendSpacePlayer;
	static C(Other: UObject | any): AnimNode_BlendSpacePlayer;
}

declare class AnimNode_AimOffsetLookAt extends AnimNode_BlendSpacePlayer { 
	BasePose: PoseLink;
	LODThreshold: number;
	bIsLODEnabled: boolean;
	LookAtLocation: Vector;
	SourceSocketName: string;
	PivotSocketName: string;
	SocketAxis: Vector;
	Alpha: number;
	SocketBoneReference: BoneReference;
	SocketLocalTransform: Transform;
	PivotSocketBoneReference: BoneReference;
	PivotSocketLocalTransform: Transform;
	clone() : AnimNode_AimOffsetLookAt;
	static C(Other: UObject | any): AnimNode_AimOffsetLookAt;
}

declare class AnimGraphNode_AimOffsetLookAt extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_AimOffsetLookAt;
	static Load(ResourceName: string): AnimGraphNode_AimOffsetLookAt;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_AimOffsetLookAt;
	static GetDefaultObject(): AnimGraphNode_AimOffsetLookAt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AimOffsetLookAt;
	static C(Other: UObject | any): AnimGraphNode_AimOffsetLookAt;
}

declare class AnimGraphNode_SkeletalControlBase extends AnimGraphNode_Base { 
	static Load(ResourceName: string): AnimGraphNode_SkeletalControlBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_SkeletalControlBase;
	static GetDefaultObject(): AnimGraphNode_SkeletalControlBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_SkeletalControlBase;
	static C(Other: UObject | any): AnimGraphNode_SkeletalControlBase;
}

declare class ComponentSpacePoseLink extends PoseLinkBase { 
	clone() : ComponentSpacePoseLink;
	static C(Other: UObject | any): ComponentSpacePoseLink;
}

declare class InputScaleBias { 
	Scale: number;
	Bias: number;
	clone() : InputScaleBias;
	static C(Other: UObject | any): InputScaleBias;
}

declare class AnimNode_SkeletalControlBase extends AnimNode_Base { 
	ComponentPose: ComponentSpacePoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	LODThreshold: number;
	ActualAlpha: number;
	clone() : AnimNode_SkeletalControlBase;
	static C(Other: UObject | any): AnimNode_SkeletalControlBase;
}

declare type AnimPhysSimSpaceType = 'Component' | 'Actor' | 'World' | 'RootRelative' | 'BoneRelative';
declare var AnimPhysSimSpaceType : { Component:'Component',Actor:'Actor',World:'World',RootRelative:'RootRelative',BoneRelative:'BoneRelative', };
declare type AnimPhysLinearConstraintType = 'Free' | 'Limited';
declare var AnimPhysLinearConstraintType : { Free:'Free',Limited:'Limited', };
declare type AnimPhysAngularConstraintType = 'Angular' | 'Cone';
declare var AnimPhysAngularConstraintType : { Angular:'Angular',Cone:'Cone', };
declare type AnimPhysTwistAxis = 'AxisX' | 'AxisY' | 'AxisZ';
declare var AnimPhysTwistAxis : { AxisX:'AxisX',AxisY:'AxisY',AxisZ:'AxisZ', };
declare class AnimPhysConstraintSetup { 
	LinearXLimitType: LinearXLimitType;
	LinearYLimitType: LinearYLimitType;
	LinearZLimitType: LinearZLimitType;
	LinearAxesMin: Vector;
	LinearAxesMax: Vector;
	AngularConstraintType: AngularConstraintType;
	TwistAxis: TwistAxis;
	ConeAngle: number;
	AngularXAngle: number;
	AngularYAngle: number;
	AngularZAngle: number;
	AngularLimitsMin: Vector;
	AngularLimitsMax: Vector;
	AngularTargetAxis: AngularTargetAxis;
	AngularTarget: Vector;
	bLinearFullyLocked: boolean;
	clone() : AnimPhysConstraintSetup;
	static C(Other: UObject | any): AnimPhysConstraintSetup;
}

declare class AnimPhysPlanarLimit { 
	DrivingBone: BoneReference;
	PlaneTransform: Transform;
	clone() : AnimPhysPlanarLimit;
	static C(Other: UObject | any): AnimPhysPlanarLimit;
}

declare type ESphericalLimitType = 'Inner' | 'Outer';
declare var ESphericalLimitType : { Inner:'Inner',Outer:'Outer', };
declare class AnimPhysSphericalLimit { 
	DrivingBone: BoneReference;
	SphereLocalOffset: Vector;
	LimitRadius: number;
	LimitType: LimitType;
	clone() : AnimPhysSphericalLimit;
	static C(Other: UObject | any): AnimPhysSphericalLimit;
}

declare type AnimPhysCollisionType = 'CoM' | 'CustomSphere' | 'InnerSphere' | 'OuterSphere';
declare var AnimPhysCollisionType : { CoM:'CoM',CustomSphere:'CustomSphere',InnerSphere:'InnerSphere',OuterSphere:'OuterSphere', };
declare class AnimNode_AnimDynamics extends AnimNode_SkeletalControlBase { 
	SimulationSpace: SimulationSpace;
	RelativeSpaceBone: BoneReference;
	bChain: boolean;
	BoundBone: BoneReference;
	ChainEnd: BoneReference;
	BoxExtents: Vector;
	LocalJointOffset: Vector;
	GravityScale: number;
	bLinearSpring: boolean;
	bAngularSpring: boolean;
	LinearSpringConstant: number;
	AngularSpringConstant: number;
	bEnableWind: boolean;
	bWindWasEnabled: boolean;
	WindScale: number;
	bOverrideLinearDamping: boolean;
	LinearDampingOverride: number;
	bOverrideAngularDamping: boolean;
	AngularDampingOverride: number;
	bOverrideAngularBias: boolean;
	AngularBiasOverride: number;
	bDoUpdate: boolean;
	bDoEval: boolean;
	NumSolverIterationsPreUpdate: number;
	NumSolverIterationsPostUpdate: number;
	ConstraintSetup: AnimPhysConstraintSetup;
	bUsePlanarLimit: boolean;
	PlanarLimits: AnimPhysPlanarLimit[];
	bUseSphericalLimits: boolean;
	SphericalLimits: AnimPhysSphericalLimit[];
	CollisionType: CollisionType;
	SphereCollisionRadius: number;
	ExternalForce: Vector;
	clone() : AnimNode_AnimDynamics;
	static C(Other: UObject | any): AnimNode_AnimDynamics;
}

declare class AnimGraphNode_AnimDynamics extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_AnimDynamics;
	bPreviewLive: boolean;
	bShowLinearLimits: boolean;
	bShowAngularLimits: boolean;
	bShowPlanarLimit: boolean;
	bShowSphericalLimit: boolean;
	bShowCollisionSpheres: boolean;
	LastPreviewComponent: SkeletalMeshComponent;
	static Load(ResourceName: string): AnimGraphNode_AnimDynamics;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_AnimDynamics;
	static GetDefaultObject(): AnimGraphNode_AnimDynamics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_AnimDynamics;
	static C(Other: UObject | any): AnimGraphNode_AnimDynamics;
}

declare class AnimNode_ApplyAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	LODThreshold: number;
	ActualAlpha: number;
	clone() : AnimNode_ApplyAdditive;
	static C(Other: UObject | any): AnimNode_ApplyAdditive;
}

declare class AnimGraphNode_ApplyAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_ApplyAdditive;
	static Load(ResourceName: string): AnimGraphNode_ApplyAdditive;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ApplyAdditive;
	static GetDefaultObject(): AnimGraphNode_ApplyAdditive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ApplyAdditive;
	static C(Other: UObject | any): AnimGraphNode_ApplyAdditive;
}

declare class AnimNode_ApplyMeshSpaceAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	LODThreshold: number;
	ActualAlpha: number;
	clone() : AnimNode_ApplyMeshSpaceAdditive;
	static C(Other: UObject | any): AnimNode_ApplyMeshSpaceAdditive;
}

declare class AnimGraphNode_ApplyMeshSpaceAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_ApplyMeshSpaceAdditive;
	static Load(ResourceName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
	static GetDefaultObject(): AnimGraphNode_ApplyMeshSpaceAdditive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ApplyMeshSpaceAdditive;
	static C(Other: UObject | any): AnimGraphNode_ApplyMeshSpaceAdditive;
}

declare class BlendBoneByChannelEntry { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bBlendTranslation: boolean;
	bBlendRotation: boolean;
	bBlendScale: boolean;
	clone() : BlendBoneByChannelEntry;
	static C(Other: UObject | any): BlendBoneByChannelEntry;
}

declare type EBoneControlSpace = 'BCS_WorldSpace' | 'BCS_ComponentSpace' | 'BCS_ParentBoneSpace' | 'BCS_BoneSpace';
declare var EBoneControlSpace : { BCS_WorldSpace:'BCS_WorldSpace',BCS_ComponentSpace:'BCS_ComponentSpace',BCS_ParentBoneSpace:'BCS_ParentBoneSpace',BCS_BoneSpace:'BCS_BoneSpace', };
declare class AnimNode_BlendBoneByChannel extends AnimNode_Base { 
	A: PoseLink;
	B: PoseLink;
	Alpha: number;
	AlphaScaleBias: InputScaleBias;
	BoneDefinitions: BlendBoneByChannelEntry[];
	TransformsSpace: EBoneControlSpace;
	InternalBlendAlpha: number;
	bBIsRelevant: boolean;
	ValidBoneEntries: BlendBoneByChannelEntry[];
	clone() : AnimNode_BlendBoneByChannel;
	static C(Other: UObject | any): AnimNode_BlendBoneByChannel;
}

declare class AnimGraphNode_BlendBoneByChannel extends AnimGraphNode_Base { 
	BlendNode: AnimNode_BlendBoneByChannel;
	static Load(ResourceName: string): AnimGraphNode_BlendBoneByChannel;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendBoneByChannel;
	static GetDefaultObject(): AnimGraphNode_BlendBoneByChannel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendBoneByChannel;
	static C(Other: UObject | any): AnimGraphNode_BlendBoneByChannel;
}

declare class AnimGraphNode_BlendListBase extends AnimGraphNode_Base { 
	static Load(ResourceName: string): AnimGraphNode_BlendListBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListBase;
	static GetDefaultObject(): AnimGraphNode_BlendListBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListBase;
	static C(Other: UObject | any): AnimGraphNode_BlendListBase;
}

declare class AnimNode_BlendListBase extends AnimNode_Base { 
	BlendPose: PoseLink[];
	BlendTime: number[];
	BlendType: BlendType;
	CustomBlendCurve: CurveFloat;
	BlendProfile: BlendProfile;
	Blends: AlphaBlend[];
	BlendWeights: number[];
	RemainingBlendTimes: number[];
	LastActiveChildIndex: number;
	PerBoneSampleData: BlendSampleData[];
	bResetChildOnActivation: boolean;
	clone() : AnimNode_BlendListBase;
	static C(Other: UObject | any): AnimNode_BlendListBase;
}

declare class AnimNode_BlendListByBool extends AnimNode_BlendListBase { 
	bActiveValue: boolean;
	clone() : AnimNode_BlendListByBool;
	static C(Other: UObject | any): AnimNode_BlendListByBool;
}

declare class AnimGraphNode_BlendListByBool extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByBool;
	static Load(ResourceName: string): AnimGraphNode_BlendListByBool;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListByBool;
	static GetDefaultObject(): AnimGraphNode_BlendListByBool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByBool;
	static C(Other: UObject | any): AnimGraphNode_BlendListByBool;
}

declare class AnimNode_BlendListByEnum extends AnimNode_BlendListBase { 
	EnumToPoseIndex: number[];
	ActiveEnumValue: number;
	clone() : AnimNode_BlendListByEnum;
	static C(Other: UObject | any): AnimNode_BlendListByEnum;
}

declare class AnimGraphNode_BlendListByEnum extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByEnum;
	BoundEnum: Enum;
	VisibleEnumEntries: string[];
	static Load(ResourceName: string): AnimGraphNode_BlendListByEnum;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListByEnum;
	static GetDefaultObject(): AnimGraphNode_BlendListByEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByEnum;
	static C(Other: UObject | any): AnimGraphNode_BlendListByEnum;
}

declare class AnimNode_BlendListByInt extends AnimNode_BlendListBase { 
	ActiveChildIndex: number;
	clone() : AnimNode_BlendListByInt;
	static C(Other: UObject | any): AnimNode_BlendListByInt;
}

declare class AnimGraphNode_BlendListByInt extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_BlendListByInt;
	static Load(ResourceName: string): AnimGraphNode_BlendListByInt;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendListByInt;
	static GetDefaultObject(): AnimGraphNode_BlendListByInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendListByInt;
	static C(Other: UObject | any): AnimGraphNode_BlendListByInt;
}

declare class AnimNode_BlendSpaceEvaluator extends AnimNode_BlendSpacePlayer { 
	NormalizedTime: number;
	clone() : AnimNode_BlendSpaceEvaluator;
	static C(Other: UObject | any): AnimNode_BlendSpaceEvaluator;
}

declare class AnimGraphNode_BlendSpaceEvaluator extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_BlendSpaceEvaluator;
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceEvaluator;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceEvaluator;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceEvaluator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceEvaluator;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceEvaluator;
}

declare class AnimGraphNode_BlendSpacePlayer extends AnimGraphNode_BlendSpaceBase { 
	UNode: AnimNode_BlendSpacePlayer;
	static Load(ResourceName: string): AnimGraphNode_BlendSpacePlayer;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpacePlayer;
	static GetDefaultObject(): AnimGraphNode_BlendSpacePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpacePlayer;
	static C(Other: UObject | any): AnimGraphNode_BlendSpacePlayer;
}

declare type EComponentType = 'None' | 'TranslationX' | 'TranslationY' | 'TranslationZ' | 'RotationX' | 'RotationY' | 'RotationZ' | 'Scale' | 'ScaleX' | 'ScaleY' | 'ScaleZ';
declare var EComponentType : { None:'None',TranslationX:'TranslationX',TranslationY:'TranslationY',TranslationZ:'TranslationZ',RotationX:'RotationX',RotationY:'RotationY',RotationZ:'RotationZ',Scale:'Scale',ScaleX:'ScaleX',ScaleY:'ScaleY',ScaleZ:'ScaleZ', };
declare type EDrivenDestinationMode = 'Bone' | 'MorphTarget' | 'MaterialParameter';
declare var EDrivenDestinationMode : { Bone:'Bone',MorphTarget:'MorphTarget',MaterialParameter:'MaterialParameter', };
declare type EDrivenBoneModificationMode = 'AddToInput' | 'ReplaceComponent' | 'AddToRefPose';
declare var EDrivenBoneModificationMode : { AddToInput:'AddToInput',ReplaceComponent:'ReplaceComponent',AddToRefPose:'AddToRefPose', };
declare class AnimNode_BoneDrivenController extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	SourceComponent: EComponentType;
	DrivingCurve: CurveFloat;
	Multiplier: number;
	bUseRange: boolean;
	RangeMin: number;
	RangeMax: number;
	RemappedMin: number;
	RemappedMax: number;
	DestinationMode: DestinationMode;
	ParameterName: string;
	TargetBone: BoneReference;
	TargetComponent: EComponentType;
	bAffectTargetTranslationX: boolean;
	bAffectTargetTranslationY: boolean;
	bAffectTargetTranslationZ: boolean;
	bAffectTargetRotationX: boolean;
	bAffectTargetRotationY: boolean;
	bAffectTargetRotationZ: boolean;
	bAffectTargetScaleX: boolean;
	bAffectTargetScaleY: boolean;
	bAffectTargetScaleZ: boolean;
	ModificationMode: ModificationMode;
	clone() : AnimNode_BoneDrivenController;
	static C(Other: UObject | any): AnimNode_BoneDrivenController;
}

declare class AnimGraphNode_BoneDrivenController extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_BoneDrivenController;
	static Load(ResourceName: string): AnimGraphNode_BoneDrivenController;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BoneDrivenController;
	static GetDefaultObject(): AnimGraphNode_BoneDrivenController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BoneDrivenController;
	static C(Other: UObject | any): AnimGraphNode_BoneDrivenController;
}

declare class AnimNode_ConvertComponentToLocalSpace extends AnimNode_Base { 
	ComponentPose: ComponentSpacePoseLink;
	clone() : AnimNode_ConvertComponentToLocalSpace;
	static C(Other: UObject | any): AnimNode_ConvertComponentToLocalSpace;
}

declare class AnimGraphNode_ComponentToLocalSpace extends AnimGraphNode_Base { 
	UNode: AnimNode_ConvertComponentToLocalSpace;
	static Load(ResourceName: string): AnimGraphNode_ComponentToLocalSpace;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ComponentToLocalSpace;
	static GetDefaultObject(): AnimGraphNode_ComponentToLocalSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ComponentToLocalSpace;
	static C(Other: UObject | any): AnimGraphNode_ComponentToLocalSpace;
}

declare type EConstraintOffsetOption = 'None' | 'Offset_RefPose';
declare var EConstraintOffsetOption : { None:'None',Offset_RefPose:'Offset_RefPose', };
declare type ETransformConstraintType = 'Translation' | 'Rotation' | 'Scale' | 'Parent';
declare var ETransformConstraintType : { Translation:'Translation',Rotation:'Rotation',Scale:'Scale',Parent:'Parent', };
declare class FilterOptionPerAxis { 
	bX: boolean;
	bY: boolean;
	bZ: boolean;
	clone() : FilterOptionPerAxis;
	static C(Other: UObject | any): FilterOptionPerAxis;
}

declare class Constraint { 
	TargetBone: BoneReference;
	OffsetOption: OffsetOption;
	TransformType: TransformType;
	PerAxis: FilterOptionPerAxis;
	clone() : Constraint;
	static C(Other: UObject | any): Constraint;
}

declare class AnimNode_Constraint extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	ConstraintSetup: Constraint[];
	ConstraintWeights: number[];
	clone() : AnimNode_Constraint;
	static C(Other: UObject | any): AnimNode_Constraint;
}

declare class AnimGraphNode_Constraint extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Constraint;
	static Load(ResourceName: string): AnimGraphNode_Constraint;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Constraint;
	static GetDefaultObject(): AnimGraphNode_Constraint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Constraint;
	static C(Other: UObject | any): AnimGraphNode_Constraint;
}

declare class AnimNode_CopyBone extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bCopyTranslation: boolean;
	bCopyRotation: boolean;
	bCopyScale: boolean;
	ControlSpace: EBoneControlSpace;
	clone() : AnimNode_CopyBone;
	static C(Other: UObject | any): AnimNode_CopyBone;
}

declare class AnimGraphNode_CopyBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_CopyBone;
	static Load(ResourceName: string): AnimGraphNode_CopyBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CopyBone;
	static GetDefaultObject(): AnimGraphNode_CopyBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyBone;
	static C(Other: UObject | any): AnimGraphNode_CopyBone;
}

declare type CopyBoneDeltaMode = 'Accumulate' | 'Copy';
declare var CopyBoneDeltaMode : { Accumulate:'Accumulate',Copy:'Copy', };
declare class AnimNode_CopyBoneDelta extends AnimNode_SkeletalControlBase { 
	SourceBone: BoneReference;
	TargetBone: BoneReference;
	bCopyTranslation: boolean;
	bCopyRotation: boolean;
	bCopyScale: boolean;
	CopyMode: CopyMode;
	TranslationMultiplier: number;
	RotationMultiplier: number;
	ScaleMultiplier: number;
	clone() : AnimNode_CopyBoneDelta;
	static C(Other: UObject | any): AnimNode_CopyBoneDelta;
}

declare class AnimGraphNode_CopyBoneDelta extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_CopyBoneDelta;
	static Load(ResourceName: string): AnimGraphNode_CopyBoneDelta;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CopyBoneDelta;
	static GetDefaultObject(): AnimGraphNode_CopyBoneDelta;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyBoneDelta;
	static C(Other: UObject | any): AnimGraphNode_CopyBoneDelta;
}

declare class AnimNode_CopyPoseFromMesh extends AnimNode_Base { 
	SourceMeshComponent: any;
	bUseAttachedParent: boolean;
	clone() : AnimNode_CopyPoseFromMesh;
	static C(Other: UObject | any): AnimNode_CopyPoseFromMesh;
}

declare class AnimGraphNode_CopyPoseFromMesh extends AnimGraphNode_Base { 
	UNode: AnimNode_CopyPoseFromMesh;
	static Load(ResourceName: string): AnimGraphNode_CopyPoseFromMesh;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CopyPoseFromMesh;
	static GetDefaultObject(): AnimGraphNode_CopyPoseFromMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CopyPoseFromMesh;
	static C(Other: UObject | any): AnimGraphNode_CopyPoseFromMesh;
}

declare class AnimNode_CurveSource extends AnimNode_Base { 
	SourcePose: PoseLink;
	SourceBinding: string;
	Alpha: number;
	CurveSource: any;
	clone() : AnimNode_CurveSource;
	static C(Other: UObject | any): AnimNode_CurveSource;
}

declare class AnimGraphNode_CurveSource extends AnimGraphNode_Base { 
	UNode: AnimNode_CurveSource;
	static Load(ResourceName: string): AnimGraphNode_CurveSource;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CurveSource;
	static GetDefaultObject(): AnimGraphNode_CurveSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CurveSource;
	static C(Other: UObject | any): AnimGraphNode_CurveSource;
}

declare class SocketReference { 
	SocketName: string;
	clone() : SocketReference;
	static C(Other: UObject | any): SocketReference;
}

declare class BoneSocketTarget { 
	bUseSocket: boolean;
	BoneReference: BoneReference;
	SocketReference: SocketReference;
	clone() : BoneSocketTarget;
	static C(Other: UObject | any): BoneSocketTarget;
}

declare type EBoneRotationSource = 'BRS_KeepComponentSpaceRotation' | 'BRS_KeepLocalSpaceRotation' | 'BRS_CopyFromTarget';
declare var EBoneRotationSource : { BRS_KeepComponentSpaceRotation:'BRS_KeepComponentSpaceRotation',BRS_KeepLocalSpaceRotation:'BRS_KeepLocalSpaceRotation',BRS_CopyFromTarget:'BRS_CopyFromTarget', };
declare class AnimNode_Fabrik extends AnimNode_SkeletalControlBase { 
	EffectorTransform: Transform;
	EffectorTransformSpace: EBoneControlSpace;
	EffectorTransformBone: BoneReference;
	EffectorTarget: BoneSocketTarget;
	EffectorRotationSource: EBoneRotationSource;
	TipBone: BoneReference;
	RootBone: BoneReference;
	Precision: number;
	MaxIterations: number;
	bEnableDebugDraw: boolean;
	clone() : AnimNode_Fabrik;
	static C(Other: UObject | any): AnimNode_Fabrik;
}

declare class AnimGraphNode_Fabrik extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_Fabrik;
	static Load(ResourceName: string): AnimGraphNode_Fabrik;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Fabrik;
	static GetDefaultObject(): AnimGraphNode_Fabrik;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Fabrik;
	static C(Other: UObject | any): AnimGraphNode_Fabrik;
}

declare class AnimNode_HandIKRetargeting extends AnimNode_SkeletalControlBase { 
	RightHandFK: BoneReference;
	LeftHandFK: BoneReference;
	RightHandIK: BoneReference;
	LeftHandIK: BoneReference;
	IKBonesToMove: BoneReference[];
	HandFKWeight: number;
	clone() : AnimNode_HandIKRetargeting;
	static C(Other: UObject | any): AnimNode_HandIKRetargeting;
}

declare class AnimGraphNode_HandIKRetargeting extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_HandIKRetargeting;
	static Load(ResourceName: string): AnimGraphNode_HandIKRetargeting;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_HandIKRetargeting;
	static GetDefaultObject(): AnimGraphNode_HandIKRetargeting;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_HandIKRetargeting;
	static C(Other: UObject | any): AnimGraphNode_HandIKRetargeting;
}

declare type ERefPoseType = 'EIT_LocalSpace' | 'EIT_Additive';
declare var ERefPoseType : { EIT_LocalSpace:'EIT_LocalSpace',EIT_Additive:'EIT_Additive', };
declare class AnimNode_RefPose extends AnimNode_Base { 
	RefPoseType: ERefPoseType;
	clone() : AnimNode_RefPose;
	static C(Other: UObject | any): AnimNode_RefPose;
}

declare class AnimGraphNode_RefPoseBase extends AnimGraphNode_Base { 
	UNode: AnimNode_RefPose;
	static Load(ResourceName: string): AnimGraphNode_RefPoseBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_RefPoseBase;
	static GetDefaultObject(): AnimGraphNode_RefPoseBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_RefPoseBase;
	static C(Other: UObject | any): AnimGraphNode_RefPoseBase;
}

declare class AnimGraphNode_IdentityPose extends AnimGraphNode_RefPoseBase { 
	static Load(ResourceName: string): AnimGraphNode_IdentityPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_IdentityPose;
	static GetDefaultObject(): AnimGraphNode_IdentityPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_IdentityPose;
	static C(Other: UObject | any): AnimGraphNode_IdentityPose;
}

declare class BranchFilter { 
	BoneName: string;
	BlendDepth: number;
	clone() : BranchFilter;
	static C(Other: UObject | any): BranchFilter;
}

declare class InputBlendPose { 
	BranchFilters: BranchFilter[];
	clone() : InputBlendPose;
	static C(Other: UObject | any): InputBlendPose;
}

declare type ECurveBlendOption = 'MaxWeight' | 'NormalizeByWeight' | 'BlendByWeight';
declare var ECurveBlendOption : { MaxWeight:'MaxWeight',NormalizeByWeight:'NormalizeByWeight',BlendByWeight:'BlendByWeight', };
declare class PerBoneBlendWeight { 
	SourceIndex: number;
	BlendWeight: number;
	clone() : PerBoneBlendWeight;
	static C(Other: UObject | any): PerBoneBlendWeight;
}

declare class AnimNode_LayeredBoneBlend extends AnimNode_Base { 
	BasePose: PoseLink;
	BlendPoses: PoseLink[];
	LayerSetup: InputBlendPose[];
	BlendWeights: number[];
	bMeshSpaceRotationBlend: boolean;
	CurveBlendOption: ECurveBlendOption;
	bBlendRootMotionBasedOnRootBone: boolean;
	bHasRelevantPoses: boolean;
	PerBoneBlendWeights: PerBoneBlendWeight[];
	SkeletonGuid: Guid;
	VirtualBoneGuid: Guid;
	clone() : AnimNode_LayeredBoneBlend;
	static C(Other: UObject | any): AnimNode_LayeredBoneBlend;
}

declare class AnimGraphNode_LayeredBoneBlend extends AnimGraphNode_BlendListBase { 
	UNode: AnimNode_LayeredBoneBlend;
	static Load(ResourceName: string): AnimGraphNode_LayeredBoneBlend;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LayeredBoneBlend;
	static GetDefaultObject(): AnimGraphNode_LayeredBoneBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LayeredBoneBlend;
	static C(Other: UObject | any): AnimGraphNode_LayeredBoneBlend;
}

declare class AnimLegIKDefinition { 
	IKFootBone: BoneReference;
	FKFootBone: BoneReference;
	NumBonesInLimb: number;
	FootBoneForwardAxis: EAxis;
	bEnableRotationLimit: boolean;
	MinRotationAngle: number;
	bEnableKneeTwistCorrection: boolean;
	clone() : AnimLegIKDefinition;
	static C(Other: UObject | any): AnimLegIKDefinition;
}

declare class AnimLegIKData { 
	clone() : AnimLegIKData;
	static C(Other: UObject | any): AnimLegIKData;
}

declare class AnimNode_LegIK extends AnimNode_SkeletalControlBase { 
	ReachPrecision: number;
	MaxIterations: number;
	LegsDefinition: AnimLegIKDefinition[];
	LegsData: AnimLegIKData[];
	clone() : AnimNode_LegIK;
	static C(Other: UObject | any): AnimNode_LegIK;
}

declare class AnimGraphNode_LegIK extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_LegIK;
	static Load(ResourceName: string): AnimGraphNode_LegIK;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LegIK;
	static GetDefaultObject(): AnimGraphNode_LegIK;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LegIK;
	static C(Other: UObject | any): AnimGraphNode_LegIK;
}

declare class AnimGraphNode_LocalRefPose extends AnimGraphNode_RefPoseBase { 
	static Load(ResourceName: string): AnimGraphNode_LocalRefPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LocalRefPose;
	static GetDefaultObject(): AnimGraphNode_LocalRefPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LocalRefPose;
	static C(Other: UObject | any): AnimGraphNode_LocalRefPose;
}

declare class AnimNode_ConvertLocalToComponentSpace extends AnimNode_Base { 
	LocalPose: PoseLink;
	clone() : AnimNode_ConvertLocalToComponentSpace;
	static C(Other: UObject | any): AnimNode_ConvertLocalToComponentSpace;
}

declare class AnimGraphNode_LocalToComponentSpace extends AnimGraphNode_Base { 
	UNode: AnimNode_ConvertLocalToComponentSpace;
	static Load(ResourceName: string): AnimGraphNode_LocalToComponentSpace;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LocalToComponentSpace;
	static GetDefaultObject(): AnimGraphNode_LocalToComponentSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LocalToComponentSpace;
	static C(Other: UObject | any): AnimGraphNode_LocalToComponentSpace;
}

declare type EAxisOption = 'X' | 'Y' | 'Z' | 'X_Neg' | 'Y_Neg' | 'Z_Neg' | 'Custom';
declare var EAxisOption : { X:'X',Y:'Y',Z:'Z',X_Neg:'X_Neg',Y_Neg:'Y_Neg',Z_Neg:'Z_Neg',Custom:'Custom', };
declare class Axis { 
	Axis: Vector;
	bInLocalSpace: boolean;
	clone() : Axis;
	static C(Other: UObject | any): Axis;
}

declare type EInterpolationBlend = 'Linear' | 'Cubic' | 'Sinusoidal' | 'EaseInOutExponent2' | 'EaseInOutExponent3' | 'EaseInOutExponent4' | 'EaseInOutExponent5';
declare var EInterpolationBlend : { Linear:'Linear',Cubic:'Cubic',Sinusoidal:'Sinusoidal',EaseInOutExponent2:'EaseInOutExponent2',EaseInOutExponent3:'EaseInOutExponent3',EaseInOutExponent4:'EaseInOutExponent4',EaseInOutExponent5:'EaseInOutExponent5', };
declare class AnimNode_LookAt extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	LookAtBone: BoneReference;
	LookAtSocket: string;
	LookAtTarget: BoneSocketTarget;
	LookAtLocation: Vector;
	LookAtAxis: EAxisOption;
	CustomLookAtAxis: Vector;
	LookAt_Axis: Axis;
	bUseLookUpAxis: boolean;
	LookUpAxis: EAxisOption;
	CustomLookUpAxis: Vector;
	LookUp_Axis: Axis;
	LookAtClamp: number;
	InterpolationType: EInterpolationBlend;
	InterpolationTime: number;
	InterpolationTriggerThreashold: number;
	clone() : AnimNode_LookAt;
	static C(Other: UObject | any): AnimNode_LookAt;
}

declare class AnimGraphNode_LookAt extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_LookAt;
	static Load(ResourceName: string): AnimGraphNode_LookAt;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_LookAt;
	static GetDefaultObject(): AnimGraphNode_LookAt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_LookAt;
	static C(Other: UObject | any): AnimGraphNode_LookAt;
}

declare class AnimNode_MakeDynamicAdditive extends AnimNode_Base { 
	Base: PoseLink;
	Additive: PoseLink;
	bMeshSpaceAdditive: boolean;
	clone() : AnimNode_MakeDynamicAdditive;
	static C(Other: UObject | any): AnimNode_MakeDynamicAdditive;
}

declare class AnimGraphNode_MakeDynamicAdditive extends AnimGraphNode_Base { 
	UNode: AnimNode_MakeDynamicAdditive;
	static Load(ResourceName: string): AnimGraphNode_MakeDynamicAdditive;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_MakeDynamicAdditive;
	static GetDefaultObject(): AnimGraphNode_MakeDynamicAdditive;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MakeDynamicAdditive;
	static C(Other: UObject | any): AnimGraphNode_MakeDynamicAdditive;
}

declare class AnimNode_MeshSpaceRefPose extends AnimNode_Base { 
	clone() : AnimNode_MeshSpaceRefPose;
	static C(Other: UObject | any): AnimNode_MeshSpaceRefPose;
}

declare class AnimGraphNode_MeshRefPose extends AnimGraphNode_Base { 
	UNode: AnimNode_MeshSpaceRefPose;
	static Load(ResourceName: string): AnimGraphNode_MeshRefPose;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_MeshRefPose;
	static GetDefaultObject(): AnimGraphNode_MeshRefPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MeshRefPose;
	static C(Other: UObject | any): AnimGraphNode_MeshRefPose;
}

declare type EBoneModificationMode = 'BMM_Ignore' | 'BMM_Replace' | 'BMM_Additive';
declare var EBoneModificationMode : { BMM_Ignore:'BMM_Ignore',BMM_Replace:'BMM_Replace',BMM_Additive:'BMM_Additive', };
declare class AnimNode_ModifyBone extends AnimNode_SkeletalControlBase { 
	BoneToModify: BoneReference;
	Translation: Vector;
	Rotation: Rotator;
	Scale: Vector;
	TranslationMode: EBoneModificationMode;
	RotationMode: EBoneModificationMode;
	ScaleMode: EBoneModificationMode;
	TranslationSpace: EBoneControlSpace;
	RotationSpace: EBoneControlSpace;
	ScaleSpace: EBoneControlSpace;
	clone() : AnimNode_ModifyBone;
	static C(Other: UObject | any): AnimNode_ModifyBone;
}

declare class AnimGraphNode_ModifyBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ModifyBone;
	static Load(ResourceName: string): AnimGraphNode_ModifyBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ModifyBone;
	static GetDefaultObject(): AnimGraphNode_ModifyBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ModifyBone;
	static C(Other: UObject | any): AnimGraphNode_ModifyBone;
}

declare type EModifyCurveApplyMode = 'Add' | 'Scale' | 'Blend';
declare var EModifyCurveApplyMode : { Add:'Add',Scale:'Scale',Blend:'Blend', };
declare class AnimNode_ModifyCurve extends AnimNode_Base { 
	SourcePose: PoseLink;
	ApplyMode: ApplyMode;
	CurveValues: number[];
	CurveNames: string[];
	Alpha: number;
	clone() : AnimNode_ModifyCurve;
	static C(Other: UObject | any): AnimNode_ModifyCurve;
}

declare class AnimGraphNode_ModifyCurve extends AnimGraphNode_Base { 
	UNode: AnimNode_ModifyCurve;
	static Load(ResourceName: string): AnimGraphNode_ModifyCurve;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ModifyCurve;
	static GetDefaultObject(): AnimGraphNode_ModifyCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ModifyCurve;
	static C(Other: UObject | any): AnimGraphNode_ModifyCurve;
}

declare class AnimNode_MultiWayBlend extends AnimNode_Base { 
	Poses: PoseLink[];
	DesiredAlphas: number[];
	bAdditiveNode: boolean;
	bNormalizeAlpha: boolean;
	AlphaScaleBias: InputScaleBias;
	clone() : AnimNode_MultiWayBlend;
	static C(Other: UObject | any): AnimNode_MultiWayBlend;
}

declare class AnimGraphNode_MultiWayBlend extends AnimGraphNode_Base { 
	UNode: AnimNode_MultiWayBlend;
	static Load(ResourceName: string): AnimGraphNode_MultiWayBlend;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_MultiWayBlend;
	static GetDefaultObject(): AnimGraphNode_MultiWayBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_MultiWayBlend;
	static C(Other: UObject | any): AnimGraphNode_MultiWayBlend;
}

declare class AnimNode_ObserveBone extends AnimNode_SkeletalControlBase { 
	BoneToObserve: BoneReference;
	DisplaySpace: EBoneControlSpace;
	bRelativeToRefPose: boolean;
	Translation: Vector;
	Rotation: Rotator;
	Scale: Vector;
	clone() : AnimNode_ObserveBone;
	static C(Other: UObject | any): AnimNode_ObserveBone;
}

declare class AnimGraphNode_ObserveBone extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_ObserveBone;
	static Load(ResourceName: string): AnimGraphNode_ObserveBone;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_ObserveBone;
	static GetDefaultObject(): AnimGraphNode_ObserveBone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_ObserveBone;
	static C(Other: UObject | any): AnimGraphNode_ObserveBone;
}

declare class AnimGraphNode_PoseHandler extends AnimGraphNode_AssetPlayerBase { 
	static Load(ResourceName: string): AnimGraphNode_PoseHandler;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseHandler;
	static GetDefaultObject(): AnimGraphNode_PoseHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseHandler;
	static C(Other: UObject | any): AnimGraphNode_PoseHandler;
}

declare class AnimNode_PoseHandler extends AnimNode_AssetPlayerBase { 
	PoseAsset: PoseAsset;
	clone() : AnimNode_PoseHandler;
	static C(Other: UObject | any): AnimNode_PoseHandler;
}

declare class AnimNode_PoseBlendNode extends AnimNode_PoseHandler { 
	SourcePose: PoseLink;
	BlendOption: BlendOption;
	CustomCurve: CurveFloat;
	clone() : AnimNode_PoseBlendNode;
	static C(Other: UObject | any): AnimNode_PoseBlendNode;
}

declare class AnimGraphNode_PoseBlendNode extends AnimGraphNode_PoseHandler { 
	UNode: AnimNode_PoseBlendNode;
	static Load(ResourceName: string): AnimGraphNode_PoseBlendNode;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_PoseBlendNode;
	static GetDefaultObject(): AnimGraphNode_PoseBlendNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_PoseBlendNode;
	static C(Other: UObject | any): AnimGraphNode_PoseBlendNode;
}

declare class AnimNode_PoseByName extends AnimNode_PoseHandler { 
	PoseName: string;
	PoseWeight: number;
	clone() : AnimNode_PoseByName;
	static C(Other: UObject | any): AnimNode_PoseByName;
}

